<!DOCTYPE html>
<html lang="zh-CN">
  <head>
  <meta charset="UTF-8">
  <meta 
    name="viewport"
    content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
  <meta 
    http-equiv="X-UA-Compatible" 
    content="ie=edge">
  <meta 
    name="theme-color" 
    content="#fff" 
    id="theme-color">
  <meta 
    name="description" 
    content="simon·yian&#39;Blog">
  <link 
    rel="icon" 
    href="/">
  <title>java新特性</title>
  
    
      <meta 
        property="og:title" 
        content="java新特性">
    
    
      <meta 
        property="og:url" 
        content="https://simon-yian.github.io/2022/09/17/xianTrain26-JavaNewCharacteristic/index.html">
    
    
      <meta 
        property="og:img" 
        content="https://img.songhn.com/img/Y67gdd.png">
    
    
      <meta 
        property="og:img" 
        content="&lt;p&gt;&lt;em&gt;&lt;strong&gt;学习打卡&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;">
    
    
      <meta 
        property="og:type" 
        content="article">
      <meta 
        property="og:article:published_time" 
        content="2022-09-17">
      <meta 
        property="og:article:modified_time" 
        content="2022-09-17">
      <meta 
        property="og:article:author" 
        content="simon-yi·an Blog">
      
        
      
    
  
  
  <link rel="preload" href="//at.alicdn.com/t/font_1946621_i1kgafibvw.css" as="style" >
  <link rel="preload" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css" as="style" >
  <link rel="preload" href="/css/main.css" as="style" >
  
  <link rel="modulepreload" href="//instant.page/5.1.0">
  
  <link rel="stylesheet" href="/css/main.css">
  
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1946621_i1kgafibvw.css">
  
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css">
  
  
  
    <link rel="stylesheet" href="/js/lib/lightbox/baguetteBox.min.css">
  
  <script>
    function loadScript(url, cb) {
      var script = document.createElement('script');
      script.src = url;
      if (cb) script.onload = cb;
      script.async = true;
      document.body.appendChild(script);
    }
    function loadCSS(href, data, attr) {
      var sheet = document.createElement('link');
      sheet.ref = 'stylesheet';
      sheet.href = href;
      sheet.dataset[data] = attr;
      document.head.appendChild(sheet);
    }
    function changeCSS(cssFile, data, attr) {
      var oldlink = document.querySelector(data);
      var newlink = document.createElement("link");
      newlink.setAttribute("rel", "stylesheet");
      newlink.setAttribute("href", cssFile);
      newlink.dataset.prism = attr;
      document.head.replaceChild(newlink, oldlink);
    }
  </script>
  
    
  
  <script>
    // control reverse button
    var reverseDarkList = {
      dark: 'light',
      light: 'dark'
    };
    var themeColor = {
      dark: '#1c1c1e',
      light: '#fff'
    }
    // get the data of css prefers-color-scheme
    var getCssMediaQuery = function() {
      return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    };
    // reverse current darkmode setting function
    var reverseDarkModeSetting = function() {
      var setting = localStorage.getItem('user-color-scheme');
      if(reverseDarkList[setting]) {
        setting = reverseDarkList[setting];
      } else if(setting === null) {
        setting = reverseDarkList[getCssMediaQuery()];
      } else {
        return;
      }
      localStorage.setItem('user-color-scheme', setting);
      return setting;
    };
    // apply current darkmode setting
  </script>
  
    <script>
      var setDarkmode = function(mode) {
      var setting = mode || localStorage.getItem('user-color-scheme');
      if(setting === getCssMediaQuery()) {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[setting];
        document.getElementById('theme-color').dataset.mode = setting;
      } else if(reverseDarkList[setting]) {
        document.documentElement.setAttribute('data-user-color-scheme', setting);
        document.getElementById('theme-color').content = themeColor[setting];
        document.getElementById('theme-color').dataset.mode = setting;
      } else {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[getCssMediaQuery()];
        document.getElementById('theme-color').dataset.mode = getCssMediaQuery();
      }
    };
    setDarkmode();
    </script>
  
  
  
    <link rel="preload" href="/js/lib/lightbox/baguetteBox.min.js" as="script">
    <link rel="preload" href="/js/lib/lightbox/baguetteBox.min.css" as="style" >
  
  
    <link rel="preload" href="/js/lib/lozad.min.js" as="script">
  
  
  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>

  <body>
    <div class="wrapper">
       
      <nav class="navbar">
  <div class="navbar-logo">
    <a class="navbar-logo-main" href="/">
      
      <span class="navbar-logo-dsc">simon-yi·an</span>
      </a>
  </div>
  <div class="navbar-menu">
    
      <a 
        href="/" 
        class="navbar-menu-item">
        
          首页
        
      </a>
    
      <a 
        href="/archives" 
        class="navbar-menu-item">
        
          归档
        
      </a>
    
      <a 
        href="/tags" 
        class="navbar-menu-item">
        
          标签
        
      </a>
    
      <a 
        href="/categories" 
        class="navbar-menu-item">
        
          分类
        
      </a>
    
      <a 
        href="/about" 
        class="navbar-menu-item">
        
          关于
        
      </a>
    
      <a 
        href="/links" 
        class="navbar-menu-item">
        
          友链
        
      </a>
    
    <button 
      class="navbar-menu-item darknavbar navbar-menu-btn" 
      aria-label="Toggle dark mode"
      id="dark">
      <i class="iconfont icon-weather"></i>
    </button>
    <button 
      class="navbar-menu-item searchnavbar navbar-menu-btn" 
      aria-label="Toggle search"
      id="search">
      <!-- <i 
        class="iconfont icon-search" 
        style="font-size: 1.2rem; font-weight: 400;">
      </i> -->
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img"
        class="iconify iconify--ion" width="28" height="28" preserveAspectRatio="xMidYMid meet" viewBox="0 0 512 512">
        <path fill="none" stroke="currentColor" stroke-miterlimit="10" stroke-width="28"
          d="M256 80a176 176 0 1 0 176 176A176 176 0 0 0 256 80Z"></path>
        <path fill="none" stroke="currentColor" stroke-miterlimit="10" stroke-width="28"
          d="M232 160a72 72 0 1 0 72 72a72 72 0 0 0-72-72Z"></path>
        <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="28"
          d="M283.64 283.64L336 336"></path>
      </svg>
    </button>
  </div>
</nav> 
      
      <div 
        id="local-search" 
        style="display: none">
        <input
          class="navbar-menu-item"
          id="search-input"
          placeholder="请输入搜索内容..." />
        <div id="search-content"></div>
      </div>
      
      <div class="section-wrap">
        <div class="container">
          <div class="columns">
            <aside class="left-column">
              
              <div class="card card-author">
                
  <img 
    src="https://img.songhn.com/img/Y67gdd.png" 
    class="author-img"
    width="88"
    height="88"
    alt="author avatar">

<p class="author-name">simon-yi·an Blog</p>
<p class="author-description">designed by simon-yi·an</p>
<div class="author-message">
  <a 
    class="author-posts-count" 
    href="/archives">
    <span>38</span>
    <span>文章</span>
  </a>
  <a 
    class="author-categories-count" 
    href="/categories">
    <span>9</span>
    <span>分类</span>
  </a>
  <a 
    class="author-tags-count" 
    href="/tags">
    <span>0</span>
    <span>标签</span>
  </a>
</div>

              </div>
               <div class="sticky-tablet">
  
  
    <article class="display-when-two-columns spacer">
      <div class="card card-content toc-card">
        <div class="toc-header">
  <i 
    class="iconfont icon-menu" 
    style="padding-right: 2px;">
  </i>目录
</div>

      </div>
    </article>
  
  
  <article class="card card-content categories-widget">
    <div class="categories-card">
  <div class="categories-header">
    <i 
      class="iconfont icon-fenlei" 
      style="padding-right: 2px;">
    </i>分类
  </div>
  <div class="categories-list">
    
      <a href="/categories/algorithm/">
        <div class="categories-list-item">
          algorithm
          <span class="categories-list-item-badge">2</span>
        </div>
      </a>
    
      <a href="/categories/LeetCode/">
        <div class="categories-list-item">
          LeetCode
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
      <a href="/categories/Python%E7%AC%94%E8%AE%B0/">
        <div class="categories-list-item">
          Python笔记
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
      <a href="/categories/VMware/">
        <div class="categories-list-item">
          VMware
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
      <a href="/categories/XiAnTrain/">
        <div class="categories-list-item">
          XiAnTrain
          <span class="categories-list-item-badge">17</span>
        </div>
      </a>
    
      <a href="/categories/fatal/">
        <div class="categories-list-item">
          fatal
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
      <a href="/categories/hexo/">
        <div class="categories-list-item">
          hexo
          <span class="categories-list-item-badge">3</span>
        </div>
      </a>
    
      <a href="/categories/XiAnTrain-java%E9%AB%98%E7%BA%A7%E7%AF%87/">
        <div class="categories-list-item">
          XiAnTrain-java高级篇
          <span class="categories-list-item-badge">7</span>
        </div>
      </a>
    
      <a href="/categories/XiAnTrain-java%E5%88%9D%E7%BA%A7%E7%AF%87/">
        <div class="categories-list-item">
          XiAnTrain-java初级篇
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
  </div>
</div>
  </article>
  
  <article class="card card-content tags-widget">
    <div class="tags-card">
  <div class="tags-header">
    <i 
      class="iconfont icon-biaoqian" 
      style="padding-right: 2px;">
    </i>热门标签
  </div>
  <div class="tags-list">
    
  </div>
</div>
  </article>
  
  
</div>
            </aside>
            <main class="main-column">
              
<article class="card card-content">
  <header>
    <h1 class="post-title">
      java新特性
    </h1>
  </header>
  <div class="post-meta post-show-meta">
    <time datetime="2022-09-17T08:20:16.000Z">
      <i 
        class="iconfont icon-calendar" 
        style="margin-right: 2px;">
      </i>
      <span>2022-09-17</span>
    </time>
    
      <span class="dot"></span>
      
        <a 
          href="/categories/XiAnTrain-java%E9%AB%98%E7%BA%A7%E7%AF%87/" 
          class="post-meta-link">
          XiAnTrain - java高级篇
        </a>
      
    
    
      <span class="dot"></span>
      <span>5.1k 字</span>
    
  </div>
  
  </header>
  <div 
    id="section" 
    class="post-content">
    <p><em><strong>学习打卡</strong></em></p>
<span id="more"></span>
<p>Lambda表达式是Java8中新增的特性，lambda表达式是一个可传递的代码块，可以在以后执行一次或多次。在以前定义的方法中，只能将基本类型或者引用类型的变量作为方法参数，在Java 8以后可以将一个代码片段作为方法参数。</p>
<p>19.1 Lambda表达式入门<br>在集合中Java为开发者提供了遍历集合的简洁方式，如下例所示：</p>
<p>package cn.bytecollege;</p>
<p>import java.util.List;<br>import java.util.ArrayList;<br>public class LambdaDemo {<br>    public static void main(String[] args) {<br>        List<String> list = new ArrayList&lt;&gt;();</String></p>
<pre><code>    list.add(&quot;张三&quot;);
    list.add(&quot;李四&quot;);
    list.add(&quot;王五&quot;);
    
    list.forEach(e-&gt;System.out.println(e));
&#125;
</code></pre>
<p>}</p>
<p>在上面的示例中，调用了list对象的foreach方法，从程序可以看出，传入foreach的并不是一个变量，而是一段代码，这就是Lambda表达式。从上面的语法可以看出，Lambda表达式的主要作用就是代替匿名内部类的烦琐语法。<br>Lambda由3部分组成：</p>
<p>形参列表：形参列表允许省略形参的数据类型，如果形参列表中有且只有1个参数，可以省略形参列表的括号<br>箭头函数：-&gt;必须有横线和大于号组成<br>代码块。如果代码块只包含一条语句，Lambda表达式允许省略代码块的花括号。<br>下面，通过示例来学习Lambda的写法：</p>
<p>//表达式只有1个参数<br>(a)-&gt;{<br>    System.out.print(a);<br>}<br>//表达式可以简写为<br>a-&gt;{<br>    System.out.print(a);<br>}<br>//如果代码块中只有1条语句，可以省略大括号<br>a-&gt;System.out.print(a)</p>
<p>19.2 函数式接口<br>Lambda表达式的目标类型必须是函数式接口，所谓函数式接口代表只包含一个抽象方法的接口，函数式接口可以包含多个默认方法、类方法，但是只能声明一个抽象方法。</p>
<p>如果采用匿名内部类语法来创建函数式接口的实例，则只需要实现一个抽象方法，在这种情况下可采用Lambda表达式来创建对象。</p>
<p>注意：Java8 专门为函数式接口提供了@FunctionalInterface注解，该注解通常放在接口定义前，该注解对程序功能没有任何作用，它的作用是用于告诉编译器执行更严格的检查，检查该接口必须是函数式接口，否则编译器出错。</p>
<p>Lambda表达式的结果就是被作为对象，程序中晚期可以使用Lambda表达式进行赋值，例如在多线程Thread类的构造器中可以传入Runnable接口的子类对象。查看Runnable接口发现，该接口也被声明为一个函数式接口：</p>
<p>@FunctionalInterface<br>public interface Runnable {<br>    public abstract void run();<br>}<br>所以，就可以使用Lambda表达式来创建线程：</p>
<p>package cn.bytecollege;<br>public class ThreadLambdaDemo {<br>    public static void main(String[] args) {<br>        Thread thread = new Thread(()-&gt;{<br>            for (int i = 0; i &lt; 10; i++) {<br>                System.out.println(i);<br>            }<br>        });<br>        thread.start();<br>    }<br>}<br>Lambda 表达式实现的是匿名方法——因此它只能实现特定函数式接口中的唯一方法。这意味着 Lambda 表达式有如下两个限制。</p>
<p>Lambda 表达式的目标类型必须是明确的函数式接口。<br>Lambda 表达式只能为函数式接口创建对象。Lambda 表达式只能实现一个方法，因此它只能为 只有一个抽象方法的接口（函数式接口）创建对象。<br>下面定义一个函数式接口深入学习Lambda表达式</p>
<p>package cn.bytecollege;<br>//函数式接口只能有一个抽象方法，并且要使用@FunctionalInterface声明<br>@FunctionalInterface<br>public interface Consumer {<br>    int add(int a,int b);<br>}</p>
<p>定义一个方法，方法参数是Consumer接口：</p>
<p>package cn.bytecollege;</p>
<p>public class MyTest {<br>    public static int test(Consumer consumer) {<br>        int a = 5;<br>        int b = 4;<br>        return consumer.add(a, b);</p>
<pre><code>&#125;
public static void main(String[] args) &#123;
    int k = test((a,b)-&gt;&#123;
        return a+b;
    &#125;);
    System.out.println(k);
&#125;
</code></pre>
<p>}</p>
<p>在上例中定义了一个函数式接口，在测试类的test方法传入了接口并调用了Consumer接口的add方法，需要注意的是，此时add方法并没有方法实现，在main方法中调用了test，并将一段代码（即add方法的实现）也就是lambda表达式当做参数传入了test方法。换句话说在上例中使用了lambda表达替代了烦琐的匿名内部类。对比下面的代码就可以看出Lambda表达式的独到之处。</p>
<p>package cn.bytecollege;</p>
<p>public class MyTest {<br>    public static int test(Consumer consumer) {<br>        int a = 5;<br>        int b = 4;<br>        return consumer.add(a, b);</p>
<pre><code>&#125;
public static void main(String[] args) &#123;
    int k = test(new Consumer() &#123;
        @Override
        public int add(int a, int b) &#123;
            return a+b;
        &#125;
    &#125;);
    System.out.println(k);
&#125;
</code></pre>
<p>}</p>
<p>从前面的程序可以看出Lambda表达式的使用离不开函数式接口，通常函数式接口中有且只能有1个抽象方法，这样使用Lambda表达式时也就明确了是哪个抽象方法的实现，如果接口中出现了多个抽象方法，那么就不能在接口上使用@FunctionInterface注解，会编译出错。因此，Java 8在java.util.function包中预定义了大量函数式接口，通常情况下这些接口完全可以满足开发需要：</p>
<p>XxxFunction∶ 这类接口中通常包含一个 apply()抽象方法，该方法对参数进行处理、转换（apply() 方法的处理逻辑由 Lambda 表达式来实现），然后返回一个新的值。该函数式接口通常用于对指定数据进行转换处理。<br>XxxConsumer∶ 这类接口中通常包含一个 accept()抽象方法，该方法与 XxxFunction 接口中的 apply()方法基本相似，也负责对参数进行处理，只是该方法不会返回处理结果。<br>XxxxPredicate∶这类接口中通常包含一个 test()抽象方法，该方法通常用来对参数进行某种判断 test()方法的判断逻辑由 Lambda 表达式来实现），然后返回一个 boolean 值。该接口通常用于判断参数是否满足特定条件，经常用于进行筛滤数据。<br>XxxSupplier∶ 这类接口中通常包含一个 getAsXxx()抽象方法，该方法不需要输入参数，该方法会按某种逻辑算法（getAsXxx()方法的逻辑算法由 Lambda 表达式来实现）返回一个数据。综上所述，不难发现 Lambda 表达式的本质很简单，就是使用简洁的语法来创建函数式接口的实例——这种语法避免了匿名内部类的烦琐。<br>下面在程序中示范上述接口的使用：</p>
<p>package cn.bytecollege.lambda;</p>
<p>import java.util.function.Function;</p>
<p>/**</p>
<ul>
<li>数据转换</li>
<li>@author MR.W</li>
<li></li>
<li>/<br>public class CastUtil {<br>  /**<ul>
<li>定义方法将Object类型转换为String类型</li>
<li>@param function</li>
<li>@param o</li>
<li>@return</li>
<li>/<br>public static String castToString(Function&lt;Object, String&gt; function, Integer a) {<br>  return function.apply(a);<br>}<br>}</li>
</ul>
</li>
</ul>
<p>在上面的CastUtil类中定义了castToString，在该方法中第一个参数是一个Java 8 预定义的函数式接口，在方法内调用了Function接口的apply()方法，作用是将任意类型转换成String。但是此时这个方法并没有方法的实现，需要在调用此方法时传入方法的实现。</p>
<p>package cn.bytecollege.lambda;<br>import java.util.function.Function;<br>public class Test {<br>    public static void main(String[] args) {<br>        Integer a = 10010;<br>        //使用Lambda表达式，此时castToString方法的第一个参数<br>        //就是Function函数式接口apply()的实现<br>        String s = CastUtil.castToString((o)-&gt;{<br>            return String.valueOf(o);<br>        }, a);<br>        System.out.println(s);<br>    }<br>}<br>在测试类中，调用了CastUtil的castToString()方法，并传入了Lambda表达式，以此Lambda表达式作为apply()方法的实现，在表达式中使用了String.valueOf()方法将对象转换成String类型。</p>
<p>19.3 方法引用与构造器引用<br>前面已经介绍过，如果Lambda 表达式的代码块只有一条代码，程序就可以省略 Lambda 表达式中代码块的花括号。不仅如此，如果Lambda 表达式的代码块只有一条代码，还可以在代码块中使用方法引用和构造器引用。 方法引用和构造器引用可以让 Lambda表达式的代码块更加简洁。方法引用和构造器引用都需要使用两个英文冒号。<br>Lambda 表达式支持如下表所示的几种引用方式。 </p>
<p>19.3.1 引用类方法<br>下面的示例将演示类方法的引用，首先定义一个函数式接口，接口中定义抽象方法castToString()，该方法的作用是将一个对象转换成String对象。</p>
<p>package cn.bytecollege.lambda;<br>@FunctionalInterface<br>public interface Function&lt;T,R&gt; {<br>    R castToString(T t);<br>}</p>
<p>在String的学习中可以知道，String类有提供了类方法valueOf(Object o)，该方法可以将任意对象转换成String类型，因此可以使用该方法作为Lambda表达式的实现代码：</p>
<p>package cn.bytecollege.lambda;</p>
<p>public class RefTest {<br>    public static void main(String[] args) {<br>        Function&lt;Object, String&gt; function = a-&gt;{<br>            return String.valueOf(a);<br>        };<br>        System.out.println(function.castToString(“张三”));<br>    }<br>}</p>
<p>在上面的代码中，创建了Lambda表达式作为了Function接口中castToString()方法的实现。在Lambda表达式中调用了String.valueOf()方法来进行对象到字符串的转换，在代码第8行调用了function接口的castToString()方法，实际上调用了就是代码第5行创建的Lambda表达式。<br>上面的Lambda表达式的代码块只有一行调用类方法的代码，因此可以使用如下方法引用进行替换。代码如下：</p>
<p>package cn.bytecollege.lambda;</p>
<p>public class RefTest {<br>    public static void main(String[] args) {<br>        Function&lt;Object, String&gt; function = String::valueOf;<br>        System.out.println(function.castToString(“张三”));<br>    }<br>}</p>
<p>对于上面的类方法的引用，也就是调用了String类的valueOf()方法来实现Function函数式接口中唯一抽象方法。当调用castToString()方法时，调用参数将会传给String类的valueOf()类方法。</p>
<p>19.3.2 引用对象的实例方法<br>下面演示第二种方法引用，引用对象的实例方法，首先使用Lambda表达式创建一个Function接口的子类对象：</p>
<p>Function&lt;Object, String&gt; function = o-&gt;o.toString();<br>上面的Lambda表达式只有一条语句，因此省略了该代码的花括号。<br>接下来程序调用function对象的castToString()方法：</p>
<p>package cn.bytecollege.lambda;<br>public class RefTest {<br>    public static void main(String[] args) {<br>        Function&lt;Object, String&gt; function = o-&gt;o.toString();<br>        System.out.println(function.castToString(100));<br>    }<br>}</p>
<p>上面的程序调用了function对象的castToString()方法时，由于function对象是Lambda表达式创建，castToString()方法的执行体就是Lambda表达式的代码部分，因此上面的程序输出了100.<br>上面的Lambda表达式代码只有一行，且调用了对象的o的toString()实例方法。因此代码可以进行如下替换：</p>
<p>package cn.bytecollege.lambda;<br>public class RefTest {<br>    public static void main(String[] args) {<br>        Function&lt;Object, String&gt; function = Object::toString;<br>        System.out.println(function.castToString(100));<br>    }<br>}</p>
<p>上面的Lambda表达式的代码只有一条语句，因此省略了代码块的花括号；而且由于表达式实现的castToString方法需要返回值，因此Lambda表达会将这行代码的值作为返回值。此时就可以使用方法引用进行替换，直接引用Object的toString()方法作为Lambda表达式的代码块。其中Function接口的castToString方法有个参数，当执行Lambda表达式代码块时，会自动调用传入参数的toString()方法。</p>
<p>19.3.3 引用构造器<br>下面的实例将演示如何引用构造器，首先定义函数式接口：</p>
<p>package cn.bytecollege.lambda;<br>@FunctionalInterface<br>public interface MyInterface {<br>    StringBuilder get(String s);<br>}</p>
<p>该函数式接口包含了一个get()抽象方法，该方法的作用是使用String对象生成一个StringBuilder对象，接着使用Lambda表达式创建一个MyInterface的对象：</p>
<p>package cn.bytecollege.lambda;<br>public class RefTest3 {<br>    public static void main(String[] args) {<br>        MyInterface myInterface = (s)-&gt; new StringBuilder(s);<br>        StringBuilder sb = myInterface.get(“张三”);<br>    }<br>}<br>上面的代码调用了myInterface对象的get()方法时，由于该对象是Lambda表达式创建的，因此get()方法执行体就是Lambda表达式的代码块部分，即执行体就是执行new StringBuilder(a)语句，并将这条语句的值作为方法的返回值。因此上面代码中Lambda表达式的代码可以进行如下替换：</p>
<p>package cn.bytecollege.lambda;</p>
<p>public class RefTest3 {<br>    public static void main(String[] args) {<br>        MyInterface myInterface = StringBuilder::new;<br>        StringBuilder sb = myInterface.get(“张三”);<br>    }<br>}</p>
<p>对于上面的构造器引用，也就是调用StringBuilder类的构造方法来实现MyInteface函数式接口中唯一的抽象方法，当调用MyInterface接口的test()方法是，调用参数会传给StringBuilder构造器，从上面的程序中可以看出，调用myInterface对象的get()方法时，实际只传入了一个String类型的参数，这个String类型的参数会被传给StringBuilder的构造器。</p>
<p>19.4 Lambda表达式和匿名内部类的联系和区别<br>从前面介绍可以看出，Lambda 表达式是匿名内部类的一种简化，因此它可以部分取代匿名内部类的作用，Lambda 表达式与匿名内部类存在如下相同点。</p>
<p>Lambda 表达式与匿名内部类一样，都可以直接访问”effectively final”的局部变量，以及外部 类的成员变量（包括实例变量和类变量）。<br>Lambda 表达式创建的对象与匿名内部类生成的对象一样，都可以直接调用从接口中继承的默认 方法。<br>首先创建函数式接口：</p>
<p>package cn.bytecollege.ano;<br>@FunctionalInterface<br>public interface Display {<br>    int add(int a,int b);</p>
<pre><code>default void print() &#123;
    System.out.println(&quot;Hello!&quot;);
&#125;
</code></pre>
<p>}</p>
<p>package cn.bytecollege.ano;</p>
<p>public class LambdaTest {<br>    private int age = 18;<br>    private static String name = “Byte科技”;</p>
<pre><code>public void test() &#123;
    String book = &quot;Java编程思想&quot;;
    Display display = (a,b)-&gt;&#123;
        //访问外部类的实例变量
        System.out.println(age);
        //访问外部类的类变量
        System.out.println(name);
        //访问局部变量
        System.out.println(book);
        return a+b;
    &#125;;
    //调用display对象从接口继承的默认方法
    display.print();
</code></pre>
<p>//        book = “Java核心技术卷”;<br>        System.out.println(display.add(1, 2));<br>    }<br>}</p>
<p>创建测试类：</p>
<p>package cn.bytecollege.ano;</p>
<p>public class Test {<br>    public static void main(String[] args) {<br>        LambdaTest test = new LambdaTest();<br>        test.test();<br>    }<br>}</p>
<p>上面的程序使用Lambda表达式创建了一个Display接口的对象，Lambda表达式分别访问了外部类的实例变量，类变量从这些来看Lambda表达式的代码块和匿名内部类的方法体是相同的。<br>和匿名内部类相似，由于Lambda表达式访问了了book局部变量，因此该局部变量相当于有一个隐式的final修饰，不允许对book局部变量重新赋值。<br>当程序使用 Lambda 表达式创建了 Display 的对象之后，该对象不仅可调用接口中唯一的抽象方法，也可调用接口中的默认方法。<br>Lambda表达式与匿名内部类主要存在如下区别:</p>
<p>匿名内部类可以为任意接口创建实例——不管接口包含多少个抽象方法，只要匿名内部类实现 所有的抽象方法即可;但 Lambda 表达式只能为函数式接口创建实例。<br>匿名内部类可以为抽象类甚至普通类创建实例;但 Lambda 表达式只能为函数式接口创建实例。<br>匿名内部类实现的抽象方法的方法体允许调用接口中定义的默认方法;但 Lambda 表达式的代 码块不允许调用接口中定义的默认方法。 <br>19.5 Stream<br>Java8 还新增了Stream、IntStream、LongStream、DoubleStream等流式API（注意：这里的Stream并不是IO中的Stream），这些API代表多个支持串行和并行聚集操作的元素。上面的4个接口中，Stream是一个通用的流接口，而IntStream、LongStream、DoubleStream则代表元素类型为int、long、double的流。<br>Java 8 还为上面每个流式 API 提供了对应的 Builder，例如 Stream.Builder、IntStream.Builder、 LongStream.Builder、DoubleStream.Builder，开发者可以通过这些 Builder 来创建对应的流 独立使用 Stream 的步骤如下∶</p>
<p>使用 Stream 或 XxxStream 的 builder()类方法创建该 Stream 对应的 Builder。<br>重复调用 Builder 的 add()方法向该流中添加多个元素。<br>调用 Builder 的 build()方法获取对应的 Stream。<br>调用 Stream 的聚集方法。<br>Stream提供了大量的方法进行聚集操作，这些方法可以是中间的，也可以是末端的。</p>
<p>中间方法∶中间操作允许流保持打开状态，并允许直接调用后续方法。也就是说中间方法可以连续调用。<br>末端方法; 末端方法是对流的最终操作。当对某个 Stream 执行末端方法后，该流将会被”消耗” 且不再可用。换句话说就是末端方法一旦调用后就会关闭流，再不能对流进行操作，否则会抛出异常。<br>下面先介绍Stream常用的中间方法：</p>
<p>filter(Predicate predicate)∶ 过滤 Stream 中所有不符合 predicate 的元素。<br>mapToXxx(ToXxxFunction mapper)∶使用 ToXxxFunction 对流中的元素执行一对一的转换，该方 法返回的新流中包含了ToXxxFunction 转换生成的所有元素。<br>peek(Consumer action)∶ 依次对每个元素执行一些操作，该方法返回的流与原有流包含相同的元 素。该方法主要用于调试。<br>distinct()∶该方法用于排序流中所有重复的元素（判断元素重复的标准是使用 equals（）比较返回 true）。这是一个有状态的方法。<br>sorted()∶该方法用于保证流中的元素在后续的访问中处于有序状态。这是一个有状态的方法。<br>limit(long maxSize)∶ 该方法用于保证对该流的后续访问中最大允许访问的元素个数。这是一个 有状态的、短路方法。<br>下面简单介绍一下 Stream 常用的末端方法。</p>
<p>forEach(Consumer action)∶ 遍历流中所有元素，对每个元素执行 action。<br>toArray()∶将流中所有元素转换为一个数组。<br>reduce（）∶该方法有三个重载的版本，都用于通过某种操作来合并流中的元素。<br>min()∶ 返回流中所有元素的最小值。<br>max()∶ 返回流中所有元素的最大值。<br>count()∶ 返回流中所有元素的数量。<br>anyMatch(Predicate predicate)：判断流中是否至少包含一个元素符合 Predicate 条件。<br>allMatch(Predicate predicate)：判断流中是否每个元素都符合 Predicate 条件。<br>noneMatch(Predicate predicate)∶判断流中是否所有元素都不符合 Predicate 条件。<br>findFirst()∶ 返回流中的第一个元素。<br>findAny()∶返回流中的任意一个元素。<br>下面，通过示例来学习Stream的使用：</p>
<p>package cn.bytecollege.stream;</p>
<p>import java.util.stream.IntStream;</p>
<p>public class IntStreamTest {<br>    public static void main(String[] args) {<br>        IntStream is = IntStream.builder()<br>                .add(100)<br>                .add(10)<br>                .add(30)<br>                .add(40)<br>                .build();<br>        //调用聚集方法,下列方法都是末端方法，因此同时只能调用1个<br>//        System.out.println(“最大值：”+is.max().getAsInt());<br>//        System.out.println(“最小值：”+is.min().getAsInt());<br>//        System.out.println(“总和：”+is.sum());<br>//        System.out.println(“总数”+is.count());<br>//        System.out.println(“平均值”+is.average());<br>//        System.out.println(“判断所有元素的是否都大于10:”+is.allMatch(e-&gt;e&gt;10));<br>//        System.out.println(“判断是否任意一个元素都大于10:”+is.anyMatch(e-&gt;e&gt;20));</p>
<pre><code>    is.forEach(System.out::println);
    
&#125;
</code></pre>
<p>}<br>除此之外，Java8允许使用流式API来操作集合，这也是Stream的重要使用场景之一，Collection接口提供了stream()默认方法，该方法可以返回该集合对应的流，下面使用Stream来操作集合。</p>
<p>package cn.bytecollege.stream;</p>
<p>import java.util.ArrayList;<br>import java.util.List;<br>import java.util.stream.Stream;</p>
<p>public class ListStreamDemo {<br>    public static void main(String[] args) {</p>
<pre><code>    List&lt;String&gt; list = new ArrayList&lt;&gt;();
    //list中添加元素
    list.add(&quot;Java编程思想&quot;);
    list.add(&quot;Java核心技术卷&quot;);
    list.add(&quot;Effective Java&quot;);
    list.add(&quot;Spring 入门与精通&quot;);
    list.add(&quot;并发编程之美&quot;);
    //获取Stream
    Stream&lt;String&gt; stream = list.stream();
    //统计包含Java字符串的元素总数
</code></pre>
<p>//        System.out.println(stream.filter(e-&gt;e.contains(“Java”)).count());<br>        //取出前3个元素<br>        stream.limit(3).forEach(System.out::println);<br>    }<br>}</p>
<p>在上面的实例中首先获取了List的Stream，在代码20行对stream进行了过滤，筛选出了包含Java的字符串，然后调用了count()统计了过滤后的字符串个数。因为count()是末端方法，因此调用后再不能进行后续操作。代码22行是用limit取出了前3个元素，并对其进行了遍历。<br>需要注意的是，Stream对集合的操作并不影响List中保存的数据。</p>

  </div>
  <div>
    
      <div 
        class="post-note note-warning copyright" 
        style="margin-top: 42px">
        <p>
          <span style="font-weight: bold;">作者：</span><a 
            target="_blank" 
            rel="nofollow noopener noreferrer" 
            href="/about">
            simon-yi·an Blog
          </a>
        </p>
        <p>
          <span style="font-weight: bold;">文章链接：</span><a 
            target="_blank" 
            rel="nofollow noopener noreferrer" 
            href="https://simon-yian.github.io/2022/09/17/xianTrain26-JavaNewCharacteristic/">
            https://simon-yian.github.io/2022/09/17/xianTrain26-JavaNewCharacteristic/
          </a>
        </p>
        <p><span style="font-weight: bold;">版权声明：</span>本博客所有文章除特别声明外，均采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0 协议</a>。转载请注明出处！</p>
      </div>
    
  </div>
</article>
<div class="nav">
  
    <div class="nav-item-prev">
      <a 
        href="/2022/09/17/jvmCommonParameters/" 
        class="nav-link">
        <i class="iconfont icon-left nav-prev-icon"></i>
        <div>
          <div class="nav-label">上一篇</div>
          
            <div class="nav-title">JVM常用参数 </div>
          
        </div>
      </a>
    </div>
  
  
    <div class="nav-item-next">
      <a 
        href="/2022/09/17/xianTrain24-reflex/" 
        class="nav-link">
        <div>
          <div class="nav-label">下一篇</div>
          
            <div class="nav-title">反射和注解 </div>
          
        </div>
        <i class="iconfont icon-right nav-next-icon"></i>
      </a>
    </div>
  
</div>

<div 
  class="card card-content toc-card" 
  id="mobiletoc">
  <div class="toc-header">
  <i 
    class="iconfont icon-menu" 
    style="padding-right: 2px;">
  </i>目录
</div>

</div>
            </main>
            <aside class="right-column">
              <div class="sticky-widescreen">
  
  
    <article class="card card-content toc-card">
      <div class="toc-header">
  <i 
    class="iconfont icon-menu" 
    style="padding-right: 2px;">
  </i>目录
</div>

    </article>
  
  
  <article class="card card-content">
    <div class="recent-posts-card">
  <div class="recent-posts-header">
    <i 
      class="iconfont icon-wenzhang_huaban" 
      style="padding-right: 2px;">
    </i>最近文章
  </div>
  <div class="recent-posts-list">
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2022-09-17</div>
        <a href="/2022/09/17/jvmCommonParameters/"><div class="recent-posts-item-content">JVM常用参数</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2022-09-17</div>
        <a href="/2022/09/17/xianTrain26-JavaNewCharacteristic/"><div class="recent-posts-item-content">java新特性</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2022-09-17</div>
        <a href="/2022/09/17/xianTrain24-reflex/"><div class="recent-posts-item-content">反射和注解</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2022-08-10</div>
        <a href="/2022/08/10/xianTrain21-IOStream/"><div class="recent-posts-item-content">IO流</div></a>
      </div>
    
  </div>
</div>
  </article>
  
  
</div>
            </aside>
          </div>
        </div>
      </div>
    </div>
     
    <footer class="footer">
  <div class="footer-container">
    <div>
      <div class="footer-dsc">
        <span>
          Copyright ©
          
            2020
          
          
                - 
                2022
          
        </span>
        &nbsp;
        <a 
          href="/" 
          class="footer-link">
          simon-yi·an
        </a>
      </div>
    </div>

    
      <div class="footer-dsc">
        
          Powered by
          <a 
            href="https://hexo.io/" 
            class="footer-link" 
            target="_blank" 
            rel="nofollow noopener noreferrer">
            &nbsp;Hexo
          </a>
        
        
          <span>&nbsp;|&nbsp;</span>
        
        
          Theme -
          <a 
            href="https://github.com/theme-kaze" 
            class="footer-link" 
            target="_blank"
            rel="nofollow noopener noreferrer">
            &nbsp;Kaze
          </a>
        
      </div>
    
    
    
    
</footer>
 
    
  <a 
    role="button" 
    id="scrollbutton" 
    class="basebutton" 
    aria-label="回到顶部">
    <i class="iconfont icon-arrowleft button-icon"></i>
  </a>

<a 
  role="button" 
  id="menubutton"
  aria-label="menu button"
  class="basebutton">
  <i class="iconfont icon-menu button-icon"></i>
</a>
<a 
  role="button" 
  id="popbutton" 
  class="basebutton" 
  aria-label="控制中心">
  <i class="iconfont icon-expand button-icon"></i>
</a>
<a 
  role="button" 
  id="darkbutton" 
  class="basebutton darkwidget" 
  aria-label="夜色模式">
  <i class="iconfont icon-weather button-icon"></i>
</a>
<a 
  role="button" 
  id="searchbutton" 
  class="basebutton searchwidget" 
  aria-label="搜索">
  <i class="iconfont icon-search button-icon"></i>
</a> 
     
     
     
      <script>
  var addImgLayout = function () {
    var img = document.querySelectorAll('.post-content img')
    var i
    for (i = 0; i < img.length; i++) {
      var wrapper = document.createElement('a')
      wrapper.setAttribute('href', img[i].getAttribute('data-src'))
      wrapper.setAttribute('aria-label', 'illustration')
      wrapper.style.cssText =
        'width: 100%; display: flex; justify-content: center;'
      if (img[i].alt) wrapper.dataset.caption = img[i].alt
      wrapper.dataset.nolink = true
      img[i].before(wrapper)
      wrapper.append(img[i])
      var divWrap = document.createElement('div')
      divWrap.classList.add('gallery')
      wrapper.before(divWrap)
      divWrap.append(wrapper)
    }
    baguetteBox.run('.gallery')
  }
</script>
<script>
  loadScript(
    "/js/lib/lightbox/baguetteBox.min.js",
    addImgLayout
  )
</script>
 
     
     
    <script src="/js/main.js"></script> 
     
    
      <script>
        var addLazyload = function () {
          var observer = lozad('.lozad', {
            load: function (el) {
              el.srcset = el.getAttribute('data-src')
            },
            loaded: function (el) {
              el.classList.add('loaded')
            },
          })
          observer.observe()
        }
      </script>
      <script>
        loadScript('/js/lib/lozad.min.js', addLazyload)
      </script>
    
    <script src="//instant.page/5.1.0" type="module"
      integrity="sha384-by67kQnR+pyfy8yWP4kPO12fHKRLHZPfEsiSXR8u2IKcTdxD805MGUXBzVPnkLHw"></script>
    
    
  </body>
</html>
