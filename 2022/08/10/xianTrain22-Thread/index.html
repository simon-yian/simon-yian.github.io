<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="baidu-site-verification" content="code-lKi6sS4j7S" />
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/H%20.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"simon-yian.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;Java基础学习打卡第2天">
<meta property="og:type" content="article">
<meta property="og:title" content="线程">
<meta property="og:url" content="https://simon-yian.github.io/2022/08/10/xianTrain22-Thread/index.html">
<meta property="og:site_name" content="simon·yian&#39;Blog">
<meta property="og:description" content="&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;Java基础学习打卡第2天">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/22117562/1626920386127-c24a68e4-6ca2-4ce2-b62c-a15261388ab9.png#align=left&display=inline&height=2084&id=kAo87&margin=[object%20Object]&originHeight=2084&originWidth=3252&size=0&status=done&style=none&width=3252">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/2745416/1629187967272-6014308d-e5d4-49c6-9f84-74969efffa9a.png#align=left&display=inline&height=163&id=Y2EJf&margin=[object%20Object]&name=image.png&originHeight=190&originWidth=450&size=17728&status=done&style=none&width=387">
<meta property="article:published_time" content="2022-08-10T12:03:41.000Z">
<meta property="article:modified_time" content="2022-08-19T13:32:00.000Z">
<meta property="article:author" content="simon·yi an">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.nlark.com/yuque/0/2021/png/22117562/1626920386127-c24a68e4-6ca2-4ce2-b62c-a15261388ab9.png#align=left&display=inline&height=2084&id=kAo87&margin=[object%20Object]&originHeight=2084&originWidth=3252&size=0&status=done&style=none&width=3252">


<link rel="canonical" href="https://simon-yian.github.io/2022/08/10/xianTrain22-Thread/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://simon-yian.github.io/2022/08/10/xianTrain22-Thread/","path":"2022/08/10/xianTrain22-Thread/","title":"线程"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>线程 | simon·yian'Blog</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>


  <!-- 添加萝莉-->
  <script src="/live2d-widget/autoload.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">simon·yian'Blog</h1>
      <i class="logo-line"></i>
    </a>
      <img class="custom-logo-image" src="/images/simon.png" alt="simon·yian'Blog">
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fas fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-message"><a href="/message/" rel="section"><i class="fas fa-comment fa-fw"></i>留言板</a></li>
        <li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="sitmap fa-fw"></i>站点地图</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">1 、线程和进程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1%E3%80%81%E5%AE%9A%E4%B9%89"><span class="nav-number">1.0.1.</span> <span class="nav-text">1.1、定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2%E3%80%81%E5%8C%BA%E5%88%AB"><span class="nav-number">1.0.2.</span> <span class="nav-text">1.2、区别</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E5%AE%98%E6%96%B9%E7%89%88"><span class="nav-number">1.1.</span> <span class="nav-text">非官方版</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91"><span class="nav-number">2.</span> <span class="nav-text">1.2 并行和并发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%90%AF%E5%8A%A8"><span class="nav-number">3.</span> <span class="nav-text">1.3 线程的创建和启动</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-1-%E7%BB%A7%E6%89%BFThread%E7%B1%BB"><span class="nav-number">3.0.1.</span> <span class="nav-text">1.3.1 继承Thread类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-1-1-Thread%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.0.2.</span> <span class="nav-text">1.3.1.1 Thread底层实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-number">3.1.</span> <span class="nav-text">构造器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.</span> <span class="nav-text">实例方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="nav-number">3.3.</span> <span class="nav-text">类方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="nav-number">3.4.</span> <span class="nav-text">缺点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-2-%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="nav-number">3.5.</span> <span class="nav-text">1.3.2 实现Runnable接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A-1"><span class="nav-number">3.6.</span> <span class="nav-text">缺点：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-3-%E4%BD%BF%E7%94%A8Callable%E5%92%8CFuture%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="nav-number">4.</span> <span class="nav-text">1.3.3 使用Callable和Future创建线程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%A6%82%E4%B8%8B%E6%89%80%E7%A4%BA%EF%BC%9A"><span class="nav-number">4.0.1.</span> <span class="nav-text">底层实现如下所示：</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Callable%E6%8E%A5%E5%8F%A3"><span class="nav-number">4.0.1.1.</span> <span class="nav-text">Callable接口</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Future%E6%8E%A5%E5%8F%A3"><span class="nav-number">4.0.1.2.</span> <span class="nav-text">Future接口</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">5.</span> <span class="nav-text">1.4 线程的生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-2-1-%E6%96%B0%E5%BB%BA%E5%92%8C%E5%B0%B1%E7%BB%AA%E7%8A%B6%E6%80%81"><span class="nav-number">6.</span> <span class="nav-text">15.2.1 新建和就绪状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-2-2-%E8%BF%90%E8%A1%8C%E5%92%8C%E9%98%BB%E5%A1%9E%E7%8A%B6%E6%80%81"><span class="nav-number">7.</span> <span class="nav-text">15.2.2 运行和阻塞状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#http-192-168-31-254-java-advance-%E7%AC%AC15%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80-html-15-2-3-%E7%BA%BF%E7%A8%8B%E6%AD%BB%E4%BA%A1-15-2-3-%E7%BA%BF%E7%A8%8B%E6%AD%BB%E4%BA%A1"><span class="nav-number">8.</span> <span class="nav-text">[#](http:&#x2F;&#x2F;192.168.31.254&#x2F;java-advance&#x2F;第15章 多线程基础.html#_15-2-3-线程死亡)15.2.3 线程死亡</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-%E6%8E%A7%E5%88%B6%E7%BA%BF%E7%A8%8B"><span class="nav-number"></span> <span class="nav-text">1.3 控制线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-1-Join"><span class="nav-number">0.1.</span> <span class="nav-text">1.3.1 Join</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-2-Join-long-millis"><span class="nav-number">1.</span> <span class="nav-text">1.3.2 Join(long millis)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-3-%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.1.</span> <span class="nav-text">1.3.3 守护线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-4-%E7%BA%BF%E7%A8%8B%E4%BC%91%E7%9C%A0"><span class="nav-number">1.2.</span> <span class="nav-text">1.3.4  线程休眠</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-4-1-sleep"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.3.4.1 sleep()</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-4-2-LockSupport%E7%B1%BB"><span class="nav-number">1.2.2.</span> <span class="nav-text">1.3.4.2 LockSupport类</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">底层实现方法：</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-4-3-yield-%E7%BA%BF%E7%A8%8B%E8%AE%A9%E6%AD%A5"><span class="nav-number">1.2.3.</span> <span class="nav-text">1.3.4.3 yield() 线程让步</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-5-%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">2.</span> <span class="nav-text">1.3.5 线程优先级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-6-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%81%9C%E6%AD%A2"><span class="nav-number">3.</span> <span class="nav-text">1.3.6 线程的停止</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-jMM%E6%A8%A1%E5%9E%8B"><span class="nav-number">4.</span> <span class="nav-text">1.4 jMM模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%80%A7%EF%BC%9A"><span class="nav-number">5.</span> <span class="nav-text">特性：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="nav-number">5.1.</span> <span class="nav-text">1.原子性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#http-192-168-31-254-java-advance-%E7%AC%AC15%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80-html-2-%E5%8F%AF%E8%A7%81%E6%80%A7-2-%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-number">5.2.</span> <span class="nav-text">[#](http:&#x2F;&#x2F;192.168.31.254&#x2F;java-advance&#x2F;第15章 多线程基础.html#_2-可见性)2.可见性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#http-192-168-31-254-java-advance-%E7%AC%AC15%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80-html-3-%E6%9C%89%E5%BA%8F%E6%80%A7-3-%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="nav-number">5.3.</span> <span class="nav-text">[#](http:&#x2F;&#x2F;192.168.31.254&#x2F;java-advance&#x2F;第15章 多线程基础.html#_3-有序性)3.有序性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized"><span class="nav-number">5.4.</span> <span class="nav-text">synchronized</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%90%E9%87%8D%E8%A6%81%E3%80%91synchronized%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">5.5.</span> <span class="nav-text">【重要】synchronized实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%90%E9%87%8D%E8%A6%81%E3%80%91synchronized%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89"><span class="nav-number">5.6.</span> <span class="nav-text">【重要】synchronized的内存语义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">5.7.</span> <span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E8%AF%8A%E6%96%AD"><span class="nav-number">5.8.</span> <span class="nav-text">死锁诊断</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E9%94%81"><span class="nav-number">6.</span> <span class="nav-text">同步锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%EF%BC%9A"><span class="nav-number">6.1.</span> <span class="nav-text">学习心得：</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="simon·yi an"
      src="/images/avator.jpg">
  <p class="site-author-name" itemprop="name">simon·yi an</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">37</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/simon-yian" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;simon-yian" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yourname@gmail.com" title="E-Mail → mailto:yourname@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/yourname" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://plus.google.com/yourname" title="Google → https:&#x2F;&#x2F;plus.google.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>Google</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/yourname" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



        </div><div>
  <canvas id="canvasDiyBlock" style="width:60%;">当前浏览器不支持canvas，请更换浏览器后再试</canvas><script src="/js/custom/clock.js"></script>
</div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://simon-yian.github.io/2022/08/10/xianTrain22-Thread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avator.jpg">
      <meta itemprop="name" content="simon·yi an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="simon·yian'Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          线程
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-10 20:03:41" itemprop="dateCreated datePublished" datetime="2022-08-10T20:03:41+08:00">2022-08-10</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-08-19 21:32:00" itemprop="dateModified" datetime="2022-08-19T21:32:00+08:00">2022-08-19</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/XiAnTrain-java%E9%AB%98%E7%BA%A7%E7%AF%87/" itemprop="url" rel="index"><span itemprop="name">XiAnTrain - java高级篇</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>57k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>52 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p><em><strong>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Java基础学习打卡第2天</strong></em></p>
<span id="more"></span>

<h3 id="1-、线程和进程"><a href="#1-、线程和进程" class="headerlink" title="1 、线程和进程"></a>1 、线程和进程</h3><h5 id="1-1、定义"><a href="#1-1、定义" class="headerlink" title="1.1、定义"></a>1.1、定义</h5><p>进程是资源分配的基本单位，具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。</p>
<p>线程是进程的一个实体，是独立运行和独立调度的基本单位（CPU上真正运行的是线程）。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p>
<h5 id="1-2、区别"><a href="#1-2、区别" class="headerlink" title="1.2、区别"></a>1.2、区别</h5><ul>
<li>进程是资源分配的基本单位，线程是程序执行的基本单位</li>
<li>进程拥有自己的资源空间，每启动一个进程，系统就会为它分配地址空间；而线程与CPU资源分配无关，多个线程共享同一进程内的资源，使用相同的地址空间。</li>
<li>一个进程可以有多个线程</li>
</ul>
<h4 id="非官方版"><a href="#非官方版" class="headerlink" title="非官方版"></a>非官方版</h4><p>当一个程序进入内存运行时，就会变成一个进程。进程是处于运行过程中的程序，并且具有一定的独立功能，进程是系统进行资源分配和调节的独立单位。</p>
<p>线程是进程中必不可少的一部分，一个进程可以有多个线程，线程可以拥有自己的堆栈，自己的程序计数器和自己的局部变量，并且与父进程中的其他线程共享系统资源</p>
<h3 id="1-2-并行和并发"><a href="#1-2-并行和并发" class="headerlink" title="1.2 并行和并发"></a>1.2 并行和并发</h3><p>并行指在同一时刻，有多条指令在多个处理器上同时执行。例如打印机，多台打印机多人同时打印。</p>
<p>并发指在同一时刻只能由一条指令执行，但多个线程指令被快速轮换执行，时刻在宏观上具有多个进程同时执行的效果。例如打印机，一台打印机多人轮换打印。</p>
<p>注：单CPU时代多线程编程是没有太大意义的，并且线程间频繁的上下文切换还会带来额外开销</p>
<h3 id="1-3-线程的创建和启动"><a href="#1-3-线程的创建和启动" class="headerlink" title="1.3 线程的创建和启动"></a>1.3 线程的创建和启动</h3><p>java使用Thread类代表线程，所有的线程对象都必须是Thread类或其子类的实例</p>
<h5 id="1-3-1-继承Thread类"><a href="#1-3-1-继承Thread类" class="headerlink" title="1.3.1 继承Thread类"></a>1.3.1 继承Thread类</h5><p>通过继承Tread类来船舰并启动多线程的步骤如下：</p>
<ol>
<li>定义Thread类的子类，并重写该类的run（）方法，该run（）方法的方法题就代表线程需要完成的任务。即run（）方法称之为线程执行体。</li>
<li>创建Thread子类实例，即创建线程对象。</li>
<li>调用线程对象的start（）方法来启动该线程。</li>
</ol>
<p>演示实例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Iterator;</span><br><span class="line"></span><br><span class="line">public class MyThread1 extends Thread&#123;</span><br><span class="line">	//重写run方法，run方法体中的内容即线程所做的事情</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+&quot;==============&quot;+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Thread t = new MyThread1();</span><br><span class="line">		t.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>也可以使用lamda表达式进行创建并启动多线程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//也可用lamda表达式</span><br><span class="line">Thread thread = new Thread(()-&gt;&#123;</span><br><span class="line">public void run() &#123;</span><br><span class="line">	for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+&quot;==============&quot;+i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">	</span><br><span class="line">	thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-3-1-1-Thread底层实现"><a href="#1-3-1-1-Thread底层实现" class="headerlink" title="1.3.1.1 Thread底层实现"></a>1.3.1.1 Thread底层实现</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line">public class Thread implements Runnable &#123;</span><br><span class="line">   //线程最小的优先级</span><br><span class="line">   public static final int MIN_PRIORITY = 1;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">     * The default priority that is assigned to a thread.</span><br><span class="line">     */</span><br><span class="line">    public static final int NORM_PRIORITY = 5;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The maximum priority that a thread can have.</span><br><span class="line">     */</span><br><span class="line">    public static final int MAX_PRIORITY = 10;</span><br><span class="line">    //常用构造方法</span><br><span class="line">    public Thread() &#123;</span><br><span class="line">        this(null, null, &quot;Thread-&quot; + nextThreadNum(), 0);</span><br><span class="line">    &#125;</span><br><span class="line">    public Thread(Runnable target) &#123;</span><br><span class="line">        this(null, target, &quot;Thread-&quot; + nextThreadNum(), 0);</span><br><span class="line">    &#125;</span><br><span class="line">    public Thread(Runnable target, String name) &#123;</span><br><span class="line">        this(null, target, name, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    //常用API</span><br><span class="line">    /**</span><br><span class="line">     * 获取线程的状态，返回值是State枚举（见下文）</span><br><span class="line">     */</span><br><span class="line">    public State getState() &#123;</span><br><span class="line">        // get current thread state</span><br><span class="line">        return jdk.internal.misc.VM.toThreadState(threadStatus);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 判断线程是否处于存活状态，如果线程被启动，但是还没有终止(包括阻塞状态)，返回true</span><br><span class="line">     * 否则，返回false</span><br><span class="line">     */</span><br><span class="line">    public final native boolean isAlive();</span><br><span class="line">    </span><br><span class="line">    //如果在A线程内调用了B.join(),线程A会一直等待线程B执行结束后，再继续执行</span><br><span class="line">    public final void join() throws InterruptedException &#123;</span><br><span class="line">        join(0);</span><br><span class="line">    &#125;</span><br><span class="line">    //如果在线程A中调用线程B.join(loing millis)，则A线程最多等待线程B执行millis毫秒。其后交替执行</span><br><span class="line">    public final synchronized void join(long millis)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">        //获取当前时间的毫秒数</span><br><span class="line">        long base = System.currentTimeMillis();</span><br><span class="line">        long now = 0;</span><br><span class="line">		//如果传入参数小于0，则抛出异常</span><br><span class="line">        if (millis &lt; 0) &#123;</span><br><span class="line">            //非法参数异常</span><br><span class="line">            throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">		//如果传入参数等于0</span><br><span class="line">        if (millis == 0) &#123;</span><br><span class="line">            //判断插队的线程是否存活</span><br><span class="line">            while (isAlive()) &#123;</span><br><span class="line">                wait(0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //传入参数大于0</span><br><span class="line">            while (isAlive()) &#123;</span><br><span class="line">                long delay = millis - now;</span><br><span class="line">                if (delay &lt;= 0) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay);</span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public final synchronized void join(long millis, int nanos)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">		</span><br><span class="line">        if (millis &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (nanos &lt; 0 || nanos &gt; 999999) &#123;</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">                                &quot;nanosecond timeout value out of range&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (nanos &gt;= 500000 || (nanos != 0 &amp;&amp; millis == 0)) &#123;</span><br><span class="line">            millis++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        join(millis);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 设置线程为守护线程（on=true）</span><br><span class="line">     * 只能在线程启动前调用</span><br><span class="line">     */</span><br><span class="line">    public final void setDaemon(boolean on) &#123;</span><br><span class="line">        checkAccess();</span><br><span class="line">        //如果线程启动后是不能设置为守护线程的</span><br><span class="line">        if (isAlive()) &#123;</span><br><span class="line">            throw new IllegalThreadStateException();</span><br><span class="line">        &#125;</span><br><span class="line">        daemon = on;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * Causes the currently executing thread to sleep (temporarily cease</span><br><span class="line">     * execution) for the specified number of milliseconds, subject to</span><br><span class="line">     * the precision and accuracy of system timers and schedulers. The thread</span><br><span class="line">     * does not lose ownership of any monitors.</span><br><span class="line">     * 正在运行的线程睡眠指定的毫秒数，线程休眠时不会释放</span><br><span class="line">     * @param  millis</span><br><span class="line">     *         the length of time to sleep in milliseconds</span><br><span class="line">     *</span><br><span class="line">     * @throws  IllegalArgumentException</span><br><span class="line">     *          //如果毫秒数传入一个负值，则抛出该异常</span><br><span class="line">     *          if the value of &#123;@code millis&#125; is negative</span><br><span class="line">     *			//如果线程在休眠过程中被中断，则抛出此异常，抛出异常后清除中断状态</span><br><span class="line">     * @throws  InterruptedException</span><br><span class="line">     *          if any thread has interrupted the current thread. The</span><br><span class="line">     *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is</span><br><span class="line">     *          cleared when this exception is thrown.</span><br><span class="line">     */</span><br><span class="line">    public static native void sleep(long millis) throws InterruptedException;</span><br><span class="line">    </span><br><span class="line">    public static void sleep(long millis, int nanos)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">        if (millis &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (nanos &lt; 0 || nanos &gt; 999999) &#123;</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">                                &quot;nanosecond timeout value out of range&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        if (nanos &gt;= 500000 || (nanos != 0 &amp;&amp; millis == 0)) &#123;</span><br><span class="line">            millis++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sleep(millis);</span><br><span class="line">    &#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 设置线程的优先级</span><br><span class="line">     * Changes the priority of this thread.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * First the &#123;@code checkAccess&#125; method of this thread is called</span><br><span class="line">     * with no arguments. This may result in throwing a &#123;@code SecurityException&#125;.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * Otherwise, the priority of this thread is set to the smaller of</span><br><span class="line">     * the specified &#123;@code newPriority&#125; and the maximum permitted</span><br><span class="line">     * priority of the thread&#x27;s thread group.</span><br><span class="line">     *</span><br><span class="line">     * @param newPriority priority to set this thread to</span><br><span class="line">     * @throws     IllegalArgumentException  If the priority is not in the</span><br><span class="line">     *               range &#123;@code MIN_PRIORITY&#125; to</span><br><span class="line">     *               &#123;@code MAX_PRIORITY&#125;.</span><br><span class="line">     * @throws     SecurityException  if the current thread cannot modify</span><br><span class="line">     *               this thread.</span><br><span class="line">     * @see        #getPriority</span><br><span class="line">     * @see        #checkAccess()</span><br><span class="line">     * @see        #getThreadGroup()</span><br><span class="line">     * @see        #MAX_PRIORITY</span><br><span class="line">     * @see        #MIN_PRIORITY</span><br><span class="line">     * @see        ThreadGroup#getMaxPriority()</span><br><span class="line">     */</span><br><span class="line">    public final void setPriority(int newPriority) &#123;</span><br><span class="line">        ThreadGroup g;</span><br><span class="line">        checkAccess();</span><br><span class="line">        if (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        if((g = getThreadGroup()) != null) &#123;</span><br><span class="line">            if (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line">                newPriority = g.getMaxPriority();</span><br><span class="line">            &#125;</span><br><span class="line">            setPriority0(priority = newPriority);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //返回线程的优先级</span><br><span class="line">    public final int getPriority() &#123;</span><br><span class="line">        return priority;</span><br><span class="line">    &#125;</span><br><span class="line">    //获取线程的名字，如果没有为线程执行名称，则由JVM生成</span><br><span class="line">    public final String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    //为线程设置名称</span><br><span class="line">    public final synchronized void setName(String name) &#123;</span><br><span class="line">        checkAccess();</span><br><span class="line">        if (name == null) &#123;</span><br><span class="line">            throw new NullPointerException(&quot;name cannot be null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.name = name;</span><br><span class="line">        if (threadStatus != 0) &#123;</span><br><span class="line">            setNativeName(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static native void yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><table>
<thead>
<tr>
<th>构造器</th>
<th>方法描述</th>
</tr>
</thead>
<tbody><tr>
<td>public Thread()</td>
<td>无参构造器，用于创建一个线程</td>
</tr>
<tr>
<td>public Thread(Runnable target)</td>
<td>传入一个Runnable接口的子类对象，创建线程</td>
</tr>
<tr>
<td>public Thread(Runnable target,String name)</td>
<td>传入Runnable接口的子类对象，创建线程，并指定线程的名称</td>
</tr>
</tbody></table>
<h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>方法描述</th>
</tr>
</thead>
<tbody><tr>
<td>public State getState()</td>
<td>获取线程的状态</td>
</tr>
<tr>
<td>public final native boolean isAlive();</td>
<td>获取线程存活状态，线程在start()之后，终止之前，该方法会返回true，否则返回false</td>
</tr>
<tr>
<td>public final void setDaemon(boolean on)</td>
<td>设置一个线程为守护线程，该方法在调用start()之前调用，否则会抛出异常</td>
</tr>
<tr>
<td>public final void setPriority(int newPriority)</td>
<td>设置线程的优先级，总共有10个优先级1-10</td>
</tr>
<tr>
<td>public final int getPriority()</td>
<td>获取线程的优先级</td>
</tr>
<tr>
<td>public final String getName()</td>
<td>获取线程的名字，如果没有为线程执行名称，则由JVM生成</td>
</tr>
<tr>
<td>public final synchronized void setName(String name)</td>
<td>为线程设置名称，不能为null</td>
</tr>
<tr>
<td>public final void join() throws InterruptedException</td>
<td>———-合并线程，如果在A线程中调用B线程join()方法，则A线程进入WAITING状态，知道B线程执行结束，A线程进入RUNNABLE状态</td>
</tr>
<tr>
<td>public final synchronized void join(long millis)</td>
<td>如果在线程A中调用线程B.join(loing millis)，则A线程最多等待线程B执行millis毫秒。其后交替执行</td>
</tr>
<tr>
<td>public final synchronized void join(long millis,long nanos)</td>
<td>如果在线程A中调用线程B.join，则A线程最多等待线程B执行millis++毫秒。其后交替执行</td>
</tr>
</tbody></table>
<h4 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>方法描述</th>
</tr>
</thead>
<tbody><tr>
<td>public static native void sleep(long millis) throws InterruptedException</td>
<td>线程休眠millis毫秒，休眠过后转入到Runnable状态，当线程进入休眠后，线程处于TIMED_WAITING状态</td>
</tr>
<tr>
<td>public static void sleep(long millis, int nanos)</td>
<td>同上</td>
</tr>
<tr>
<td>public static native void yield();</td>
<td>暂停正在执行的线程，线程调度器重新调度在就绪队列中的线程，优先级高的线程获得执行的概率较大，也有可能刚才正在执行的线程被重新执行。</td>
</tr>
</tbody></table>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p>因为java中类是单继承的，继承了Thread类，就无法继承其他父类，不利于代码扩展。</p>
<h4 id="1-3-2-实现Runnable接口"><a href="#1-3-2-实现Runnable接口" class="headerlink" title="1.3.2 实现Runnable接口"></a>1.3.2 实现Runnable接口</h4><p>实现Runnable接口来创建并启动多线程的步骤如下：</p>
<ol>
<li>定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</li>
<li>创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。</li>
<li>调用线程对象的start()方法来启动该线程。</li>
</ol>
<p>  示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread2 implements Runnable&#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+&quot;==============&quot;+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		MyThread2 t = new MyThread2();</span><br><span class="line">		Thread thread = new Thread(t);</span><br><span class="line">		thread.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：在启动线程时，MyThread并没有start（）方法，所以使用了Thread的构造方法，将线程t传入并启动了线程，此处启动的并不是线程thread，而是线程t。</p>
<h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><ol>
<li>因为Runnable接口中没有start()方法，因此启动线程时，必须将继承了Runnable接口的类的对象通过Thread类的构造进行包装，然后调用Thread的start()方法启动线程。</li>
<li>run()方法不能抛出异常，如果run（）方法中代码抛出异常，程序只能中断，不能通过try..catch进行异常。</li>
<li>run()方法没有返回值。</li>
</ol>
<h3 id="1-3-3-使用Callable和Future创建线程"><a href="#1-3-3-使用Callable和Future创建线程" class="headerlink" title="1.3.3 使用Callable和Future创建线程"></a>1.3.3 使用Callable和Future创建线程</h3><p>Callable接口提供了一个call方法可以作为线程执行体，但call()方法比run()方法功能强大。其call()方法可以有返回值和声明抛出异常。call()方法并不是直接调用，它是作为线程执行体被调用的。</p>
<blockquote>
<p>Callable接口是Java 5新增的接口，而且它不是Runnable接口的子接口，所以Callable对象不能直接作为Thread的target。</p>
</blockquote>
<blockquote>
<p>java 5提供了Future接口来代表Callable接口里call()方法的返回值，并为Future接口提供了一个FutureTask实现类，该实现类实现了Future接口，并实现了Runnable接口——可以作为Thread类的target。</p>
</blockquote>
<p>创建并启动有返回值的线程的步骤如下：</p>
<ol>
<li>创建Callable接口的实现类，并实现call方法，该call方法将作为线程执行体，且该call方法有返回值</li>
<li>创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象分装了该Callable对象的call（）方法的返回值</li>
<li>使用FutureTask对象作为Thread对象的target创建并启动新线程。</li>
<li>调用FutureTask对象的get（）方法来获得子线程执行结束的放回值。</li>
</ol>
<blockquote>
<ol>
<li><p>继承Callable接口，并实现call()方法</p>
</li>
<li><p>创建FutureTask对象，包装Callable的子类对象</p>
</li>
<li><p>创建Thread类的对象，包装FutureTask对象</p>
</li>
<li><p>调用Thread#start()方法启动线程</p>
</li>
<li><p>调用FutureTask#get()方法获取call()方法的返回值</p>
</li>
</ol>
</blockquote>
<p>演示实例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread3 implements Callable&lt;Integer&gt;&#123;</span><br><span class="line">	@Override</span><br><span class="line">	public Integer call() throws Exception &#123;</span><br><span class="line">		int i = 0;</span><br><span class="line">		for (;i&lt;100;i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+&quot;=========&quot;+i);</span><br><span class="line">		&#125;</span><br><span class="line">		return i;</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		MyThread3 t = new MyThread3();</span><br><span class="line">		FutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;(t);</span><br><span class="line">		</span><br><span class="line">		Thread thread = new Thread(task);</span><br><span class="line">		</span><br><span class="line">		thread.start();</span><br><span class="line">		//获取返回值</span><br><span class="line">		try &#123;</span><br><span class="line">			System.out.println(&quot;线程的返回值是：&quot;+task.get());</span><br><span class="line">		&#125; catch (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h5 id="底层实现如下所示："><a href="#底层实现如下所示：" class="headerlink" title="底层实现如下所示："></a>底层实现如下所示：</h5><h6 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 等价于run()方法，但是该方法有返回值，并且可以抛出异常</span><br><span class="line">     *</span><br><span class="line">     * @return computed result</span><br><span class="line">     * @throws Exception if unable to compute a result</span><br><span class="line">     */</span><br><span class="line">    V call() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public interface Future&lt;V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 尝试取消一个任务.如果任务已经执行完成，则取消失败 . 当任务没有开始时，可以取消</span><br><span class="line">     * 如果任务已经开始，线程能不能被取消取决于mayInterruptIfRunning参数</span><br><span class="line">     * </span><br><span class="line">     * 当调用完此方法后调用isCancelled(),isDone()方法都会返回true</span><br><span class="line">     * @param mayInterruptIfRunning 如果是true，则正则执行的线程可以被取消，否则</span><br><span class="line">     * 线程被允许执行完成。</span><br><span class="line">     * @return &#123;@code false&#125; 如果返回false则线程没有取消</span><br><span class="line">     * 典型的例如，这个线程已经执行完成。</span><br><span class="line">     * &#123;@code true&#125; otherwise</span><br><span class="line">     */</span><br><span class="line">    boolean cancel(boolean mayInterruptIfRunning);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns &#123;@code true&#125; 如果任务在任务启动前或者完成过程被取消，则返回true</span><br><span class="line">     * 在完成后取消，并调用该方法时返回false。</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    boolean isCancelled();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns &#123;@code true&#125; 如果任务完成则返回true.</span><br><span class="line">     * 任务被中断，被取消，或者发生异常，都会返回true</span><br><span class="line">     *</span><br><span class="line">     * @return &#123;@code true&#125; if this task completed</span><br><span class="line">     */</span><br><span class="line">    boolean isDone();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 如果需要，等待call()方法执行结束后，获取结果</span><br><span class="line">     *</span><br><span class="line">     * @return the computed result</span><br><span class="line">     * @throws CancellationException if the computation was cancelled</span><br><span class="line">     * @throws ExecutionException if the computation threw an</span><br><span class="line">     * exception</span><br><span class="line">     * @throws InterruptedException if the current thread was interrupted</span><br><span class="line">     * while waiting</span><br><span class="line">     */</span><br><span class="line">    V get() throws InterruptedException, ExecutionException;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 等待给定时间内获取结果，如果在等待时间内没有获取到结果，则抛出异常</span><br><span class="line">     *</span><br><span class="line">     * @param timeout the maximum time to wait</span><br><span class="line">     * @param unit the time unit of the timeout argument</span><br><span class="line">     * @return the computed result</span><br><span class="line">     * @throws CancellationException if the computation was cancelled</span><br><span class="line">     * @throws ExecutionException if the computation threw an</span><br><span class="line">     * exception</span><br><span class="line">     * @throws InterruptedException if the current thread was interrupted</span><br><span class="line">     * while waiting</span><br><span class="line">     * @throws TimeoutException if the wait timed out</span><br><span class="line">     */</span><br><span class="line">    V get(long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-线程的生命周期"><a href="#1-4-线程的生命周期" class="headerlink" title="1.4 线程的生命周期"></a>1.4 线程的生命周期</h3><p>线程的生命周期就是线程从创建到运行结束的整个过程状态。</p>
<p>在线程的生命周期中，它要经过新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）和死亡（Dead）五种状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public enum State &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 线程创建但未启动</span><br><span class="line">         */</span><br><span class="line">        NEW,</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 线程处于该状态，可能是正在运行，</span><br><span class="line">         * 也可能是处于等待状态，在等待处理器分配资源</span><br><span class="line">         */</span><br><span class="line">        RUNNABLE,</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 线程在等待其他线程释放锁时，会处于该状态</span><br><span class="line">         */</span><br><span class="line">        BLOCKED,</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Thread state for a waiting thread.</span><br><span class="line">         * A thread is in the waiting state due to calling one of the</span><br><span class="line">         * following methods:</span><br><span class="line">         * &lt;ul&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link #join() Thread.join&#125; with no timeout&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span><br><span class="line">         * &lt;/ul&gt;</span><br><span class="line">         *</span><br><span class="line">         * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span><br><span class="line">         * perform a particular action.</span><br><span class="line">         *</span><br><span class="line">         * For example, a thread that has called &#123;@code Object.wait()&#125;</span><br><span class="line">         * on an object is waiting for another thread to call</span><br><span class="line">         * &#123;@code Object.notify()&#125; or &#123;@code Object.notifyAll()&#125; on</span><br><span class="line">         * that object. A thread that has called &#123;@code Thread.join()&#125;</span><br><span class="line">         * is waiting for a specified thread to terminate.</span><br><span class="line">         */</span><br><span class="line">        WAITING,</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Thread state for a waiting thread with a specified waiting time.</span><br><span class="line">         * A thread is in the timed waiting state due to calling one of</span><br><span class="line">         * the following methods with a specified positive waiting time:</span><br><span class="line">         * &lt;ul&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link #sleep Thread.sleep&#125;&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span><br><span class="line">         * &lt;/ul&gt;</span><br><span class="line">         */</span><br><span class="line">        TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 线程执行完毕后处于该状态</span><br><span class="line">         */</span><br><span class="line">        TERMINATED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="15-2-1-新建和就绪状态"><a href="#15-2-1-新建和就绪状态" class="headerlink" title="15.2.1 新建和就绪状态"></a>15.2.1 新建和就绪状态</h3><p>当程序使用 new 关键字创建了一个线程之后，该线程就处于新建状态，此时它和其他的Java对象一样，仅仅由Java虚拟机为其分配内存，并初始化其成员变量的值。此时的线程对象没有表现出任何线程的动态特征，程序也不会执行线程的线程执行体。当线程对象调用了start()方法之后，该线程处于就绪状态，Java虚拟机会为其创建方法调用栈和程序计数器，处于这个状态中的线程并没有开始运行，只是表示该线程可以运行了。至于该线程何时开始运行，取决于JVM里线程调度器的调度。<br>线程的调度目前主要分为两种：分时调度和抢占式调度。</p>
<ol>
<li>分时调度：系统平均分配CPU时间片，所有线程轮流占用CPU，也就是说在时间片调度的分配上所有线程“人人平等”。</li>
<li>抢占式调度：系统按照线程优先级分配CPU时间片。优先级高的线程优先分配CPU时间片，如果所有就绪线程的优先级相同，那么会随机选择一个，优先级高的线程获取的CPU时间片相对多一些。</li>
</ol>
<p>由于目前大部分操作系统都是使用抢占式调度模型进行线程调度，Java的线程管理和调度是委托给操作系统完成的，与之相对应，Java的线程调度也是使用抢占式调度模型。</p>
<blockquote>
<p>启动线程使用 start()方法，而不是 run()方法！永远不要调用线程对象的run()方法！调用start()方法来启动线程，系统会把该run()方法当成线程执行体来处理；但如果直接调用线程对象的run()方法，则run()方法立即就会被执行，而且在 run()方法返回之前其他线程无法并发执行——也就是说，系统把线程对象当成一个普通对象，而run()方法也是一个普通方法，而不是线程执行体。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.cycle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Thread state====&quot;</span>+getState());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//此时线程处于新建状态</span></span><br><span class="line">		MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">		System.out.println(<span class="string">&quot;Thread state====&quot;</span>+thread.getState());</span><br><span class="line">		thread.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面的程序可以看出当thread线程创建对象后，此时打印线程为新建状态（NEW）,当启动线程，线程已经程开始运行时在代码第6行打印了运行状态（RUNNABLE）</p>
<blockquote>
<p>只能对处于新建状态的线程调用 start()方法，否则将引发IllegalThreadStateException异常。也就是说当线程调用过start()方法后再不能重复调用，否则将引发异常。</p>
</blockquote>
<h3 id="15-2-2-运行和阻塞状态"><a href="#15-2-2-运行和阻塞状态" class="headerlink" title="15.2.2 运行和阻塞状态"></a>15.2.2 运行和阻塞状态</h3><p>如果处于就绪状态的线程获得了CPU，开始执行run()方法的线程执行体，则该线程处于运行状态，如果计算机只有一个 CPU，那么在任何时刻只有一个线程处于运行状态。当然，在一个多处理器的机器上，将会有多个线程并行（注意是并行：parallel）执行；当线程数大于处理器数时，依然会存在多个线程在同一个CPU上轮换的现象。<br>当一个线程开始运行后，它不可能一直处于运行状态（除非它的线程执行体足够短，瞬间就执行结束了），线程在运行过程中需要被中断，目的是使其他线程获得执行的机会，线程调度的细节取决于底层平台所采用的策略。对于采用抢占式策略的系统而言，系统会给每个可执行的线程一个小时间段来处理任务；当该时间段用完后，系统就会剥夺该线程所占用的资源，让其他线程获得执行的机会。在选择下一个线程时，系统会考虑线程的优先级。<br>当发生如下情况时，线程将会进入阻塞状态。</p>
<ul>
<li>线程调用sleep()方法主动放弃所占用的处理器资源。</li>
<li>线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞。</li>
<li>线程试图获得一个同步监视器，但该同步监视器正被其他线程所持有。关于同步监视器的知识、后面将有更深入的介绍。</li>
<li>线程在等待某个通知（notify）。</li>
</ul>
<p>当前正在执行的线程被阻塞之后，其他线程就可以获得执行的机会。被阻塞的线程会在合适的时候重新进入就绪状态，注意是就绪状态而不是运行状态。也就是说，被阻塞线程的阻塞解除后，必须重新等待线程调度器再次调度它。<br>针对上面几种情况，当发生如下特定的情况时可以解除上面的阻塞，让该线程重新进入就绪状态。</p>
<ul>
<li>调用sleep()方法的线程经过了指定时间。</li>
<li>线程调用的阻塞式IO方法已经返回。</li>
<li>线程成功地获得了试图取得的同步监视器。</li>
<li>线程正在等待某个通知时，其他线程发出了一个通知。</li>
</ul>
<p>下图显示了线程状态转换图。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/22117562/1626920386127-c24a68e4-6ca2-4ce2-b62c-a15261388ab9.png#align=left&display=inline&height=2084&id=kAo87&margin=[object%20Object]&originHeight=2084&originWidth=3252&size=0&status=done&style=none&width=3252" alt="img"><br>下面通过示例来演示程序进入阻塞状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.cycle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> k = sc.nextInt();</span><br><span class="line">		System.out.println(<span class="string">&quot;Thread state====&quot;</span>+getState());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">		thread.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面的程序发现启动线程后，线程一直处于阻塞状态，这是因为在代码第9行程序一直在等待着用户的输入。</p>
<h3 id="http-192-168-31-254-java-advance-第15章-多线程基础-html-15-2-3-线程死亡-15-2-3-线程死亡"><a href="#http-192-168-31-254-java-advance-第15章-多线程基础-html-15-2-3-线程死亡-15-2-3-线程死亡" class="headerlink" title="[#](http://192.168.31.254/java-advance/第15章 多线程基础.html#_15-2-3-线程死亡)15.2.3 线程死亡"></a>[#](<a target="_blank" rel="noopener" href="http://192.168.31.254/java-advance/%E7%AC%AC15%E7%AB%A0">http://192.168.31.254/java-advance/第15章</a> 多线程基础.html#_15-2-3-线程死亡)15.2.3 线程死亡</h3><p>线程会以如下3种方式结束，结束后就处于死亡状态。</p>
<ul>
<li>run()或call()方法执行完成，线程正常结束。</li>
<li>线程抛出一个未捕获的 Exception或Error。</li>
<li>直接调用该线程的stop()方法来结束该线程——该方法容易导致死锁，通常不推荐使用。</li>
</ul>
<p><strong>当主线程结束时，其他线程不受任何影响，并不会随之结束。一旦子线程启动起来后，它就拥有和主线程相同的地位，它不会受主线程的影响。</strong><br>为了测试某个线程是否已经死亡，可以调用线程对象的isAlive()方法，当线程处于就绪、运行、阻塞3种状态时，该方法将返回true；当线程处于新建、死亡2种状态时，该方法将返回false。<br>下面通过程序来演示该状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.cycle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;state====&quot;</span>+getState());</span><br><span class="line">		System.out.println(<span class="string">&quot;isAlive====&quot;</span>+isAlive());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">		thread.start();</span><br><span class="line">		<span class="comment">//主线程休眠3秒，等待thread线程执行完毕</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//再次获取thread的状态</span></span><br><span class="line">		System.out.println(<span class="string">&quot;thread state====&quot;</span>+thread.getState());</span><br><span class="line">		System.out.println(<span class="string">&quot;thread isAlive====&quot;</span>+thread.isAlive());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中代码第12行启动了thread线程，启动该线程后让主线程休眠3s，给予thread线程充分的执行时间，当主线程休眠结束后，再次获取thread线程的状态，发现发现打印了TERMINATED。运行结果如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/2745416/1629187967272-6014308d-e5d4-49c6-9f84-74969efffa9a.png#align=left&display=inline&height=163&id=Y2EJf&margin=[object%20Object]&name=image.png&originHeight=190&originWidth=450&size=17728&status=done&style=none&width=387" alt="image.png"><br><strong>不要对处于死亡状态的线程调用start()方法，程序只能对新建状态的线程调用start()方法，对新建状态的线程两次调用start()方法也是错误的。这都会引发IllegalThreadState Exception异常</strong></p>
<h2 id="1-3-控制线程"><a href="#1-3-控制线程" class="headerlink" title="1.3 控制线程"></a>1.3 控制线程</h2><h4 id="1-3-1-Join"><a href="#1-3-1-Join" class="headerlink" title="1.3.1 Join"></a>1.3.1 Join</h4><p>当某个程序在执行流中调用其他线程的join()方法时，调用线程将被阻塞，直到被join()方法加入的线程执行结束。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread t1 = new Thread(()-&gt;&#123;</span><br><span class="line">            for (int i = 0; i &lt; 30; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;===&quot;+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;t1&quot;);</span><br><span class="line">        Thread t2 = new Thread(()-&gt;&#123;</span><br><span class="line">            for (int i = 0; i &lt; 30; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;+++&quot;+i);</span><br><span class="line">                if(i==10)&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        t1.join();</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        throw new RuntimeException(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;t2&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        for (int i = 0; i &lt; 60; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;&gt;&gt;&gt;&quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>注意：当T2线程执行过程中被T1线程Join，线程T1执行时，T2处于WAITING</strong></p>
<h3 id="1-3-2-Join-long-millis"><a href="#1-3-2-Join-long-millis" class="headerlink" title="1.3.2 Join(long millis)"></a>1.3.2 Join(long millis)</h3><p>当某个程序在执行流中调用其他线程的join(long millis)方法时，调用线程将被限时阻塞，直到等待millis毫秒之后此线程和其他线程交替执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread3 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread t1 = new Thread(()-&gt;&#123;</span><br><span class="line">            for (int i = 0; i &lt; 50; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;==============&quot;+i);</span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(1);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    throw new RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;t1&quot;);</span><br><span class="line">        Thread t2 = new Thread(()-&gt;&#123;</span><br><span class="line">            for (int i = 0;i&lt;200;i++)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;==============&quot;+i);</span><br><span class="line">                if(i==20)&#123;</span><br><span class="line">                    t1.start();</span><br><span class="line">                    try &#123;</span><br><span class="line">                        t1.join(3000);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        throw new RuntimeException(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;t2&quot;);</span><br><span class="line">        t2.start();</span><br><span class="line">        //让主线程休眠，保存t2被t1#join</span><br><span class="line">        TimeUnit.SECONDS.sleep(2);</span><br><span class="line">        System.out.println(t2.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意：当T2线程执行过程中被T1线程Join，线程T1执行时，T2处于TIME_WAITING</strong></p>
<h4 id="1-3-3-守护线程"><a href="#1-3-3-守护线程" class="headerlink" title="1.3.3 守护线程"></a>1.3.3 守护线程</h4><p>有一种线程，他是在后台运行的，它的任务是为其他的线程提供服务，这种线程被称为“后台线程（Daemon Thread）”，又称为守护线程。</p>
<p>调用Thread对象的setDaemon(true)方法可将指定线程设置为后台线程。</p>
<p><strong>注意：如果所有的前台线程都死亡，后台线程会自动死亡。当父线程为后台线程则子线程也为后台线程</strong></p>
<p>可以通过isDaemon()方法判断线程是否是守护线程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 演示守护线程</span><br><span class="line"> * 前台线程结束后，守护线程会自动结束</span><br><span class="line"> */</span><br><span class="line">public class MyThread &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread t1 = new Thread(()-&gt;&#123;</span><br><span class="line">            for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;====&quot;+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;t1&quot;);</span><br><span class="line">        //设置线程为守护线程</span><br><span class="line">        t1.start();</span><br><span class="line">        t1.setDaemon(true);</span><br><span class="line">        for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;&gt;&gt;&gt;&gt;&quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>守护线程必须在启动前将其守护状态设置为true，启动之后崩再将用户线程设置为守护线程，否则JVM会抛出一个InterruptedException异常。</li>
<li>守护线程存在被JVM强行终止的风险，所以i在守护线程中尽量不去访问系统资源，如数据库连接。</li>
<li>守护线程创建的线程也是守护线程，在创建之后，如果通过调用setDaemon(false)将新的线程显示的设置为用户线程，新的线程可以调整为用户线程。</li>
</ol>
<h4 id="1-3-4-线程休眠"><a href="#1-3-4-线程休眠" class="headerlink" title="1.3.4  线程休眠"></a>1.3.4  线程休眠</h4><h5 id="1-3-4-1-sleep"><a href="#1-3-4-1-sleep" class="headerlink" title="1.3.4.1 sleep()"></a>1.3.4.1 sleep()</h5><p>sleep()方法是一个类方法，不需要使用对象调用（通过对象调用该方法，是无法达到让线程休眠的效果）。</p>
<p><strong>注意：让哪个线程休眠，就在哪个线程中调用sleep()方法。</strong></p>
<ul>
<li>static void sleep(long millis)：让当前正在执行的线程暂停millis毫秒，并进入阻塞状态，该方法受到系统计时器和线程调度器的精度与准确度的影响。</li>
<li>static void sleep(long millis,int nanos)：让当前正在执行的线程暂停millis毫秒加nanos毫微秒，并进入阻塞状态，该方法受到系统计时器和线程调度器的精度与准确度的影响。</li>
</ul>
<h6 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread t1 = new Thread(()-&gt;&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;开始休眠&quot;);</span><br><span class="line">                Thread.sleep(5000);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;休眠结束&quot;);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                throw new RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>反面示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.sleep;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i&lt;<span class="number">100</span>)&#123;</span><br><span class="line">                System.out.println(i++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">//让主线程休眠1S，确保T1线程运行</span></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;t1.sleep()开始&quot;</span>);</span><br><span class="line">        t1.sleep(<span class="number">5000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;t1.sleep()结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：代码第18行，并不会让t1线程休眠，而是让主线程休眠了5秒钟。</p>
<p>线程在休眠的过程中调用interrupt()方法，会抛出异常</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package cn.bytecollege.sleep;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class MyThread3 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread t1 = new Thread(()-&gt;&#123;</span><br><span class="line">//            try &#123;</span><br><span class="line">//                Thread.sleep(100000);</span><br><span class="line">//            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">//                e.printStackTrace();</span><br><span class="line">//            &#125;</span><br><span class="line">            while (true)&#123;</span><br><span class="line">                System.out.println(true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        //让主线程休眠1S，确保T1线程进入到休眠状态</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(3);</span><br><span class="line">        //获取t1的状态</span><br><span class="line">        System.out.println(t1.getState());</span><br><span class="line">        //在线程休眠过程中中断</span><br><span class="line">        t1.interrupt();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-3-4-2-LockSupport类"><a href="#1-3-4-2-LockSupport类" class="headerlink" title="1.3.4.2 LockSupport类"></a>1.3.4.2 LockSupport类</h5><p>LockSupport是JUC提供的一个线程阻塞与唤醒的工具类，该工具类可以让线程在任意位置橘色和唤醒，其所有的方法都是静态方法。</p>
<h6 id="底层实现方法："><a href="#底层实现方法：" class="headerlink" title="底层实现方法："></a>底层实现方法：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class LockSupport &#123;</span><br><span class="line">   /**</span><br><span class="line">     * 该方法会使线程进入休眠状态，知道被其他线程unpark()</span><br><span class="line">     * Disables the current thread for thread scheduling purposes unless the</span><br><span class="line">     * permit is available.</span><br><span class="line">     * </span><br><span class="line">     * &lt;p&gt;If the permit is available then it is consumed and the call</span><br><span class="line">     * returns immediately; otherwise the current thread becomes disabled</span><br><span class="line">     * for thread scheduling purposes and lies dormant until one of three</span><br><span class="line">     * things happens:</span><br><span class="line">     *</span><br><span class="line">     * &lt;ul&gt;</span><br><span class="line">     *</span><br><span class="line">     * &lt;li&gt;Some other thread invokes &#123;@link #unpark unpark&#125; with the</span><br><span class="line">     * current thread as the target; or</span><br><span class="line">     *</span><br><span class="line">     * &lt;li&gt;Some other thread &#123;@linkplain Thread#interrupt interrupts&#125;</span><br><span class="line">     * the current thread; or</span><br><span class="line">     *</span><br><span class="line">     * &lt;li&gt;The call spuriously (that is, for no reason) returns.</span><br><span class="line">     * &lt;/ul&gt;</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;This method does &lt;em&gt;not&lt;/em&gt; report which of these caused the</span><br><span class="line">     * method to return. Callers should re-check the conditions which caused</span><br><span class="line">     * the thread to park in the first place. Callers may also determine,</span><br><span class="line">     * for example, the interrupt status of the thread upon return.</span><br><span class="line">     * </span><br><span class="line">     */</span><br><span class="line">    public static void park() &#123;</span><br><span class="line">            U.park(false, 0L);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 休眠nanos毫秒，时间到达后，自动转入的Runnable状态</span><br><span class="line">     */</span><br><span class="line">    public static void parkNanos(long nanos) &#123;</span><br><span class="line">        if (nanos &gt; 0)</span><br><span class="line">            U.park(false, nanos);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 休眠到未来的某个时间点</span><br><span class="line">     */</span><br><span class="line">    public static void parkUntil(long deadline) &#123;</span><br><span class="line">        U.park(true, deadline);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            String name = Thread.currentThread().getName();</span><br><span class="line">            System.out.println(name+<span class="string">&quot;调用park()&quot;</span>);</span><br><span class="line">            <span class="keyword">long</span> time = System.currentTimeMillis()+<span class="number">5000</span>;</span><br><span class="line">            LockSupport.parkNanos(<span class="number">10000000000L</span>);</span><br><span class="line"><span class="comment">//            LockSupport.parkUntil(time);</span></span><br><span class="line"><span class="comment">//            LockSupport.park();</span></span><br><span class="line">            System.out.println(name+<span class="string">&quot;结束park()&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">//主线程在休眠5秒后，唤醒休眠线程</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;开始唤醒&quot;</span>);</span><br><span class="line">        LockSupport.unpark(thread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用park()方法时，会让线程进入WAITING状态，调用parkNanos(long nanos)方法时，线程会进入TIMED_WAITING状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.locksupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.bytecollege.thread.MyThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">40</span>)&#123;</span><br><span class="line">                    LockSupport.parkNanos(<span class="number">6000000000L</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">//主线程休眠1秒钟，包装thread线程进入到休眠状态</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(thread.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>【重要】LockSort.park和Thread.sleep()的区别：</p>
<ol>
<li>Thread.sleep()无法从外部唤醒，只能自己醒过来；而被LockSupport.park()方法阻塞的线程可以通过调用LockSupport.unpark()方法去唤醒；</li>
<li>Thread.sleep()方法声明了InterruptedException中断异常，这是一个受检异常，调用者需要捕获这个异常或者再抛出；而调用LockSupport.park()方法时不需要捕获中断异常。</li>
<li>被LockSupport.park()方法、Thread.sleep()方法所阻塞的线程有一个特点，当被阻塞时，线程的Thread.interrupt()方法被调用，被阻塞线程的中断标志将被设置，该线程将被唤醒。不同的是，二者对中断信号的响应方式不同：LockSupport.park()方法不会抛出InterruptedException异常，仅仅设置了线程的终端标志；而Thread.sleep()方法会抛出InterruptedException异常。</li>
<li>与Thread.sleep()相比，调用LockSupport.park（）能更精准，更加灵活的阻塞、唤醒指定线程。 醒示例如下：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class InterruptDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread thread = new Thread(() -&gt;&#123;</span><br><span class="line">            Thread t = Thread.currentThread();</span><br><span class="line">            System.out.println(t.getName() +&quot;状态 ： &quot;+t.getState());</span><br><span class="line">//            LockSupport.park();</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(10000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">//                throw new RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(t.getName() +&quot;状态 ： &quot;+t.getState() + &quot;执行结束&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(2);</span><br><span class="line">        System.out.println(thread.getName() +&quot;状态 ： &quot;+thread.getState());</span><br><span class="line">        thread.interrupt();</span><br><span class="line">        TimeUnit.SECONDS.sleep(2);</span><br><span class="line">        System.out.println(thread.getName() +&quot;状态 ： &quot;+thread.getState() + &quot;继续执行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意：通过LockSupport.park（）方法进入阻塞的线程和通过Thread.sleep()进入阻塞的线程一样，都不会释放锁。</strong></p>
<h5 id="1-3-4-3-yield-线程让步"><a href="#1-3-4-3-yield-线程让步" class="headerlink" title="1.3.4.3 yield() 线程让步"></a>1.3.4.3 yield() 线程让步</h5><p>暂停正在执行的线程，线程调度器重新调度在就绪队列中的线程，优先级高的线程获得执行的概率较大，也有可能刚才正在执行的线程被重新执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.yield;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;==============&quot;</span>+i);</span><br><span class="line">                <span class="keyword">if</span>(i%<span class="number">10</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    Thread.yield();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;&gt;&gt;&gt;&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        <span class="comment">//yield之后，有可能原来执行的线程继续获得执行的机会</span></span><br><span class="line">        t1.setPriority(<span class="number">10</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;&gt;&gt;&gt;&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>sleep()方法和yield()方法的区别：</strong></p>
<ol>
<li>sleep()方法暂停当前线程后，会给其他线程执行机会，不会理会其他线程的优先级；但yield()方法会给优先级相同，或优先级更高的线程执行机会。</li>
<li>sleep()方法会将线程转入阻塞状态，直到经过阻塞时间才会转入就绪状态；而yield()不会将线程转入阻塞状态，它只是强制当前线程进入就绪状态。因此完全有可能某个线程调用yield()方法暂停之后，立即再次获得处理器资源被执行。</li>
<li>sleep()方法声明抛出了 InterruptedException 异常，所以调用 sleep()方法时要么捕捉该异常，要么显式声明抛出该异常；而yield()方法则没有声明抛出任何异常。</li>
</ol>
<h3 id="1-3-5-线程优先级"><a href="#1-3-5-线程优先级" class="headerlink" title="1.3.5 线程优先级"></a>1.3.5 线程优先级</h3><p>线程的优先级并不能绝对线程的执行顺序，也就是说优先级高的线程并不一定优先执行，只是线程优先级高的线程获得CPU时间片的概率更大一些。</p>
<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.priority;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(getName()+<span class="string">&quot;，优先级=====&quot;</span>+getPriority());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> cn.bytecollege.priority;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            threads[i-<span class="number">1</span>] = <span class="keyword">new</span> MyThread();</span><br><span class="line">            threads[i-<span class="number">1</span>].setPriority(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//主线程休眠3秒</span></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">400</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i].stop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程优先级具有继承性，也就是说在某个线程中创建的线程，其优先级和父线程相同。</p>
<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.priority;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPriorityTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread main = Thread.currentThread();</span><br><span class="line">        System.out.println(main.getName()+<span class="string">&quot;================&quot;</span>+main.getPriority());</span><br><span class="line">        System.out.println(t.getPriority());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-3-6-线程的停止"><a href="#1-3-6-线程的停止" class="headerlink" title="1.3.6 线程的停止"></a>1.3.6 线程的停止</h3><p>线程停止有2种办法</p>
<ol>
<li>stop()：该方法已被废弃，我们是不能随便中断一个线程的，我们无法知道这个线程正运行在什么状态，它可能持有某把锁，强行中断线程可能导致锁不能释放的问题；或者线程可能在操作数据库，强行中断线程可能导致数据不一致的问题。正是由于调用stop()方法来终止线程可能会产生不可预料的结果，因此不推荐调用stop()方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.stop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.bytecollege.priority.MyThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                System.out.println(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="comment">//主线程休眠1ms，保证t线程运行</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        t.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>异常中断法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.stop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程休眠后终止</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThreadDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="comment">//线程休眠10秒</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t线程进入休眠状态&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t线程中断&quot;</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="comment">//主线程休眠1ms，保证t线程运行</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//添加中断标记</span></span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.stop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程wait后终止</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThreadDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="comment">//线程wait()</span></span><br><span class="line">            System.out.println(<span class="string">&quot;线程t进入等待状态&quot;</span>);</span><br><span class="line">            Object o = <span class="keyword">new</span> Object();</span><br><span class="line">            <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    o.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程终止&quot;</span>);</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="comment">//主线程休眠1ms，保证t线程运行</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//添加中断标记</span></span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.stop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中断标记终止</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThreadDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            Thread thread = Thread.currentThread();</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">&quot;运行状态&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(thread.isInterrupted())&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程即将中断&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="comment">//主线程休眠1ms，保证t线程运行</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//添加中断标记</span></span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【次重要】interrupt()和interrupted()的区别</strong></p>
<ol>
<li>interrupt()是实例方法，用于为正在运行的线程添加中断标记，当线程正在运行时，该方法并不会影响线程的运行。如果线程被Object.wait()、Thread.join()和Thread.sleep()三种方法之一阻塞，此时线程处于WAITING或者TIMED_WAITING状态时，调用该方法时，线程会抛出中断异常。</li>
<li>interrupted()是类方法，用于检测线程是否有中断标记，如果线程有中断标记，调用该方法时会清除标记，清除标记后再次调用该方法会返回false，除非再次为线程添加中断标记</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.stop;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThreadDemo6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">30</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;中断1&quot;</span>);</span><br><span class="line">                    <span class="comment">//该方法多次调用不会清除标记</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程是否有中断标记：&quot;</span>+Thread.currentThread().isInterrupted());</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">60</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;中断2&quot;</span>);</span><br><span class="line">                    System.out.println(Thread.interrupted());</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程是否有中断标记：&quot;</span>+Thread.currentThread().isInterrupted());</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">80</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;中断3&quot;</span>);</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程是否有中断标记：&quot;</span>+Thread.currentThread().isInterrupted());</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">90</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;中断4&quot;</span>);</span><br><span class="line">                    System.out.println(Thread.interrupted());</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程是否有中断标记：&quot;</span>+Thread.currentThread().isInterrupted());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-jMM模型"><a href="#1-4-jMM模型" class="headerlink" title="1.4 jMM模型"></a>1.4 jMM模型</h3><p>JMM（Java Memory Model）：Java 内存模型，是 Java 虚拟机规范中所定义的一种内存模型，Java 内存模型是标准化的，屏蔽掉了底层不同计算机的区别。也就是说，JMM 是 JVM 中定义的一种并发编程的底层模型机制。</p>
<p>。下：</p>
<ul>
<li>所有的共享变量都存储于主内存。这里所说的变量指的是实例变量和类变量，不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。</li>
<li>每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。</li>
<li>线程对变量的所有的操作（读，写）都必须在工作内存中完成，而不能直接读写主内存中的变量。</li>
<li>不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存中转来完成。</li>
</ul>
<p>总结：</p>
<ol>
<li>每个线程都有自己的私有内存（工作内存）</li>
<li>线程对共享变量的操作只能在私有内存中进行，操作完成后写入到主内存中</li>
<li>共享比那里都存储在主内存中。 </li>
</ol>
<h3 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h3><h4 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1.原子性"></a>1.原子性</h4><p>原子性是指，一个或者多个操作不可分割，要么全部执行，并且执行过程中不会被任何因素打断，要么就都不执行。Java中可以使用synchronized保证原子性。</p>
<h4 id="http-192-168-31-254-java-advance-第15章-多线程基础-html-2-可见性-2-可见性"><a href="#http-192-168-31-254-java-advance-第15章-多线程基础-html-2-可见性-2-可见性" class="headerlink" title="[#](http://192.168.31.254/java-advance/第15章 多线程基础.html#_2-可见性)2.可见性"></a>[#](<a target="_blank" rel="noopener" href="http://192.168.31.254/java-advance/%E7%AC%AC15%E7%AB%A0">http://192.168.31.254/java-advance/第15章</a> 多线程基础.html#_2-可见性)2.可见性</h4><p>可见性是指当一个线程修改了某一个共享变量的值时，其他线程是否能够立即知道这个修改。Java中的volatile、synchronized、Lock都能保证可见性。如一个变量被volatile修饰后，表示当一个线程修改共享变量后，其会立即被更新到主内存中，其他线程读取共享变量时，会直接从主内存中读取。而synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>
<h4 id="http-192-168-31-254-java-advance-第15章-多线程基础-html-3-有序性-3-有序性"><a href="#http-192-168-31-254-java-advance-第15章-多线程基础-html-3-有序性-3-有序性" class="headerlink" title="[#](http://192.168.31.254/java-advance/第15章 多线程基础.html#_3-有序性)3.有序性"></a>[#](<a target="_blank" rel="noopener" href="http://192.168.31.254/java-advance/%E7%AC%AC15%E7%AB%A0">http://192.168.31.254/java-advance/第15章</a> 多线程基础.html#_3-有序性)3.有序性</h4><p>对于一个线程的执行代码而言，我们总是习惯性地认为代码是从前往后依次执行的。这么理解也不能说完全错误，因为就一个线程内而言，确实会表现成这样。但是，在并发时，程序的执行可能就会出现乱序。给人的直观感觉就是：写在前面的代码，会在后面执行。听起来有些不可思议，有序性问题的原因是程序在执行时，可能会进行指令重排，重排后的指令与原指令的顺序未必一致。</p>
<p>在单核CPU的场景下，当指令被重排序之后，如何保障运行的正确性呢？其实很简单，编译器和CPU都需要遵守As-if-Serial规则。<br><strong>As-if-Serial规则的具体内容为：无论如何重排序，都必须保证代码在单线程下运行正确</strong>。为了遵守As-if-Serial规则，编译器和CPU不会对存在数据依赖关系的操作进行重排序，因为这种重排序会改变执行结果。但是，如果指令之间不存在数据依赖关系，这些指令可能被编译器和CPU重排序。<br>下面是一段非常简单的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReorderDemo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>; <span class="comment">//①</span></span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">2</span>; <span class="comment">//②</span></span><br><span class="line">        <span class="keyword">int</span> c = a+b; <span class="comment">//③</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例代码中，③和①之间存在数据依赖关系，同时③和②之间也存在数据依赖关系。因此，在最终执行的指令序列中，③不能被重排序到①和②的前面，因为③排到①和②的前面，程序的结果将会被改变。但①和②之间没有数据依赖关系，编译器和CPU可以重排序①和②之间的执行顺序。<br>虽然编译器和CPU遵守了As-if-Serial规则，无论如何，也只能在单CPU执行的情况下保证结果正确。在多核CPU并发执行的场景下，由于CPU的一个内核无法清晰分辨其他内核上指令序列中的数据依赖关系，因此可能出现乱序执行，从而导致程序运行结果错误。<strong>因此As-if-Serial规则只能保障单内核指令重排序之后的执行结果正确，不能保障多内核以及跨CPU指令重排序之后的执行结果正确。</strong></p>
<h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><p>synchronize是一个修饰符，表示同步的意思，可以修饰方法，也可以修饰代码块。修饰的方法叫做同步方法，修饰的代码块叫做同步代码块，被synchronized修饰的方法或则代码，也叫做临界区，临界区的特点在同一时刻有且只能又一个现场访问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.syn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果不加此代码，运行结果不一定是200</span></span><br><span class="line">        <span class="comment">//synchronized (NumberDemo.class)&#123;</span></span><br><span class="line">            i++;</span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">                add();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">                add();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>时刻</th>
<th>线程A</th>
<th>线程B</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>抢锁，且成功</td>
<td>就绪</td>
</tr>
<tr>
<td>T2</td>
<td>读变量i</td>
<td>就绪</td>
</tr>
<tr>
<td>T3</td>
<td>修改变量i</td>
<td>就绪</td>
</tr>
<tr>
<td>T4</td>
<td>时间片到</td>
<td>运行</td>
</tr>
<tr>
<td>T5</td>
<td>就绪</td>
<td>抢锁，但是抢不到（处于阻塞状态），直到时间片结束</td>
</tr>
<tr>
<td>T6</td>
<td>获得时间片，继续执行，写入主内存</td>
<td>就绪</td>
</tr>
<tr>
<td>T7</td>
<td>退出临界区，并释放锁</td>
<td>抢锁，且成功</td>
</tr>
</tbody></table>
<p>如果多个线程分别持有自己的锁，则加锁没有意义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.syn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.bytecollege.callable.MyThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumDemo2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Object lock1 = <span class="keyword">new</span> Object();</span><br><span class="line">        Object lock2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock1)&#123;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">               <span class="keyword">synchronized</span> (lock1)&#123;</span><br><span class="line">                   add();</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>证明线程处于休眠状态时，不会释放锁。</p>
<p>证明多个线程持有同一把锁时，如果A线程持有锁，则B线程处于BLOCKED状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.syn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Object o = <span class="keyword">new</span> Object();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t1获得锁&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;t1进入休眠&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//TODO</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;t1释放锁&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t2获得锁&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>+i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;t2释放锁&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">//休眠3ms，获取t2状态</span></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        System.out.println(t2.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>synchronized修饰类方法时，锁时当前类对象即类名.class，当synchronized修饰实例方法时，锁时当前对象即this。</p>
<p><strong>修饰类方法示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.syn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">                add();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">                add();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>修饰实例方法示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.syn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        );</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行上面的示例,发现结果并不同步,这是因为两个线程分别将当前对象当做锁,也就不存在锁竞争,因此在临界区也不会存在互斥性</p>
<h4 id="【重要】synchronized实现原理"><a href="#【重要】synchronized实现原理" class="headerlink" title="【重要】synchronized实现原理"></a>【重要】synchronized实现原理</h4><p>主要有两个重要的指令monitorenter和monitorexit</p>
<p>monitorenter指令时会尝试获取相应对象的monitor，获取规则如下：</p>
<ul>
<li>如果monitor的进入数为0，则该线程可以进入monitor，并将monitor进入数设置为1，该线程即为monitor的拥有者。</li>
<li>如果当前线程已经拥有该monitor，只是重新进入，则进入monitor的进入数加1，所以synchronized关键字实现的锁是可重入的锁。</li>
<li>如果monitor已被其他线程拥有，则当前线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor。</li>
</ul>
<p><strong>monitorexit</strong><br>只有拥有相应对象的monitor的线程才能执行monitorexit指令。每执行一次该指令monitor进入数减1，当进入数为0时当前线程释放monitor，此时其他阻塞的线程将可以尝试获取该monitor。</p>
<h4 id="【重要】synchronized的内存语义"><a href="#【重要】synchronized的内存语义" class="headerlink" title="【重要】synchronized的内存语义"></a>【重要】synchronized的内存语义</h4><ol>
<li>进入synchronized内存语义是把在synchronized块内使用到的变量从线程的工作内存中清除，这样在synchronized块内使用到该变量时就不会从线程的工作内存中获取，而是直接从主内存中获取。</li>
<li>退出synchronized块的内存语义是把在synchronized块内对共享变量的修改刷新到主内存。</li>
</ol>
<p>其实这也是加锁和释放锁的语义，当获取锁后会清空锁块内本地内存中将会被用到的共享变量，在使用这些共享变量时从主内存进行加载，在释放锁时将本地内存中修改的共享变量刷新到主   内存。除可以解决共享变量内存可见性问题外，synchronized经常被用来实现原子性操作。</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>产生死锁的条件</p>
<ol>
<li>互斥条件：指线程对已经获取到的资源进行排它性使用，即该资源同时只由一个线程占用。如果此时还有其他线程请求获取该资源，则请求者只能等待，直至占有资源的线程释放该资源。</li>
<li>请求并持有条件：指一个线程已经持有了至少一个资源，但又提出了新的资源请求，而新资源已被其他线程占有，所以当前线程会被阻塞，但阻塞的同时并不释放自己已经获取的资源。</li>
<li>不可剥夺条件：指线程获取到的资源在自己使用完之前不能被其他线程抢占，只有在自己使用完毕后才由自己释放该资源。</li>
<li>环路等待条件：指在发生死锁时，必然存在一个线程—资源的环形链，即线程集合{T0, T1, T2, …, Tn}中的T0正在等待一个T1占用的资源，T1正在等待T2占用的资源，……Tn正在等待已被T0占用的资源。</li>
</ol>
<p><strong>死锁示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.deadLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Object lock1 = <span class="keyword">new</span> Object();</span><br><span class="line">        Object lock2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock1)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t1获取的lock1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock2)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;t1获取了lock2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock2)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t2获取了lock2&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock1)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;t2获取了lock1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="死锁诊断"><a href="#死锁诊断" class="headerlink" title="死锁诊断"></a>死锁诊断</h4><ol>
<li>jps -l :打印出正在运行的Java进程ID</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\88410&gt; jps -l</span><br><span class="line">13472 jdk.jcmd/sun.tools.jps.Jps</span><br><span class="line">9776 org.jetbrains.jps.cmdline.Launcher</span><br><span class="line">6504 cn.bytecollege.deadLock.DeadLockDemo</span><br><span class="line">9112</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>jstack pid</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\88410&gt; jstack 6504</span><br><span class="line">2022-08-18 10:42:16</span><br><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (11.0.15.1+2-LTS-10 mixed mode):</span><br><span class="line"></span><br><span class="line">Threads class SMR info:</span><br><span class="line">_java_thread_list=0x0000027762ad5880, length=13, elements=&#123;</span><br><span class="line">0x00000277628a2000, 0x00000277628a6000, 0x000002776291b000, 0x000002776291c000,</span><br><span class="line">0x000002776291e000, 0x0000027762920800, 0x0000027762947000, 0x0000027762018000,</span><br><span class="line">0x0000027762abd000, 0x0000027762c94800, 0x0000027762c9b800, 0x0000027762c34000,</span><br><span class="line">0x000002773f47d800</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&quot;Reference Handler&quot; #2 daemon prio=10 os_prio=2 cpu=0.00ms elapsed=121.09s tid=0x00000277628a2000 nid=0xf4c waiting on condition  [0x000000aab38ff000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">        at java.lang.ref.Reference.waitForReferencePendingList(java.base@11.0.15.1/Native Method)</span><br><span class="line">        at java.lang.ref.Reference.processPendingReferences(java.base@11.0.15.1/Reference.java:241)</span><br><span class="line">        at java.lang.ref.Reference$ReferenceHandler.run(java.base@11.0.15.1/Reference.java:213)</span><br><span class="line"></span><br><span class="line">&quot;Finalizer&quot; #3 daemon prio=8 os_prio=1 cpu=0.00ms elapsed=121.09s tid=0x00000277628a6000 nid=0x2e1c in Object.wait()  [0x000000aab39fe000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(java.base@11.0.15.1/Native Method)</span><br><span class="line">        - waiting on &lt;0x0000000713308fa8&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">        at java.lang.ref.ReferenceQueue.remove(java.base@11.0.15.1/ReferenceQueue.java:155)</span><br><span class="line">        - waiting to re-lock in wait() &lt;0x0000000713308fa8&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">        at java.lang.ref.ReferenceQueue.remove(java.base@11.0.15.1/ReferenceQueue.java:176)</span><br><span class="line">        at java.lang.ref.Finalizer$FinalizerThread.run(java.base@11.0.15.1/Finalizer.java:170)</span><br><span class="line"></span><br><span class="line">&quot;Signal Dispatcher&quot; #4 daemon prio=9 os_prio=2 cpu=0.00ms elapsed=121.08s tid=0x000002776291b000 nid=0x2ef4 runnable  [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;Attach Listener&quot; #5 daemon prio=5 os_prio=2 cpu=31.25ms elapsed=121.08s tid=0x000002776291c000 nid=0x3e34 waiting on condition  [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;Service Thread&quot; #6 daemon prio=9 os_prio=0 cpu=0.00ms elapsed=121.08s tid=0x000002776291e000 nid=0x3620 runnable  [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;C2 CompilerThread0&quot; #7 daemon prio=9 os_prio=2 cpu=15.63ms elapsed=121.08s tid=0x0000027762920800 nid=0x2138 waiting on condition  [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">   No compile task</span><br><span class="line"></span><br><span class="line">&quot;C1 CompilerThread0&quot; #10 daemon prio=9 os_prio=2 cpu=78.13ms elapsed=121.08s tid=0x0000027762947000 nid=0x2b20 waiting on condition  [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">   No compile task</span><br><span class="line"></span><br><span class="line">&quot;Sweeper thread&quot; #11 daemon prio=9 os_prio=2 cpu=0.00ms elapsed=121.08s tid=0x0000027762018000 nid=0x3b1c runnable  [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;Common-Cleaner&quot; #12 daemon prio=8 os_prio=1 cpu=0.00ms elapsed=121.02s tid=0x0000027762abd000 nid=0x1b18 in Object.wait()  [0x000000aab40fe000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(java.base@11.0.15.1/Native Method)</span><br><span class="line">        - waiting on &lt;0x0000000713225168&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">        at java.lang.ref.ReferenceQueue.remove(java.base@11.0.15.1/ReferenceQueue.java:155)</span><br><span class="line">        - waiting to re-lock in wait() &lt;0x0000000713225168&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">        at jdk.internal.ref.CleanerImpl.run(java.base@11.0.15.1/CleanerImpl.java:148)</span><br><span class="line">        at java.lang.Thread.run(java.base@11.0.15.1/Thread.java:834)</span><br><span class="line">        at jdk.internal.misc.InnocuousThread.run(java.base@11.0.15.1/InnocuousThread.java:134)</span><br><span class="line"></span><br><span class="line">&quot;Monitor Ctrl-Break&quot; #13 daemon prio=5 os_prio=0 cpu=15.63ms elapsed=120.96s tid=0x0000027762c94800 nid=0x1590 runnable  [0x000000aab42fe000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">        at java.net.SocketInputStream.socketRead0(java.base@11.0.15.1/Native Method)</span><br><span class="line">        at java.net.SocketInputStream.socketRead(java.base@11.0.15.1/SocketInputStream.java:115)</span><br><span class="line">        at java.net.SocketInputStream.read(java.base@11.0.15.1/SocketInputStream.java:168)</span><br><span class="line">        at java.net.SocketInputStream.read(java.base@11.0.15.1/SocketInputStream.java:140)</span><br><span class="line">        at sun.nio.cs.StreamDecoder.readBytes(java.base@11.0.15.1/StreamDecoder.java:284)</span><br><span class="line">        at sun.nio.cs.StreamDecoder.implRead(java.base@11.0.15.1/StreamDecoder.java:326)</span><br><span class="line">        at sun.nio.cs.StreamDecoder.read(java.base@11.0.15.1/StreamDecoder.java:178)</span><br><span class="line">        - locked &lt;0x00000007130fbf50&gt; (a java.io.InputStreamReader)</span><br><span class="line">        at java.io.InputStreamReader.read(java.base@11.0.15.1/InputStreamReader.java:181)</span><br><span class="line">        at java.io.BufferedReader.fill(java.base@11.0.15.1/BufferedReader.java:161)</span><br><span class="line">        at java.io.BufferedReader.readLine(java.base@11.0.15.1/BufferedReader.java:326)</span><br><span class="line">        - locked &lt;0x00000007130fbf50&gt; (a java.io.InputStreamReader)</span><br><span class="line">        at java.io.BufferedReader.readLine(java.base@11.0.15.1/BufferedReader.java:392)</span><br><span class="line">        at com.intellij.rt.execution.application.AppMainV2$1.run(AppMainV2.java:49)</span><br><span class="line"></span><br><span class="line">&quot;t1&quot; #14 prio=5 os_prio=0 cpu=31.25ms elapsed=120.94s tid=0x0000027762c9b800 nid=0x18a8 waiting for monitor entry  [0x000000aab44ff000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">        at cn.bytecollege.deadLock.DeadLockDemo.lambda$main$0(DeadLockDemo.java:19)</span><br><span class="line">        - waiting to lock &lt;0x000000071318a3e8&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x000000071318a3d8&gt; (a java.lang.Object)</span><br><span class="line">        at cn.bytecollege.deadLock.DeadLockDemo$$Lambda$14/0x0000000800066840.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(java.base@11.0.15.1/Thread.java:834)</span><br><span class="line"></span><br><span class="line">&quot;t2&quot; #15 prio=5 os_prio=0 cpu=15.63ms elapsed=120.93s tid=0x0000027762c34000 nid=0x2fd4 waiting for monitor entry  [0x000000aab45ff000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">        at cn.bytecollege.deadLock.DeadLockDemo.lambda$main$1(DeadLockDemo.java:32)</span><br><span class="line">        - waiting to lock &lt;0x000000071318a3d8&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x000000071318a3e8&gt; (a java.lang.Object)</span><br><span class="line">        at cn.bytecollege.deadLock.DeadLockDemo$$Lambda$15/0x0000000800066c40.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(java.base@11.0.15.1/Thread.java:834)</span><br><span class="line"></span><br><span class="line">&quot;DestroyJavaVM&quot; #16 prio=5 os_prio=0 cpu=187.50ms elapsed=120.93s tid=0x000002773f47d800 nid=0x2160 waiting on condition  [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;VM Thread&quot; os_prio=2 cpu=15.63ms elapsed=121.11s tid=0x0000027761fed000 nid=0x3018 runnable</span><br><span class="line"></span><br><span class="line">&quot;GC Thread#0&quot; os_prio=2 cpu=15.63ms elapsed=121.13s tid=0x000002773f492800 nid=0x366c runnable</span><br><span class="line"></span><br><span class="line">&quot;G1 Main Marker&quot; os_prio=2 cpu=0.00ms elapsed=121.13s tid=0x000002773f4f2000 nid=0x3750 runnable</span><br><span class="line"></span><br><span class="line">&quot;G1 Conc#0&quot; os_prio=2 cpu=0.00ms elapsed=121.13s tid=0x000002773f4f4000 nid=0x3454 runnable</span><br><span class="line"></span><br><span class="line">&quot;G1 Refine#0&quot; os_prio=2 cpu=0.00ms elapsed=121.13s tid=0x0000027761edc000 nid=0x1f34 runnable</span><br><span class="line"></span><br><span class="line">&quot;G1 Young RemSet Sampling&quot; os_prio=2 cpu=0.00ms elapsed=121.13s tid=0x0000027761edf000 nid=0x2260 runnable</span><br><span class="line">&quot;VM Periodic Task Thread&quot; os_prio=2 cpu=0.00ms elapsed=120.94s tid=0x0000027762c96800 nid=0x2748 waiting on condition</span><br><span class="line"></span><br><span class="line">JNI global refs: 16, weak refs: 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line">&quot;t1&quot;:</span><br><span class="line">  waiting to lock monitor 0x00000277628ac880 (object 0x000000071318a3e8, a java.lang.Object),</span><br><span class="line">  which is held by &quot;t2&quot;</span><br><span class="line">&quot;t2&quot;:</span><br><span class="line">  waiting to lock monitor 0x00000277628ae880 (object 0x000000071318a3d8, a java.lang.Object),</span><br><span class="line">  which is held by &quot;t1&quot;</span><br><span class="line"></span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line">&quot;t1&quot;:</span><br><span class="line">        at cn.bytecollege.deadLock.DeadLockDemo.lambda$main$0(DeadLockDemo.java:19)</span><br><span class="line">        - waiting to lock &lt;0x000000071318a3e8&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x000000071318a3d8&gt; (a java.lang.Object)</span><br><span class="line">        at cn.bytecollege.deadLock.DeadLockDemo$$Lambda$14/0x0000000800066840.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(java.base@11.0.15.1/Thread.java:834)</span><br><span class="line">&quot;t2&quot;:</span><br><span class="line">        at cn.bytecollege.deadLock.DeadLockDemo.lambda$main$1(DeadLockDemo.java:32)</span><br><span class="line">        - waiting to lock &lt;0x000000071318a3d8&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x000000071318a3e8&gt; (a java.lang.Object)</span><br><span class="line">        at cn.bytecollege.deadLock.DeadLockDemo$$Lambda$15/0x0000000800066c40.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(java.base@11.0.15.1/Thread.java:834)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure>

<h3 id="同步锁"><a href="#同步锁" class="headerlink" title="同步锁"></a>同步锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得锁</span></span><br><span class="line"><span class="comment">     * Acquires the lock.</span></span><br><span class="line"><span class="comment">     * 如果获得锁，则执行，如果没有获得锁则阻塞</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If the lock is not available then the current thread becomes</span></span><br><span class="line"><span class="comment">     * disabled for thread scheduling purposes and lies dormant until the</span></span><br><span class="line"><span class="comment">     * lock has been acquired.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;&lt;b&gt;Implementation Considerations&lt;/b&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;A &#123;<span class="doctag">@code</span> Lock&#125; implementation may be able to detect erroneous use</span></span><br><span class="line"><span class="comment">     * of the lock, such as an invocation that would cause deadlock, and</span></span><br><span class="line"><span class="comment">     * may throw an (unchecked) exception in such circumstances.  The</span></span><br><span class="line"><span class="comment">     * circumstances and the exception type must be documented by that</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> Lock&#125; implementation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取锁除非该线程被中断</span></span><br><span class="line"><span class="comment">     * Acquires the lock unless the current thread is</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupted&#125;.</span></span><br><span class="line"><span class="comment">     * 获取锁如果锁可用则立即返回</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Acquires the lock if it is available and returns immediately.</span></span><br><span class="line"><span class="comment">     * 如果锁不可用则进入阻塞状态，知道下面的2件事发生其一</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If the lock is not available then the current thread becomes</span></span><br><span class="line"><span class="comment">     * disabled for thread scheduling purposes and lies dormant until</span></span><br><span class="line"><span class="comment">     * one of two things happens:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     *    1.当前线程获得了锁</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;The lock is acquired by the current thread; or</span></span><br><span class="line"><span class="comment">     *    2.其他的线程中断了当前线程，并且支持中断获取锁</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;Some other thread &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupts&#125; the</span></span><br><span class="line"><span class="comment">     * current thread, and interruption of lock acquisition is supported.</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If the current thread:</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;has its interrupted status set on entry to this method; or</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;is &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupted&#125; while acquiring the</span></span><br><span class="line"><span class="comment">     * lock, and interruption of lock acquisition is supported,</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     * then &#123;<span class="doctag">@link</span> InterruptedException&#125; is thrown and the current thread&#x27;s</span></span><br><span class="line"><span class="comment">     * interrupted status is cleared.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;&lt;b&gt;Implementation Considerations&lt;/b&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The ability to interrupt a lock acquisition in some</span></span><br><span class="line"><span class="comment">     * implementations may not be possible, and if possible may be an</span></span><br><span class="line"><span class="comment">     * expensive operation.  The programmer should be aware that this</span></span><br><span class="line"><span class="comment">     * may be the case. An implementation should document when this is</span></span><br><span class="line"><span class="comment">     * the case.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;An implementation can favor responding to an interrupt over</span></span><br><span class="line"><span class="comment">     * normal method return.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;A &#123;<span class="doctag">@code</span> Lock&#125; implementation may be able to detect</span></span><br><span class="line"><span class="comment">     * erroneous use of the lock, such as an invocation that would</span></span><br><span class="line"><span class="comment">     * cause deadlock, and may throw an (unchecked) exception in such</span></span><br><span class="line"><span class="comment">     * circumstances.  The circumstances and the exception type must</span></span><br><span class="line"><span class="comment">     * be documented by that &#123;<span class="doctag">@code</span> Lock&#125; implementation.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if the current thread is</span></span><br><span class="line"><span class="comment">     *         interrupted while acquiring the lock (and interruption</span></span><br><span class="line"><span class="comment">     *         of lock acquisition is supported)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取锁，仅在锁可用的情况下</span></span><br><span class="line"><span class="comment">     * Acquires the lock only if it is free at the time of invocation.</span></span><br><span class="line"><span class="comment">     * 获取锁，如果锁可用则立即返回true</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Acquires the lock if it is available and returns immediately</span></span><br><span class="line"><span class="comment">     * with the value &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment">     * 如果锁不可用，在立即返回false</span></span><br><span class="line"><span class="comment">     * If the lock is not available then this method will return</span></span><br><span class="line"><span class="comment">     * immediately with the value &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;A typical usage idiom for this method would be:</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt; &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">     * Lock lock = ...;</span></span><br><span class="line"><span class="comment">     * if (lock.tryLock()) &#123;</span></span><br><span class="line"><span class="comment">     *   try &#123;</span></span><br><span class="line"><span class="comment">     *     // manipulate protected state</span></span><br><span class="line"><span class="comment">     *   &#125; finally &#123;</span></span><br><span class="line"><span class="comment">     *     lock.unlock();</span></span><br><span class="line"><span class="comment">     *   &#125;</span></span><br><span class="line"><span class="comment">     * &#125; else &#123;</span></span><br><span class="line"><span class="comment">     *   // perform alternative actions</span></span><br><span class="line"><span class="comment">     * &#125;&#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This usage ensures that the lock is unlocked if it was acquired, and</span></span><br><span class="line"><span class="comment">     * doesn&#x27;t try to unlock if the lock was not acquired.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the lock was acquired and</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果在等待的时间内获取了锁，并且当前线程没有被中断</span></span><br><span class="line"><span class="comment">     * Acquires the lock if it is free within the given waiting time and the</span></span><br><span class="line"><span class="comment">     * current thread has not been &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupted&#125;.</span></span><br><span class="line"><span class="comment">     * 如果锁可用，则立即返回true</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If the lock is available this method returns immediately</span></span><br><span class="line"><span class="comment">     * with the value &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment">     * 如果锁不可用则当前线程进入阻塞状态，知道以下3种情况发生其一</span></span><br><span class="line"><span class="comment">     * If the lock is not available then</span></span><br><span class="line"><span class="comment">     * the current thread becomes disabled for thread scheduling</span></span><br><span class="line"><span class="comment">     * purposes and lies dormant until one of three things happens:</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt; </span></span><br><span class="line"><span class="comment">     *  1. 获得锁</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;The lock is acquired by the current thread; or</span></span><br><span class="line"><span class="comment">     *  2. 被其他线程中断</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;Some other thread &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupts&#125; the</span></span><br><span class="line"><span class="comment">     * current thread, and interruption of lock acquisition is supported; or</span></span><br><span class="line"><span class="comment">     *  3. 等待时间耗尽</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;The specified waiting time elapses</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If the lock is acquired then the value &#123;<span class="doctag">@code</span> true&#125; is returned.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If the current thread:</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;has its interrupted status set on entry to this method; or</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;is &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupted&#125; while acquiring</span></span><br><span class="line"><span class="comment">     * the lock, and interruption of lock acquisition is supported,</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     * then &#123;<span class="doctag">@link</span> InterruptedException&#125; is thrown and the current thread&#x27;s</span></span><br><span class="line"><span class="comment">     * interrupted status is cleared.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If the specified waiting time elapses then the value &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">     * is returned.</span></span><br><span class="line"><span class="comment">     * If the time is</span></span><br><span class="line"><span class="comment">     * less than or equal to zero, the method will not wait at all.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;&lt;b&gt;Implementation Considerations&lt;/b&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The ability to interrupt a lock acquisition in some implementations</span></span><br><span class="line"><span class="comment">     * may not be possible, and if possible may</span></span><br><span class="line"><span class="comment">     * be an expensive operation.</span></span><br><span class="line"><span class="comment">     * The programmer should be aware that this may be the case. An</span></span><br><span class="line"><span class="comment">     * implementation should document when this is the case.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;An implementation can favor responding to an interrupt over normal</span></span><br><span class="line"><span class="comment">     * method return, or reporting a timeout.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;A &#123;<span class="doctag">@code</span> Lock&#125; implementation may be able to detect</span></span><br><span class="line"><span class="comment">     * erroneous use of the lock, such as an invocation that would cause</span></span><br><span class="line"><span class="comment">     * deadlock, and may throw an (unchecked) exception in such circumstances.</span></span><br><span class="line"><span class="comment">     * The circumstances and the exception type must be documented by that</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> Lock&#125; implementation.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time the maximum time to wait for the lock</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit the time unit of the &#123;<span class="doctag">@code</span> time&#125; argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the lock was acquired and &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">     *         if the waiting time elapsed before the lock was acquired</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if the current thread is interrupted</span></span><br><span class="line"><span class="comment">     *         while acquiring the lock (and interruption of lock</span></span><br><span class="line"><span class="comment">     *         acquisition is supported)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;&lt;b&gt;Implementation Considerations&lt;/b&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;A &#123;<span class="doctag">@code</span> Lock&#125; implementation will usually impose</span></span><br><span class="line"><span class="comment">     * restrictions on which thread can release a lock (typically only the</span></span><br><span class="line"><span class="comment">     * holder of the lock can release it) and may throw</span></span><br><span class="line"><span class="comment">     * an (unchecked) exception if the restriction is violated.</span></span><br><span class="line"><span class="comment">     * Any restrictions and the exception</span></span><br><span class="line"><span class="comment">     * type must be documented by that &#123;<span class="doctag">@code</span> Lock&#125; implementation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * Returns a new &#123;<span class="doctag">@link</span> Condition&#125; instance that is bound to this</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> Lock&#125; instance.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Before waiting on the condition the lock must be held by the</span></span><br><span class="line"><span class="comment">     * current thread.</span></span><br><span class="line"><span class="comment">     * A call to &#123;<span class="doctag">@link</span> Condition#await()&#125; will atomically release the lock</span></span><br><span class="line"><span class="comment">     * before waiting and re-acquire the lock before the wait returns.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;&lt;b&gt;Implementation Considerations&lt;/b&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The exact operation of the &#123;<span class="doctag">@link</span> Condition&#125; instance depends on</span></span><br><span class="line"><span class="comment">     * the &#123;<span class="doctag">@code</span> Lock&#125; implementation and must be documented by that</span></span><br><span class="line"><span class="comment">     * implementation.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A new &#123;<span class="doctag">@link</span> Condition&#125; instance for this &#123;<span class="doctag">@code</span> Lock&#125; instance</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedOperationException if this &#123;<span class="doctag">@code</span> Lock&#125;</span></span><br><span class="line"><span class="comment">     *         implementation does not support conditions</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<p>lock()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.synLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//线程t加锁</span></span><br><span class="line">                lock.lock();</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t2获取锁&quot;</span>);</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">&quot;t2得到锁&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">//主线程休眠1秒</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        System.out.println(t1.getState());</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的示例中，t1线程获得锁后，并没有释放锁，t2线程会一直阻塞。</p>
<p>tryLock()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.synLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//线程t加锁</span></span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.println(<span class="string">&quot;t1获得锁&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;t1休眠&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//释放锁</span></span><br><span class="line">                System.out.println(<span class="string">&quot;释放锁&quot;</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">               <span class="comment">//如果锁可用，则获取，如果锁不可用则返回false</span></span><br><span class="line">               <span class="keyword">if</span>(lock.tryLock())&#123;</span><br><span class="line">                   System.out.println(<span class="string">&quot;t2获取到锁&quot;</span>);</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   System.out.println(<span class="string">&quot;t2没有获取到锁&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               lock.unlock();</span><br><span class="line">               System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>tryLock()方法的特点是，如果锁可用则获取，如果锁不可用则立即返回false，上面的实例中，如果删除22行代码，并不会影响t2线程的执行。</p>
<p><strong>注意：使用lock()方法加锁后，一定要使用unlock()方法解锁，通常unlock()方法放置在finally中，此外同一线程中，unlock()方法调用前，必须要调用lock()方法，否则会抛出异常</strong></p>
<p>lockInterruptibly()示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bytecollege.synLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="comment">//线程t加锁</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">&quot;t1获得锁&quot;</span>);</span><br><span class="line"><span class="comment">//            lock.unlock();</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;t1释放锁&quot;);</span></span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t2获取锁&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lockInterruptibly();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t2响应中断信号&quot;</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;t1启动&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;t2启动&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;中断t2&quot;</span>);</span><br><span class="line">        t2.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，t1线程在获得锁以后，并没有释放做，因此t2线程会一直处于阻塞状态，此时调用interrupt()方法，中断获取锁的过程</p>
<p>lockInterruptibly会抛出InterruptedException。</p>
<h4 id="学习心得："><a href="#学习心得：" class="headerlink" title="学习心得："></a>学习心得：</h4><p>这两天学习多线程这块相对于前面的内容比较难理解，王哥很明显放慢了讲课速度，学起来轻松多了。今天太热了，到下午这会都快热的学不动了，不过在我的坚强的意志，端正学习态度，和在Byte公司无限的关怀，和细心的照料之下还是挺过来了。</p>

    </div>

    
    
    
    
    <div>
      
         <div>
	
		<div style="text-align:center;color:#bfbfbf;font-size:16px;"> 
 		<span>-------- 本文结束 </span> 
 		<i class="fa fa-paw"></i> 
 		<span> 感谢阅读 --------</span>
		</div> 
  	
</div>
      
    </div>

    <footer class="post-footer">
          <div class="reward-container">
  <div></div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.png" alt="simon·yi an 微信">
        <span>微信</span>
      </div>

  </div>
</div>


        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/08/10/xianTrain20-Exception/" rel="prev" title="异常">
                  <i class="fa fa-chevron-left"></i> 异常
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/08/10/xianTrain21-IOStream/" rel="next" title="IO流">
                  IO流 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">simon·yi an</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">367k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">5:33</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

  <div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_uv">
    本站总访客数:<span id="busuanzi_value_site_uv"></span>&nbsp;&nbsp;| 
  </span>
  <span id="busuanzi_container_site_pv">
      &nbsp;本站总访问量<span id="busuanzi_value_site_pv"></span>次
  </span>
  </div>
  </div>
<script>
      var now = new Date(); 
      function createtime() { 
          var grt= new Date("03/12/2019 12:00:00");//此处修改你的建站时间或者网站上线时间 
          now.setTime(now.getTime()+250); 
          days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
          hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
          if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
          mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
          seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
          snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
          document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; 
          document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
      } 
  setInterval("createtime()",250);
  </script>
    </div>
  </footer>

  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>






  <script async src="/js/cursor/fireworks.js"></script>




  <script src="/js/activate-power-mode.min.js"></script>
  <script>
    POWERMODE.colorful = true;
    POWERMODE.shake = false;
    document.body.addEventListener('input', POWERMODE);
  </script>

</body>
</html>
