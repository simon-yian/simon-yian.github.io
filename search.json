[{"title":"JVM常用参数","date":"2022-09-17T08:23:57.000Z","url":"/2022/09/17/jvmCommonParameters/","categories":[["XiAnTrain - java高级篇","/categories/XiAnTrain-java%E9%AB%98%E7%BA%A7%E7%AF%87/"]],"content":"***&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Java基础学习打卡第2天 参数名称 含义 默认值 说明 -Xms 初始堆大小 物理内存的1/64(&lt;1GB) 默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制. -Xmx 最大堆大小 物理内存的1/4(&lt;1GB) 默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制 -Xmn 年轻代大小(1.4or later) 注意：此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的。整个堆大小=年轻代大小 + 老年代大小 + 持久代（永久代）大小.增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8 -XX:NewSize 设置年轻代大小(for 1.3/1.4) -XX:MaxNewSize 年轻代最大值(for 1.3/1.4) -XX:PermSize 设置持久代(perm gen)初始值 物理内存的1/64 -XX:MaxPermSize 设置持久代最大值 物理内存的1/4 -Xss 每个线程的堆栈大小 JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K.根据应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右一般小的应用， 如果栈不是很深， 应该是128k够用的 大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。（校长）和threadstacksize选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话:-Xss is translated in a VM flag named ThreadStackSize”一般设置这个值就可以了 -XX:NewRatio 年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代) -XX:NewRatio=4表示年轻代与年老代所占比值为1:4,年轻代占整个堆栈的1/5Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。 -XX:SurvivorRatio Eden区与Survivor区的大小比值 设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10 -XX:+DisableExplicitGC 关闭System.gc() 这个参数需要严格的测试 -XX:PretenureSizeThreshold 对象超过多大是直接在旧生代分配 0 单位字节 新生代采用Parallel ScavengeGC时无效另一种直接在旧生代分配的情况是大的数组对象,且数组中无外部引用对象. -XX:ParallelGCThreads 并行收集器的线程数 此值最好配置与处理器数目相等 同样适用于CMS -XX:MaxGCPauseMillis 每次年轻代垃圾回收的最长时间(最大暂停时间) 如果无法满足此时间,JVM会自动调整年轻代大小,以满足此值. "},{"title":"java新特性","date":"2022-09-17T08:20:16.000Z","url":"/2022/09/17/xianTrain26-JavaNewCharacteristic/","categories":[["XiAnTrain - java高级篇","/categories/XiAnTrain-java%E9%AB%98%E7%BA%A7%E7%AF%87/"]],"content":"***&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Java基础学习打卡第2天 Lambda表达式是Java8中新增的特性，lambda表达式是一个可传递的代码块，可以在以后执行一次或多次。在以前定义的方法中，只能将基本类型或者引用类型的变量作为方法参数，在Java 8以后可以将一个代码片段作为方法参数。 19.1 Lambda表达式入门在集合中Java为开发者提供了遍历集合的简洁方式，如下例所示： package cn.bytecollege; import java.util.List;import java.util.ArrayList;public class LambdaDemo { public static void main(String[] args) { List list = new ArrayList&lt;&gt;(); } 在上面的示例中，调用了list对象的foreach方法，从程序可以看出，传入foreach的并不是一个变量，而是一段代码，这就是Lambda表达式。从上面的语法可以看出，Lambda表达式的主要作用就是代替匿名内部类的烦琐语法。Lambda由3部分组成： 形参列表：形参列表允许省略形参的数据类型，如果形参列表中有且只有1个参数，可以省略形参列表的括号箭头函数：-&gt;必须有横线和大于号组成代码块。如果代码块只包含一条语句，Lambda表达式允许省略代码块的花括号。下面，通过示例来学习Lambda的写法： //表达式只有1个参数(a)-&gt;{ System.out.print(a);}//表达式可以简写为a-&gt;{ System.out.print(a);}//如果代码块中只有1条语句，可以省略大括号a-&gt;System.out.print(a) 19.2 函数式接口Lambda表达式的目标类型必须是函数式接口，所谓函数式接口代表只包含一个抽象方法的接口，函数式接口可以包含多个默认方法、类方法，但是只能声明一个抽象方法。 如果采用匿名内部类语法来创建函数式接口的实例，则只需要实现一个抽象方法，在这种情况下可采用Lambda表达式来创建对象。 注意：Java8 专门为函数式接口提供了@FunctionalInterface注解，该注解通常放在接口定义前，该注解对程序功能没有任何作用，它的作用是用于告诉编译器执行更严格的检查，检查该接口必须是函数式接口，否则编译器出错。 Lambda表达式的结果就是被作为对象，程序中晚期可以使用Lambda表达式进行赋值，例如在多线程Thread类的构造器中可以传入Runnable接口的子类对象。查看Runnable接口发现，该接口也被声明为一个函数式接口： @FunctionalInterfacepublic interface Runnable { public abstract void run();}所以，就可以使用Lambda表达式来创建线程： package cn.bytecollege;public class ThreadLambdaDemo { public static void main(String[] args) { Thread thread = new Thread(()-&gt;{ for (int i = 0; i &lt; 10; i++) { System.out.println(i); } }); thread.start(); }}Lambda 表达式实现的是匿名方法——因此它只能实现特定函数式接口中的唯一方法。这意味着 Lambda 表达式有如下两个限制。 Lambda 表达式的目标类型必须是明确的函数式接口。Lambda 表达式只能为函数式接口创建对象。Lambda 表达式只能实现一个方法，因此它只能为 只有一个抽象方法的接口（函数式接口）创建对象。下面定义一个函数式接口深入学习Lambda表达式 package cn.bytecollege;//函数式接口只能有一个抽象方法，并且要使用@FunctionalInterface声明@FunctionalInterfacepublic interface Consumer { int add(int a,int b);} 定义一个方法，方法参数是Consumer接口： package cn.bytecollege; public class MyTest { public static int test(Consumer consumer) { int a = 5; int b = 4; return consumer.add(a, b); } 在上例中定义了一个函数式接口，在测试类的test方法传入了接口并调用了Consumer接口的add方法，需要注意的是，此时add方法并没有方法实现，在main方法中调用了test，并将一段代码（即add方法的实现）也就是lambda表达式当做参数传入了test方法。换句话说在上例中使用了lambda表达替代了烦琐的匿名内部类。对比下面的代码就可以看出Lambda表达式的独到之处。 package cn.bytecollege; public class MyTest { public static int test(Consumer consumer) { int a = 5; int b = 4; return consumer.add(a, b); } 从前面的程序可以看出Lambda表达式的使用离不开函数式接口，通常函数式接口中有且只能有1个抽象方法，这样使用Lambda表达式时也就明确了是哪个抽象方法的实现，如果接口中出现了多个抽象方法，那么就不能在接口上使用@FunctionInterface注解，会编译出错。因此，Java 8在java.util.function包中预定义了大量函数式接口，通常情况下这些接口完全可以满足开发需要： XxxFunction∶ 这类接口中通常包含一个 apply()抽象方法，该方法对参数进行处理、转换（apply() 方法的处理逻辑由 Lambda 表达式来实现），然后返回一个新的值。该函数式接口通常用于对指定数据进行转换处理。XxxConsumer∶ 这类接口中通常包含一个 accept()抽象方法，该方法与 XxxFunction 接口中的 apply()方法基本相似，也负责对参数进行处理，只是该方法不会返回处理结果。XxxxPredicate∶这类接口中通常包含一个 test()抽象方法，该方法通常用来对参数进行某种判断 test()方法的判断逻辑由 Lambda 表达式来实现），然后返回一个 boolean 值。该接口通常用于判断参数是否满足特定条件，经常用于进行筛滤数据。XxxSupplier∶ 这类接口中通常包含一个 getAsXxx()抽象方法，该方法不需要输入参数，该方法会按某种逻辑算法（getAsXxx()方法的逻辑算法由 Lambda 表达式来实现）返回一个数据。综上所述，不难发现 Lambda 表达式的本质很简单，就是使用简洁的语法来创建函数式接口的实例——这种语法避免了匿名内部类的烦琐。下面在程序中示范上述接口的使用： package cn.bytecollege.lambda; import java.util.function.Function; /** 数据转换 @author MR.W /public class CastUtil { /** 定义方法将Object类型转换为String类型 @param function @param o @return /public static String castToString(Function&lt;Object, String&gt; function, Integer a) { return function.apply(a);}} 在上面的CastUtil类中定义了castToString，在该方法中第一个参数是一个Java 8 预定义的函数式接口，在方法内调用了Function接口的apply()方法，作用是将任意类型转换成String。但是此时这个方法并没有方法的实现，需要在调用此方法时传入方法的实现。 package cn.bytecollege.lambda;import java.util.function.Function;public class Test { public static void main(String[] args) { Integer a = 10010; //使用Lambda表达式，此时castToString方法的第一个参数 //就是Function函数式接口apply()的实现 String s = CastUtil.castToString((o)-&gt;{ return String.valueOf(o); }, a); System.out.println(s); }}在测试类中，调用了CastUtil的castToString()方法，并传入了Lambda表达式，以此Lambda表达式作为apply()方法的实现，在表达式中使用了String.valueOf()方法将对象转换成String类型。 19.3 方法引用与构造器引用前面已经介绍过，如果Lambda 表达式的代码块只有一条代码，程序就可以省略 Lambda 表达式中代码块的花括号。不仅如此，如果Lambda 表达式的代码块只有一条代码，还可以在代码块中使用方法引用和构造器引用。 方法引用和构造器引用可以让 Lambda表达式的代码块更加简洁。方法引用和构造器引用都需要使用两个英文冒号。Lambda 表达式支持如下表所示的几种引用方式。 19.3.1 引用类方法下面的示例将演示类方法的引用，首先定义一个函数式接口，接口中定义抽象方法castToString()，该方法的作用是将一个对象转换成String对象。 package cn.bytecollege.lambda;@FunctionalInterfacepublic interface Function&lt;T,R&gt; { R castToString(T t);} 在String的学习中可以知道，String类有提供了类方法valueOf(Object o)，该方法可以将任意对象转换成String类型，因此可以使用该方法作为Lambda表达式的实现代码： package cn.bytecollege.lambda; public class RefTest { public static void main(String[] args) { Function&lt;Object, String&gt; function = a-&gt;{ return String.valueOf(a); }; System.out.println(function.castToString(“张三”)); }} 在上面的代码中，创建了Lambda表达式作为了Function接口中castToString()方法的实现。在Lambda表达式中调用了String.valueOf()方法来进行对象到字符串的转换，在代码第8行调用了function接口的castToString()方法，实际上调用了就是代码第5行创建的Lambda表达式。上面的Lambda表达式的代码块只有一行调用类方法的代码，因此可以使用如下方法引用进行替换。代码如下： package cn.bytecollege.lambda; public class RefTest { public static void main(String[] args) { Function&lt;Object, String&gt; function = String::valueOf; System.out.println(function.castToString(“张三”)); }} 对于上面的类方法的引用，也就是调用了String类的valueOf()方法来实现Function函数式接口中唯一抽象方法。当调用castToString()方法时，调用参数将会传给String类的valueOf()类方法。 19.3.2 引用对象的实例方法下面演示第二种方法引用，引用对象的实例方法，首先使用Lambda表达式创建一个Function接口的子类对象： Function&lt;Object, String&gt; function = o-&gt;o.toString();上面的Lambda表达式只有一条语句，因此省略了该代码的花括号。接下来程序调用function对象的castToString()方法： package cn.bytecollege.lambda;public class RefTest { public static void main(String[] args) { Function&lt;Object, String&gt; function = o-&gt;o.toString(); System.out.println(function.castToString(100)); }} 上面的程序调用了function对象的castToString()方法时，由于function对象是Lambda表达式创建，castToString()方法的执行体就是Lambda表达式的代码部分，因此上面的程序输出了100.上面的Lambda表达式代码只有一行，且调用了对象的o的toString()实例方法。因此代码可以进行如下替换： package cn.bytecollege.lambda;public class RefTest { public static void main(String[] args) { Function&lt;Object, String&gt; function = Object::toString; System.out.println(function.castToString(100)); }} 上面的Lambda表达式的代码只有一条语句，因此省略了代码块的花括号；而且由于表达式实现的castToString方法需要返回值，因此Lambda表达会将这行代码的值作为返回值。此时就可以使用方法引用进行替换，直接引用Object的toString()方法作为Lambda表达式的代码块。其中Function接口的castToString方法有个参数，当执行Lambda表达式代码块时，会自动调用传入参数的toString()方法。 19.3.3 引用构造器下面的实例将演示如何引用构造器，首先定义函数式接口： package cn.bytecollege.lambda;@FunctionalInterfacepublic interface MyInterface { StringBuilder get(String s);} 该函数式接口包含了一个get()抽象方法，该方法的作用是使用String对象生成一个StringBuilder对象，接着使用Lambda表达式创建一个MyInterface的对象： package cn.bytecollege.lambda;public class RefTest3 { public static void main(String[] args) { MyInterface myInterface = (s)-&gt; new StringBuilder(s); StringBuilder sb = myInterface.get(“张三”); }}上面的代码调用了myInterface对象的get()方法时，由于该对象是Lambda表达式创建的，因此get()方法执行体就是Lambda表达式的代码块部分，即执行体就是执行new StringBuilder(a)语句，并将这条语句的值作为方法的返回值。因此上面代码中Lambda表达式的代码可以进行如下替换： package cn.bytecollege.lambda; public class RefTest3 { public static void main(String[] args) { MyInterface myInterface = StringBuilder::new; StringBuilder sb = myInterface.get(“张三”); }} 对于上面的构造器引用，也就是调用StringBuilder类的构造方法来实现MyInteface函数式接口中唯一的抽象方法，当调用MyInterface接口的test()方法是，调用参数会传给StringBuilder构造器，从上面的程序中可以看出，调用myInterface对象的get()方法时，实际只传入了一个String类型的参数，这个String类型的参数会被传给StringBuilder的构造器。 19.4 Lambda表达式和匿名内部类的联系和区别从前面介绍可以看出，Lambda 表达式是匿名内部类的一种简化，因此它可以部分取代匿名内部类的作用，Lambda 表达式与匿名内部类存在如下相同点。 Lambda 表达式与匿名内部类一样，都可以直接访问”effectively final”的局部变量，以及外部 类的成员变量（包括实例变量和类变量）。Lambda 表达式创建的对象与匿名内部类生成的对象一样，都可以直接调用从接口中继承的默认 方法。首先创建函数式接口： package cn.bytecollege.ano;@FunctionalInterfacepublic interface Display { int add(int a,int b); } package cn.bytecollege.ano; public class LambdaTest { private int age = 18; private static String name = “Byte科技”; // book = “Java核心技术卷”; System.out.println(display.add(1, 2)); }} 创建测试类： package cn.bytecollege.ano; public class Test { public static void main(String[] args) { LambdaTest test = new LambdaTest(); test.test(); }} 上面的程序使用Lambda表达式创建了一个Display接口的对象，Lambda表达式分别访问了外部类的实例变量，类变量从这些来看Lambda表达式的代码块和匿名内部类的方法体是相同的。和匿名内部类相似，由于Lambda表达式访问了了book局部变量，因此该局部变量相当于有一个隐式的final修饰，不允许对book局部变量重新赋值。当程序使用 Lambda 表达式创建了 Display 的对象之后，该对象不仅可调用接口中唯一的抽象方法，也可调用接口中的默认方法。Lambda表达式与匿名内部类主要存在如下区别: 匿名内部类可以为任意接口创建实例——不管接口包含多少个抽象方法，只要匿名内部类实现 所有的抽象方法即可;但 Lambda 表达式只能为函数式接口创建实例。匿名内部类可以为抽象类甚至普通类创建实例;但 Lambda 表达式只能为函数式接口创建实例。匿名内部类实现的抽象方法的方法体允许调用接口中定义的默认方法;但 Lambda 表达式的代 码块不允许调用接口中定义的默认方法。 19.5 StreamJava8 还新增了Stream、IntStream、LongStream、DoubleStream等流式API（注意：这里的Stream并不是IO中的Stream），这些API代表多个支持串行和并行聚集操作的元素。上面的4个接口中，Stream是一个通用的流接口，而IntStream、LongStream、DoubleStream则代表元素类型为int、long、double的流。Java 8 还为上面每个流式 API 提供了对应的 Builder，例如 Stream.Builder、IntStream.Builder、 LongStream.Builder、DoubleStream.Builder，开发者可以通过这些 Builder 来创建对应的流 独立使用 Stream 的步骤如下∶ 使用 Stream 或 XxxStream 的 builder()类方法创建该 Stream 对应的 Builder。重复调用 Builder 的 add()方法向该流中添加多个元素。调用 Builder 的 build()方法获取对应的 Stream。调用 Stream 的聚集方法。Stream提供了大量的方法进行聚集操作，这些方法可以是中间的，也可以是末端的。 中间方法∶中间操作允许流保持打开状态，并允许直接调用后续方法。也就是说中间方法可以连续调用。末端方法; 末端方法是对流的最终操作。当对某个 Stream 执行末端方法后，该流将会被”消耗” 且不再可用。换句话说就是末端方法一旦调用后就会关闭流，再不能对流进行操作，否则会抛出异常。下面先介绍Stream常用的中间方法： filter(Predicate predicate)∶ 过滤 Stream 中所有不符合 predicate 的元素。mapToXxx(ToXxxFunction mapper)∶使用 ToXxxFunction 对流中的元素执行一对一的转换，该方 法返回的新流中包含了ToXxxFunction 转换生成的所有元素。peek(Consumer action)∶ 依次对每个元素执行一些操作，该方法返回的流与原有流包含相同的元 素。该方法主要用于调试。distinct()∶该方法用于排序流中所有重复的元素（判断元素重复的标准是使用 equals（）比较返回 true）。这是一个有状态的方法。sorted()∶该方法用于保证流中的元素在后续的访问中处于有序状态。这是一个有状态的方法。limit(long maxSize)∶ 该方法用于保证对该流的后续访问中最大允许访问的元素个数。这是一个 有状态的、短路方法。下面简单介绍一下 Stream 常用的末端方法。 forEach(Consumer action)∶ 遍历流中所有元素，对每个元素执行 action。toArray()∶将流中所有元素转换为一个数组。reduce（）∶该方法有三个重载的版本，都用于通过某种操作来合并流中的元素。min()∶ 返回流中所有元素的最小值。max()∶ 返回流中所有元素的最大值。count()∶ 返回流中所有元素的数量。anyMatch(Predicate predicate)：判断流中是否至少包含一个元素符合 Predicate 条件。allMatch(Predicate predicate)：判断流中是否每个元素都符合 Predicate 条件。noneMatch(Predicate predicate)∶判断流中是否所有元素都不符合 Predicate 条件。findFirst()∶ 返回流中的第一个元素。findAny()∶返回流中的任意一个元素。下面，通过示例来学习Stream的使用： package cn.bytecollege.stream; import java.util.stream.IntStream; public class IntStreamTest { public static void main(String[] args) { IntStream is = IntStream.builder() .add(100) .add(10) .add(30) .add(40) .build(); //调用聚集方法,下列方法都是末端方法，因此同时只能调用1个// System.out.println(“最大值：”+is.max().getAsInt());// System.out.println(“最小值：”+is.min().getAsInt());// System.out.println(“总和：”+is.sum());// System.out.println(“总数”+is.count());// System.out.println(“平均值”+is.average());// System.out.println(“判断所有元素的是否都大于10:”+is.allMatch(e-&gt;e&gt;10));// System.out.println(“判断是否任意一个元素都大于10:”+is.anyMatch(e-&gt;e&gt;20)); }除此之外，Java8允许使用流式API来操作集合，这也是Stream的重要使用场景之一，Collection接口提供了stream()默认方法，该方法可以返回该集合对应的流，下面使用Stream来操作集合。 package cn.bytecollege.stream; import java.util.ArrayList;import java.util.List;import java.util.stream.Stream; public class ListStreamDemo { public static void main(String[] args) { // System.out.println(stream.filter(e-&gt;e.contains(“Java”)).count()); //取出前3个元素 stream.limit(3).forEach(System.out::println); }} 在上面的实例中首先获取了List的Stream，在代码20行对stream进行了过滤，筛选出了包含Java的字符串，然后调用了count()统计了过滤后的字符串个数。因为count()是末端方法，因此调用后再不能进行后续操作。代码22行是用limit取出了前3个元素，并对其进行了遍历。需要注意的是，Stream对集合的操作并不影响List中保存的数据。"},{"title":"反射和注解","date":"2022-09-17T08:13:16.000Z","url":"/2022/09/17/xianTrain24-reflex/","categories":[["XiAnTrain - java高级篇","/categories/XiAnTrain-java%E9%AB%98%E7%BA%A7%E7%AF%87/"]],"content":"***&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Java基础学习打卡第2天 本章将会深入介绍 Java类的加载、连接和初始化知识，并重点介绍 java.lang.reflect 包下的接口和类，包括 Class、Method、Field、Constructor 和 Array等，这些类分别代表类、方法、成员变量、构造器和数组，Java 程序可以使用这些类动态地获取某个对象。某个类的运行时信息，并可以动态地创建 Java 对象，动态地调用Java方法，访问并修改指定对象的成员变量值。 [#](第17章 反射和注解.html#_17-1-类的加载)17.1 类的加载当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过加载、连接、初始化三个步骤来对该类进行初始化。如果没有意外，JVM 将会连续完成这三个步骤，所以有时也把这三个步骤统称为类加载或类初始化。 类加载指的是将类的** class 文件**读入内存，并为之创建一个 java.lang.Class 对象，也就是说，当程序中使用任何类时，系统都会为之建立一个 java.lang.Class 对象。类的加载由类加载器完成，类加载器通常由 JVM提供，这些类加载器也是前面所有程序运行的基础，JVM 提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承 ClassLoader基类来创建自己的类加载器。 通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。 从本地文件系统加载 class 文件，这是前面绝大部分示例程序的类加载方式。 从JAR 包加载 class 文件，这种方式也是很常见的，前面介绍 JDBC 编程时用到的数据库驱动类 就放在 JAR 文件中，JVM 可以从 JAR 文件中直接加载该 class 文件。 通过网络加载class 文件。 把一个 Java 源文件动态编译，并执行加载。 [#](第17章 反射和注解.html#_17-2-class文件结构)17.2 Class文件结构Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。一个Class文件包含一下几部分： 魔数：每个Class文件的头4个字节称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。很多文件存储标准中都使用魔数来进行身份识别，譬如图片格式，如gif或者jpeg等在文件头中都存有魔数。使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动。文件格式的制定者可以自由地选择魔数值，只要这个魔数值还没有被广泛采用过同时又不会引起混淆即可。 版本号：紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号（Minor Version），第7和第8个字节是主版本号（Major Version）。Java的版本号是从45开始的，JDK 1.1之后的每个JDK大版本发布主版本号向上加1（JDK 1.0～1.1使用了45.0～45.3的版本号），高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class文件。 常量池：紧接着主次版本号之后的是常量池入口，常量池可以理解为Class文件之中的资源仓库，它是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一，常量池中主要存放两大类常量：字面量（Literal）和符号引用（SymbolicReferences）。字面量比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括了下面三类常量： 类和接口的全限定名 字段的名称和描述符 方法的名称和描述符 访问标志：在常量池结束之后，紧接着的两个字节代表访问标志（access_fags），这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等。 类索引、父类索引、与接口索引集合：Class文件中由这三项数据来确定这个类的继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为0。接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements语句（如果这个类本身是一个接口，则应当是extends语句）后的接口顺序从左到右排列在接口索引集合中。 字段表集合：字段表（field_info）用于描述接口或者类中声明的变量。字段（field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。描述实例变量和类变量以及实例变量的信息包括：字段的作用域（public、private、protected修饰符）、是实例变量还是类变量（static修饰符）、可变性（final）、并发可见性（volatile修饰符，是否强制从主内存读写）、可否被序列化（transient修饰符）、字段数据类型（基本类型、对象、数组）、字段名称。 方法表集合：Class文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式，方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。 属性表集合：在Class文件、字段表、方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与Class文件中其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松了一些，不再要求各个属性表具有严格顺序，并且只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不认识的属性。 [#](第17章 反射和注解.html#_17-3-类加载器)17.3 类加载器类加载器负责加载所有的类，系统为所有被载入内存中的类生成一个java.lang.Class实例。一旦一个类被载入JVM中，同一个类就不会被再次载入了。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。当JVM启动时，会形成由3个类加载器组成的初始类加载器层次结构。 Bootstrap ClassLoader：根类加载器。它负责加载Java的核心类。 Extension ClassLoader：扩展类加载器。它负责加载 JRE 的扩展目录（%JAVA_HOME%/jre/lib/ext）中JAR包的类。 System ClassLoader：系统类加载器。它负责在JVM启动时加载来自java命令的-classpath选项、java.class.path系统属性，或CLASSPATH环境变量所指定的JAR包和类路径。 [#](第17章 反射和注解.html#_17-3-1-类加载机制)17.3.1 类加载机制JVM的类加载机制主要有如下3种。 全盘负责，所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他 Class 也将由该类加载器负责载入，除非显式使用另外一个类加载器来载入。 双亲委派，所谓父类委托，则是先让 parent（父）类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。 缓存机制。缓存机制将会保证所有加载过的 Class 都会被缓存，当程序中需要使用某个 Class 时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区中。 [#](第17章 反射和注解.html#_17-3-2-类加载过程)17.3.2 类加载过程类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。其中验证、准备、解析3个部分统称为连接（Linking），这7个阶段的发生顺序如下图所示。下面将详细讲解在类加载过程中每一步中的详细过程：1.加载“加载”是“类加载”（Class Loading）过程的一个阶段，希望读者没有混淆这两个看起来很相似的名词。在加载阶段，虚拟机需要完成以下3件事情： 通过一个类的全限定名来获取定义此类的二进制字节流。 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。 2.验证验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 文件格式验证，第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。这一阶段可能包括下面这些验证点： 是否以魔术0xCAFEBABE 主、次版本号是否在当前虚拟机处理范围内 常量池的常量中是否有不被支持的类型 指向常量的各种索引值是否有执行不存在的常量或者不符合类型的常量 CONSTANT_Utf8_info型的常量中是否有不符合UTF8编码的数据。 Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。 元数据验证，第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求，这个阶段可能包括的验证点如下： 这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。 这个类的父类是否继承了不允许被继承的类（被final修饰的类）。 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。 类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）。 字节码验证，第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型做完校验后，这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件，例如： 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似 这样的情况：在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中。 保证跳转指令不会跳转到方法体以外的字节码指令上。 保证方法体中的类型转换是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的。 符号引用验证,最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生，符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，通常需要校验下列内容： 符号引用中通过字符串描述的全限定名是否能找到对应的类。 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。 符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问。 3.准备准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这个阶段中有两个容易产生混淆的概念需要强调一下，首先，这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。4.解析解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，符号引用是以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。直接引用则是指：可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。5.初始化类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码（或者说是字节码）。在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器()方法的过程。 [#](第17章 反射和注解.html#_17-3-通过反射获取类信息)17.3 通过反射获取类信息[#](第17章 反射和注解.html#_17-3-1-获取class对象)17.3.1 获取Class对象每个类被加载之后，系统就会为该类生成一个对应的Class对象，通过该Class对象就可以访问到JVM中的这个类。在Java程序中获得Class对象通常有如下3种方式。 使用Class类的forName(String clazzName)静态方法。该方法需要传入字符串参数，该字符串参数的值是某个类的全限定类名（必须添加完整包名）。 调用某个类的class属性来获取该类对应的Class对象。例如，Person.class将会返回Person类对应的Class对象。 调用某个对象的getClass()方法。该方法是java.lang.Object类中的一个方法，所以所有的Java对象都可以调用该方法，该方法将会返回该对象所属类对应的Class对象。 下面，通过示例来演示获取Class对象 [#](第17章 反射和注解.html#_17-3-2-获取构造器)17.3.2 获取构造器Class类提供了大量的实例方法来获取该Class对象所对应类的详细信息，下面4个方法用于获取Class对应类所包含的构造器。下面4个方法用于获取Class对应类所包含的构造器。 Connstructor getConstructor(Class&lt;?&gt;… parameterTypes)：返回此Class对象对应类的指定public构造器。 Constructor&lt;?&gt;[]getConstructors()：返回此Class对象对应类的所有public构造器。 Constructor getDeclaredConstructor(Class&lt;?&gt;…parameterTypes)：返回此Class对象对应类的指定构造器，与构造器的访问权限无关。 Constructor&lt;?&gt;[]getDeclaredConstructors()：返回此Class对象对应类的所有构造器，与构造器的访问权限无关。 下面通过示例演示获取构造器： 通过反射可以获取类中定义的构造方法，获取了构造方法就可以利用反射获取的构造方法来创建对象。通过反射来生成对象有如下两种方式。 使用Class对象的newInstance()方法来创建该Class对象对应类的实例，这种方式要求该 Class 对象的对应类有默认构造器，而执行 newInstance()方法时实际上是利用默认构造器来创建该类的实例。 先使用 Class 对象获取指定的 Constructor 对象，再调用 Constructor 对象的newInstance()方法来创建该Class对象对应类的实例。通过这种方式可以选择使用指定的构造器来创建实例。 下面通过示例来演示利用反射创建对象： [#](第17章 反射和注解.html#_17-3-2-获取类包含的方法)17.3.2 获取类包含的方法下面4个方法用于获取Class对应类所包含的方法。 Method getMethod(String name,Class&lt;?&gt;…parameterTypes)：返回此Class对象对应类的指定public方法。 Method[]getMethods()：返回此Class对象所表示的类的所有public方法。 Method getDeclaredMethod(String name,Class&lt;?&gt;…parameterTypes)：返回此Class对象对应类的指定方法，与方法的访问权限无关。 Method[] getDeclaredMethods()：返回此Class对象对应类的全部方法，与方法的访问权限无关。 运行后的结果是：每个Method对象对应一个方法，获得Method对象后，程序就可通过该Method来调用它对应的方法。在Method里包含一个invoke()方法，该方法的签名如下。 Object invoke(Object obj,Object…args)：该方法中的obj是执行该方法的主调，后面的args是执行该方法时传入该方法的实参。 [#](第17章 反射和注解.html#_17-3-3-获取类包含的field)17.3.3 获取类包含的Field Field getField(String name)：返回此Class对象对应类的指定public Field。 Field[]getFields()：返回此Class对象对应类的所有public Field。 Field getDeclaredField(String name)：返回此Class对象对应类的指定Field，与Field的访问权限无关。 Field[] getDeclaredFields()：返回此Class对象对应类的全部 Field，与Field的访问权限无关。 通过Class对象的getFields()或getField()方法可以获取该类所包括的全部Field或指定Field。Field提供了如下两组方法来读取或设置Field值。 getXxx(Object obj)：获取obj对象该Field的属性值。此处的Xxx对应8个基本类型，如果该属性的类型是引用类型，则取消get后面的Xxx。 setXxx(Object obj,Xxx val)：将obj对象的该Field设置成val值。此处的Xxx对应8个基本类型，如果该属性的类型是引用类型，则取消set后面的Xxx。 [#](第17章 反射和注解.html#_17-4-反射操作数组)17.4 反射操作数组在java.lang.reflect包下还提供了一个Array类，Array对象可以代表所有的数组。程序可以通过使用Array来动态地创建数组，操作数组元素等。Array提供了如下几类方法。 static Object newInstance(Class&lt;?&gt;componentType,int…length)：创建一个具有指定的元素类型、指定维度的新数组。 static xxx getXxx(Object array,int index)：返回array数组中第index个元素。其中xxx是各种基本数据类型，如果数组元素是引用类型，则该方法变为get(Object array,int index)。 static void setXxx(Object array,int index,xxx val)：将array数组中第index个元素的值设为val。其中xxx是各种基本数据类型，如果数组元素是引用类型，则该方法变成set(Object array,int index,Object val)。 下面程序示范了如何使用Array来生成数组，为指定数组元素赋值，并获取指定数组元素的方式： [#](第17章 反射和注解.html#_17-5-注解)17.5 注解Java 5开始，Java增加了元数据（MetaData）的支持，也就是Annotation（注解），注解可以理解为代码里的特殊标识，这些标识可以在编译、类加载、运行时被读取，并进行相应的处理。通过Annotation，开发者可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息。Annotation是一个特殊的接口，程序可以通过反射来获取指定程序元素的Annotation对象，然后通过Annotation对象来取得注释里的元数据。 [#](第17章 反射和注解.html#_17-5-1-基本annotation)17.5.1 基本AnnotationJava提供的4个基本Annotation的用法——使用Annotation时要在其前面增加@符号，并把该Annotation当成一个修饰符使用，用于修饰它支持的程序元素。4个基本的Annotation如下： @Override：用来指定方法重写的，它可以强制一个子类必须覆盖父类的方法。 @Deprecated：用于表示某个程序元素（类、方法等）已过时，当其他程序使用已过时的类、方法时，编译器将会给出警告。 @SuppressWarnings：指示被该Annotation修饰的程序元素（以及该程序元素中的所有子元素）取消显示指定的编译器警告。 @SafeVarargs：是Java 7专门为抑制“堆污染”警告提供的（了解）。 [#](第17章 反射和注解.html#_17-5-2-元注解)17.5.2 元注解JDK除了在java.lang下提供了4个基本的Annotation之外，还在java.lang.annotation包下提供了4个Meta Annotation（元Annotation），这4个元Annotation都用于修饰其他的Annotation定义。可以理解为在注解中使用的注解。 [#](第17章 反射和注解.html#_17-5-2-1-retention)17.5.2.1 @Retention@Retention只能用于修饰一个Annotation定义，用于指定被修饰的Annotation可以保留多长时间，@Retention包含一个RetentionPolicy类型的value成员变量，所以使用@Retention时必须为该value成员变量指定值。value成员变量的值只能是如下3个。 RetentionPolicy.CLASS：编译器将把Annotation记录在class文件中。当运行Java程序时，JVM不再保留Annotation。这是默认值。 RetentionPolicy.RUNTIME：编译器将把Annotation记录在class文件中。当运行Java程序时，JVM也会保留Annotation，程序可以通过反射获取该Annotation信息。 RetentionPolicy.SOURCE：Annotation只保留在源代码中，编译器直接丢弃这种Annotation。 如果需要通过反射获取注释信息，就需要使用value属性值为RetentionPolicy.RUNTIME的@Retention。使用@Retention元数据Annotation可采用如下代码为value指定值。 如果Annotation里只有一个value成员变量，使用该Annotation时可以直接在Annotation后的括号里指定value成员变量的值，无须使用name=value的形式。查看元注解@Rentention源码可以发现@Rentention注解中只有一个value属性： 因此在上例中的代码可以进行简写： [#](第17章 反射和注解.html#_17-5-2-2-target)17.5.2.2 @Target@Target也只能修饰一个Annotation定义，它用于指定被修饰的Annotation能用于修饰哪些程序单元。@Target元Annotation也包含一个名为value的成员变量，该成员变量的值只能是如下几个。 ElementType.ANNOTATION_TYPE：指定该策略的Annotation只能修饰Annotation。 ElementType.CONSTRUCTOR：指定该策略的Annotation只能修饰构造器。 ElementType.FIELD：指定该策略的Annotation只能修饰成员变量。 ElementType.LOCAL_VARIABLE：指定该策略的Annotation只能修饰局部变量。 ElementType.METHOD：指定该策略的Annotation只能修饰方法定义。 ElementType.PACKAGE：指定该策略的Annotation只能修饰包定义。 ElementType.PARAMETER：指定该策略的Annotation可以修饰参数。 ElementType.TYPE：指定该策略的Annotation可以修饰类、接口（包括注释类型）或枚举定义。 与使用@Retention类似的是，使用@Target也可以直接在括号里指定value值，而无须使用name=value的形式 [#](第17章 反射和注解.html#_17-5-2-3-documented)17.5.2.3 @Documented@Documented用于指定被该元Annotation修饰的Annotation类将被javadoc工具提取成文档，如果定义Annotation类时使用了@Documented修饰，则所有使用该Annotation修饰的程序元素的API文档中将会包含该Annotation说明。 [#](第17章 反射和注解.html#_17-5-2-4-inherited)17.5.2.4 @Inherited@Inherited元Annotation指定被它修饰的Annotation将具有继承性——如果某个类使用了@A Annotation（定义该Annotation时使用了@Inherited修饰）修饰，则其子类将自动被@A修饰。 [#](第17章 反射和注解.html#_17-5-3-自定义注解)17.5.3 自定义注解定义新的Annotation类型使用@interface关键字（在原有的interface关键字前增加@符号）定义一个新的Annotation类型与定义一个接口非常像，如下代码可定义一个简单的Annotation类型。 定义了该Annotation之后，因为没有指定@Rentention，因此就可以在程序的任何地方使用该Annotation。在默认情况下，Annotation可用于修饰任何程序元素，包括类、接口、方法等。Annotation不仅可以是这种简单的Annotation，还可以带成员变量，Annotation的成员变量在Annotation定义中以无形参的方法形式来声明，其方法名和返回值定义了该成员变量的名字和类型。如下代码可以定义一个有成员变量的Annotation。 一旦在Annotation里定义了成员变量之后，使用该Annotation时就应该为该Annotation的成员变量指定值，如下代码所示。 也可以在定义Annotation的成员变量时为其指定初始值（默认值），指定成员变量的初始值可使用default关键字。如下代码定义了@MyAnno Annotation，该Annotation里包含了两个成员变量：name和age，这两个成员变量使用default指定了初始值。 如果为Annotation的成员变量指定了默认值，使用该Annotation时则可以不为这些成员变量指定值，而是直接使用默认值。 [#](第17章 反射和注解.html#_17-5-4-获取annotation的信息)17.5.4 获取Annotation的信息当开发者使用Annotation修饰了类、方法、Field等成员之后，这些Annotation不会自己生效，必须由开发者提供相应的工具来提取并处理Annotation信息。Java使用Annotation接口来代表程序元素前面的注释，该接口是所有Annotation类型的父接口。Java 5在java.lang.reflect包下新增了AnnotatedElement接口，该接口代表程序中可以接受注释的程序元素。该接口主要有如下几个实现类。 Class：类定义。 Constructor：构造器定义。 Field：类的成员变量定义。 Method：类的方法定义。 Package：类的包定义。 AnnotatedElement接口是所有程序元素（如Class、Method、Constructor等）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象（如Class、Method、Constructor等）之后，程序就可以调用该对象的如下3个方法来访问Annotation信息。 getAnnotation(ClassannotationClass)：返回该程序元素上存在的指定类型的注释，如果该类型的注释不存在，则返回null。 Annotation[]getAnnotations()：返回该程序元素上存在的所有注释。 boolean isAnnotationPresent(Class&lt; ? extendsAnnotation&gt;annotationClass)：判断该程序元素上是否存在指定类型的注释，如果存在则返回true，否则返回false。 [#](第17章 反射和注解.html#_17-4-5-4-1-获取注解)17.4.5.4.1 获取注解在下面的示例中，结合自定义注解，获取Class上的注解 "},{"title":"IO流","date":"2022-08-10T12:03:41.000Z","url":"/2022/08/10/xianTrain21-IOStream/","categories":[["XiAnTrain - java高级篇","/categories/XiAnTrain-java%E9%AB%98%E7%BA%A7%E7%AF%87/"]],"content":"***&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Java基础学习打卡第2天 在日常的开发中，经常会遇到对本地文件进行操作的功能，例如将数据库中的数据导出成Excel并保存在本地，或者将本地的文本文件读入程序中，再或者在本地新建目录删除目录等等。这些都需要对本地文件进行读写。Java为开发者提供了File类用于操作本地的文件，File类是java.io包下代表与平台无关的文件和目录，也就是说，如果希望在程序中操作文件和目录，都可以通过File类来完成。值得指出的是，不管是文件还是目录都是使用File来操作的，File能新建、删除、重命名文件和目录，File不能访问文件内容本身。如果需要访问文件内容本身，则需要使用输入/输出流。 14.1 访问文件和目录File类可以使用文件路径字符串来创建File实例，该文件路径字符串既可以是绝对路径，也可以是相对路径。一旦创建了File对象后，就可以调用File对象的方法来访问，File类提供了很多方法来操作文件和目录，下面列出一些比较常用的方法。 14.1.1访问文件名方法 描述String getName() 返回File对象的文件名或者路径名String getPath() 返回File对象对应的路径名File getAbsoluteFile() 返回File对象的绝对路径String getAbsolutePath() 返回File对象的绝对路径名String getParent() 返回File对象的父目录boolean renameTo(File newName) 重命名文件下面通过示例来学习以上方法的使用： 运行后的结果为： 14.1.2 文件检测相关方法方法 描述boolean exists() 判断File对象所对应的文件或目录是否存在boolean canWrite() 判断文件和目录是否可写boolean canRead() 判断文件和目录是否可读boolean isFile() 判断是否是文件boolean isDirectory() 判断是否是目录boolean isAbsolute() 判断是否是绝对路径boolean isHidden() 判断文件是否隐藏下面通过示例来学习以上方法的使用： 14.1.2 获取文件信息方法 描述long lastModified() 最后一次修改时间，返回值为修改时间的毫秒数long lenght() 获取文件长度，单位为字节下面通过示例来学习以上方法的使用： 运行后的结果为：14.1.3 目录操作方法 描述boolean mkdir() 创建新目录boolean mkdirs() 创建多层目录String[] list() 列出File对象子文件名和路径名，返回String数组File[] listFiles() 列出File对象的索引子文件和路径static File[] listRoots() 获取系统根路径boolean delete() 删除文件或者路径，如果有多层路径，调用1次只删除最后一层目录，并且目录必须为空下面通过示例来学习以上方法的使用： 14.1.4 获取分区大小方法 描述long getTotalSpace() 获取分区大小long getFreeSpace() 获取分区空闲大小long getUsableSpace() 获取分区可用大小package cn.bytecollege.IODemo; 运行后的结果为： 14.2 Java中的I/O流Java中I/O流是实现输入/输出的基础，可以方便的实现输入和输出操作，Java中把不同的输入/输出源抽象表述为“流”，通过流的方式运行Java程序使用相同的方式来访问不同的输入/输出源，这里的流可以理解为字节序列，通俗一点说就是一串0和1。 14.2.1 流的分类流的分类可以从以下两个角度划分： 流向：按照流的流向来分可以分为输入流和输出流，其中输入流只能从中读取数据，而不能向其写入数据；输出流只能向其写入数据，而不能从中读取数据。读取单元：按照读取单元划分，流可以分为字节流和字符流，顾名思义所谓字节流就是输入和输出的基本单位都是字节，而字符流输入输出的基本单元都是字符。上面提到的输入和输出都涉及到方向的问题，这里的输入和输出都是从程序运行所在的内存角度划分的，也就是说从硬盘或者网络读取到程序运行内存中的流叫做输入流，反之从内存中写入硬盘的流则叫做输出流，换句话说，输入流和输出流都是以当前程序运行的内存作为参照物。Java中输入流主要使用InputStream和Reader作为基类，而输出流主要使用OutputStream和Writer作为基类，它们都是一些抽象类，无法直接创建实例。 14.2.2 流的概念模型Java把所有设备里的有序数据抽象成流模型，简化了输入/输出处理，理解了流的概念模型也就了解了Java IO。Java中有关IO流的类都是从如下4个抽象类中派生的。 InputStream/Reader：所有输入流的基类，前者是字节输入流，后者是字符输入流。OutputStream/Writer：所有输出流的基类，前者是字节输出流，后者是字符输出流。对于InputStream和Reader而言，它们把输入设备抽象成一个“水管”，这个水管里的每个“水滴”依次排列，如下图所示：字节流和字符流的处理方式其实非常相似，只是它们处理的输入/输出单位不同而已。输入流使用隐式的记录指针来表示当前正准备从哪个“水滴”开始读取，每当程序从InputStream或Reader里取出一个或多个“水滴”后，记录指针自动向后移动；除此之外，InputStream和Reader里都提供一些方法来控制记录指针的移动。对于OutputStream和Writer而言，它们同样把输出设备抽象成一个“水管”，只是这个水管里没有任何水滴。当执行输出时，程序相当于依次把“水滴”放入到输出流的水管中，输出流同样采用隐式的记录指针来标识当前水滴即将放入的位置，每当程序向OutputStream或Writer里输出一个或多个水滴后，记录指针自动向后移动。 14.2.3 字节流 14.2.3.1 InputStreamInputStream是输入流的基类，读取的最小单元是字节。由于InputStream是抽象类，所以其本身并不能创建实例来执行输入。但它们将成为所有输入流的模板，所以它们的方法是所有输入流都可使用的方法。InputStream里包含如下方法： int read()：从输入流中读取单个字节（相当于从如图所示的水管中取出一滴水），返回所读取的字节数据（字节数据可直接转换为int类型）。int read(byte[]b)：从输入流中最多读取b.length个字节的数据，并将其存储在字节数组b中，返回实际读取的字节数。int read(byte[]b,int off,int len)：从输入流中最多读取len个字节的数据，并将其存储在数组b中，放入数组b中时，并不是从数组起点开始，而是从off位置开始，返回实际读取的字节数。InputStream有个子类用于读取文件的输入流：FileInputStream，下面的程序将示范FileInputStream的使用。 运行后的结果为： 14.2.3.2 OutputStreamOutputStream是输出流的基类，输入的最小单元是字节。它提供了如下方法： void write(int c)：将指定的字节输出到输出流中，其中c既可以代表字节，也可以代表字符。void write(byte[] buf)：将字节数组中的数据输出到指定输出流中。void write(byte[] buf,int off,int len)：将字节数组中从off位置开始，长度为len的字节/字符输出到输出流中。同样OutputStream也有子类用于输入文件流：FileOutputStream，下面的程序将示范FileOutputStream的使用。 接下来，同时使用输入流和输出流来复制文件。 使用Java的IO流执行输出时，不要忘记关闭输出流，关闭输出流除了可以保证流的物理资源被回收之外，可能还可以将输出流缓冲区中的数据flush到物理节点里（因为在执行close()方法之前，自动执行输出流的flush()方法） 14.2.4 字符流 14.2.4.1 Reader在Reader里包含如下3个方法： int read()：从输入流中读取单个字符（相当于如图所示的水管中取出一滴水），返回所读取的字符数据（字符数据可直接转换为int类型）。int read(char[]cbuf)：从输入流中最多读取cbuf.length个字符的数据，并将其存储在字符数组cbuf中，返回实际读取的字符数。int read(char[]cbuf,int off,int len)：从输入流中最多读取len个字符的数据，并将其存储在字符数组cbuf中，放入数组cbuf中时，并不是从数组起点开始，而是从off位置开始，返回实际读取的字符数。对比InputStream和Reader所提供的方法，就不难发现这两个基类的功能基本是一样的，只是InputStream读取的最小单位是字节，而Reader读取的最小单位是字符。Reader也有一个子类FileReader用于实现字符的读取，下面通过示例来学习FileReader的用法： 14.2.4.2 WriterWriter抽象类中的方法和OutputStream方法类似，只需要将方法参数中的byte[]更换成char[]即可，字符流直接以字符作为操作单位，所以Writer可以用字符串来代替字符数组，即以String对象作为参数。Writer里还包含如下两个方法。 void write(String str)：将str字符串里包含的字符输出到指定输出流中。void write(String str,int off,int len)：将str字符串里从off位置开始，长度为len的字符输出到指定输出流中。同样Writer也有一个子类FileWriter用于实现字符的输出，下面通过示例来学习Writer的子类FileWirter的用法。 14.3 对象序列化对象序列化的目标是将对象保存到磁盘中，或允许在网络中直接传输对象。对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，通过网络将这种二进制流传输到另一个网络节点。其他程序一旦获得了这种二进制流（无论是从磁盘中获取的，还是通过网络获取的），都可以将这种二进制流恢复成原来的Java对象。序列化机制允许将实现序列化的Java对象转换成字节序列，这些字节序列可以保存在磁盘上，或通过网络传输，以备以后重新恢复成原来的对象。序列化机制使得对象可以脱离程序的运行而独立存在。对象的序列化（Serialize）指将一个Java对象写入IO流中，与此对应的是，对象的反序列化（Deserialize）则指从IO流中恢复该Java对象。如果需要让某个对象支持序列化机制，则必须让它的类是可序列化的（继承serializable接口，该接口是一个标记接口，实现该接口无须实现任何方法，它只是表明该类的实例是可序列化的）使用Serializable来实现序列化非常简单，主要让目标类实现Serializable标记接口即可，无须实现任何方法。一旦某个类实现了Serializable接口，该类的对象就是可序列化的，程序可以通过如下两个步骤来序列化该对象。 创建一个ObjectOutputStream调用ObjectOutputStream对象的writeObject()方法输出可序列化对象下面通过示例来学了对象的序列化和反序列化： 注意：1.如果修改类是仅修改了方法，则反序列化不受任何影响。不需要修改serialVersionUID的值2.如果修改类时仅仅修改了静态变量或者transient实例变量，则反序列化不受任何影响。不需要修改serialVersionUID的值。3.如果修改类时修改了非瞬时的实例变量，则可能导致序列化版本不兼容。如果对象流中的对象和新类中包含同名的实例变量，而实例变量类型不同，则反序列化失败，类定义应该更新serialVersionUID类变量的值。如果对象流中的对象比新类中包含更多的实例变量，则多出的实例变量值被忽略，序列化版本可以兼容，类定义可以不更新serialVersionUID的值。如果新类比对象流中的对象包含更多的实例变量，则序列化版本也可以兼容，类定义可以不更新serialVersionUID的值。但反序列化的对的新对象中多出的实例变量值都是null。"},{"title":"线程","date":"2022-08-10T12:03:41.000Z","url":"/2022/08/10/xianTrain22-Thread/","categories":[["XiAnTrain - java高级篇","/categories/XiAnTrain-java%E9%AB%98%E7%BA%A7%E7%AF%87/"]],"content":"&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Java基础学习打卡第2天 1 、线程和进程1.1、定义进程是资源分配的基本单位，具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。 线程是进程的一个实体，是独立运行和独立调度的基本单位（CPU上真正运行的是线程）。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。 1.2、区别 进程是资源分配的基本单位，线程是程序执行的基本单位 进程拥有自己的资源空间，每启动一个进程，系统就会为它分配地址空间；而线程与CPU资源分配无关，多个线程共享同一进程内的资源，使用相同的地址空间。 一个进程可以有多个线程 非官方版当一个程序进入内存运行时，就会变成一个进程。进程是处于运行过程中的程序，并且具有一定的独立功能，进程是系统进行资源分配和调节的独立单位。 线程是进程中必不可少的一部分，一个进程可以有多个线程，线程可以拥有自己的堆栈，自己的程序计数器和自己的局部变量，并且与父进程中的其他线程共享系统资源 1.2 并行和并发并行指在同一时刻，有多条指令在多个处理器上同时执行。例如打印机，多台打印机多人同时打印。 并发指在同一时刻只能由一条指令执行，但多个线程指令被快速轮换执行，时刻在宏观上具有多个进程同时执行的效果。例如打印机，一台打印机多人轮换打印。 注：单CPU时代多线程编程是没有太大意义的，并且线程间频繁的上下文切换还会带来额外开销 1.3 线程的创建和启动java使用Thread类代表线程，所有的线程对象都必须是Thread类或其子类的实例 1.3.1 继承Thread类通过继承Tread类来船舰并启动多线程的步骤如下： 定义Thread类的子类，并重写该类的run（）方法，该run（）方法的方法题就代表线程需要完成的任务。即run（）方法称之为线程执行体。 创建Thread子类实例，即创建线程对象。 调用线程对象的start（）方法来启动该线程。 演示实例如下： 也可以使用lamda表达式进行创建并启动多线程： 1.3.1.1 Thread底层实现 构造器 构造器 方法描述 public Thread() 无参构造器，用于创建一个线程 public Thread(Runnable target) 传入一个Runnable接口的子类对象，创建线程 public Thread(Runnable target,String name) 传入Runnable接口的子类对象，创建线程，并指定线程的名称 实例方法 方法 方法描述 public State getState() 获取线程的状态 public final native boolean isAlive(); 获取线程存活状态，线程在start()之后，终止之前，该方法会返回true，否则返回false public final void setDaemon(boolean on) 设置一个线程为守护线程，该方法在调用start()之前调用，否则会抛出异常 public final void setPriority(int newPriority) 设置线程的优先级，总共有10个优先级1-10 public final int getPriority() 获取线程的优先级 public final String getName() 获取线程的名字，如果没有为线程执行名称，则由JVM生成 public final synchronized void setName(String name) 为线程设置名称，不能为null public final void join() throws InterruptedException ———-合并线程，如果在A线程中调用B线程join()方法，则A线程进入WAITING状态，知道B线程执行结束，A线程进入RUNNABLE状态 public final synchronized void join(long millis) 如果在线程A中调用线程B.join(loing millis)，则A线程最多等待线程B执行millis毫秒。其后交替执行 public final synchronized void join(long millis,long nanos) 如果在线程A中调用线程B.join，则A线程最多等待线程B执行millis++毫秒。其后交替执行 类方法 方法 方法描述 public static native void sleep(long millis) throws InterruptedException 线程休眠millis毫秒，休眠过后转入到Runnable状态，当线程进入休眠后，线程处于TIMED_WAITING状态 public static void sleep(long millis, int nanos) 同上 public static native void yield(); 暂停正在执行的线程，线程调度器重新调度在就绪队列中的线程，优先级高的线程获得执行的概率较大，也有可能刚才正在执行的线程被重新执行。 缺点：因为java中类是单继承的，继承了Thread类，就无法继承其他父类，不利于代码扩展。 1.3.2 实现Runnable接口实现Runnable接口来创建并启动多线程的步骤如下： 定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。 创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。 调用线程对象的start()方法来启动该线程。 示例如下： 注：在启动线程时，MyThread并没有start（）方法，所以使用了Thread的构造方法，将线程t传入并启动了线程，此处启动的并不是线程thread，而是线程t。 缺点： 因为Runnable接口中没有start()方法，因此启动线程时，必须将继承了Runnable接口的类的对象通过Thread类的构造进行包装，然后调用Thread的start()方法启动线程。 run()方法不能抛出异常，如果run（）方法中代码抛出异常，程序只能中断，不能通过try..catch进行异常。 run()方法没有返回值。 1.3.3 使用Callable和Future创建线程Callable接口提供了一个call方法可以作为线程执行体，但call()方法比run()方法功能强大。其call()方法可以有返回值和声明抛出异常。call()方法并不是直接调用，它是作为线程执行体被调用的。 Callable接口是Java 5新增的接口，而且它不是Runnable接口的子接口，所以Callable对象不能直接作为Thread的target。 java 5提供了Future接口来代表Callable接口里call()方法的返回值，并为Future接口提供了一个FutureTask实现类，该实现类实现了Future接口，并实现了Runnable接口——可以作为Thread类的target。 创建并启动有返回值的线程的步骤如下： 创建Callable接口的实现类，并实现call方法，该call方法将作为线程执行体，且该call方法有返回值 创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象分装了该Callable对象的call（）方法的返回值 使用FutureTask对象作为Thread对象的target创建并启动新线程。 调用FutureTask对象的get（）方法来获得子线程执行结束的放回值。 继承Callable接口，并实现call()方法 创建FutureTask对象，包装Callable的子类对象 创建Thread类的对象，包装FutureTask对象 调用Thread#start()方法启动线程 调用FutureTask#get()方法获取call()方法的返回值 演示实例如下： 底层实现如下所示：Callable接口 Future接口 1.4 线程的生命周期线程的生命周期就是线程从创建到运行结束的整个过程状态。 在线程的生命周期中，它要经过新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）和死亡（Dead）五种状态。 15.2.1 新建和就绪状态当程序使用 new 关键字创建了一个线程之后，该线程就处于新建状态，此时它和其他的Java对象一样，仅仅由Java虚拟机为其分配内存，并初始化其成员变量的值。此时的线程对象没有表现出任何线程的动态特征，程序也不会执行线程的线程执行体。当线程对象调用了start()方法之后，该线程处于就绪状态，Java虚拟机会为其创建方法调用栈和程序计数器，处于这个状态中的线程并没有开始运行，只是表示该线程可以运行了。至于该线程何时开始运行，取决于JVM里线程调度器的调度。线程的调度目前主要分为两种：分时调度和抢占式调度。 分时调度：系统平均分配CPU时间片，所有线程轮流占用CPU，也就是说在时间片调度的分配上所有线程“人人平等”。 抢占式调度：系统按照线程优先级分配CPU时间片。优先级高的线程优先分配CPU时间片，如果所有就绪线程的优先级相同，那么会随机选择一个，优先级高的线程获取的CPU时间片相对多一些。 由于目前大部分操作系统都是使用抢占式调度模型进行线程调度，Java的线程管理和调度是委托给操作系统完成的，与之相对应，Java的线程调度也是使用抢占式调度模型。 启动线程使用 start()方法，而不是 run()方法！永远不要调用线程对象的run()方法！调用start()方法来启动线程，系统会把该run()方法当成线程执行体来处理；但如果直接调用线程对象的run()方法，则run()方法立即就会被执行，而且在 run()方法返回之前其他线程无法并发执行——也就是说，系统把线程对象当成一个普通对象，而run()方法也是一个普通方法，而不是线程执行体。 运行上面的程序可以看出当thread线程创建对象后，此时打印线程为新建状态（NEW）,当启动线程，线程已经程开始运行时在代码第6行打印了运行状态（RUNNABLE） 只能对处于新建状态的线程调用 start()方法，否则将引发IllegalThreadStateException异常。也就是说当线程调用过start()方法后再不能重复调用，否则将引发异常。 15.2.2 运行和阻塞状态如果处于就绪状态的线程获得了CPU，开始执行run()方法的线程执行体，则该线程处于运行状态，如果计算机只有一个 CPU，那么在任何时刻只有一个线程处于运行状态。当然，在一个多处理器的机器上，将会有多个线程并行（注意是并行：parallel）执行；当线程数大于处理器数时，依然会存在多个线程在同一个CPU上轮换的现象。当一个线程开始运行后，它不可能一直处于运行状态（除非它的线程执行体足够短，瞬间就执行结束了），线程在运行过程中需要被中断，目的是使其他线程获得执行的机会，线程调度的细节取决于底层平台所采用的策略。对于采用抢占式策略的系统而言，系统会给每个可执行的线程一个小时间段来处理任务；当该时间段用完后，系统就会剥夺该线程所占用的资源，让其他线程获得执行的机会。在选择下一个线程时，系统会考虑线程的优先级。当发生如下情况时，线程将会进入阻塞状态。 线程调用sleep()方法主动放弃所占用的处理器资源。 线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞。 线程试图获得一个同步监视器，但该同步监视器正被其他线程所持有。关于同步监视器的知识、后面将有更深入的介绍。 线程在等待某个通知（notify）。 当前正在执行的线程被阻塞之后，其他线程就可以获得执行的机会。被阻塞的线程会在合适的时候重新进入就绪状态，注意是就绪状态而不是运行状态。也就是说，被阻塞线程的阻塞解除后，必须重新等待线程调度器再次调度它。针对上面几种情况，当发生如下特定的情况时可以解除上面的阻塞，让该线程重新进入就绪状态。 调用sleep()方法的线程经过了指定时间。 线程调用的阻塞式IO方法已经返回。 线程成功地获得了试图取得的同步监视器。 线程正在等待某个通知时，其他线程发出了一个通知。 下图显示了线程状态转换图。下面通过示例来演示程序进入阻塞状态： 运行上面的程序发现启动线程后，线程一直处于阻塞状态，这是因为在代码第9行程序一直在等待着用户的输入。 [#](第15章 多线程基础.html#_15-2-3-线程死亡)15.2.3 线程死亡线程会以如下3种方式结束，结束后就处于死亡状态。 run()或call()方法执行完成，线程正常结束。 线程抛出一个未捕获的 Exception或Error。 直接调用该线程的stop()方法来结束该线程——该方法容易导致死锁，通常不推荐使用。 当主线程结束时，其他线程不受任何影响，并不会随之结束。一旦子线程启动起来后，它就拥有和主线程相同的地位，它不会受主线程的影响。为了测试某个线程是否已经死亡，可以调用线程对象的isAlive()方法，当线程处于就绪、运行、阻塞3种状态时，该方法将返回true；当线程处于新建、死亡2种状态时，该方法将返回false。下面通过程序来演示该状态： 在上面的程序中代码第12行启动了thread线程，启动该线程后让主线程休眠3s，给予thread线程充分的执行时间，当主线程休眠结束后，再次获取thread线程的状态，发现发现打印了TERMINATED。运行结果如下： 不要对处于死亡状态的线程调用start()方法，程序只能对新建状态的线程调用start()方法，对新建状态的线程两次调用start()方法也是错误的。这都会引发IllegalThreadState Exception异常 1.3 控制线程1.3.1 Join当某个程序在执行流中调用其他线程的join()方法时，调用线程将被阻塞，直到被join()方法加入的线程执行结束。 注意：当T2线程执行过程中被T1线程Join，线程T1执行时，T2处于WAITING 1.3.2 Join(long millis)当某个程序在执行流中调用其他线程的join(long millis)方法时，调用线程将被限时阻塞，直到等待millis毫秒之后此线程和其他线程交替执行。 注意：当T2线程执行过程中被T1线程Join，线程T1执行时，T2处于TIME_WAITING 1.3.3 守护线程有一种线程，他是在后台运行的，它的任务是为其他的线程提供服务，这种线程被称为“后台线程（Daemon Thread）”，又称为守护线程。 调用Thread对象的setDaemon(true)方法可将指定线程设置为后台线程。 注意：如果所有的前台线程都死亡，后台线程会自动死亡。当父线程为后台线程则子线程也为后台线程 可以通过isDaemon()方法判断线程是否是守护线程。 注意： 守护线程必须在启动前将其守护状态设置为true，启动之后崩再将用户线程设置为守护线程，否则JVM会抛出一个InterruptedException异常。 守护线程存在被JVM强行终止的风险，所以i在守护线程中尽量不去访问系统资源，如数据库连接。 守护线程创建的线程也是守护线程，在创建之后，如果通过调用setDaemon(false)将新的线程显示的设置为用户线程，新的线程可以调整为用户线程。 1.3.4 线程休眠1.3.4.1 sleep()sleep()方法是一个类方法，不需要使用对象调用（通过对象调用该方法，是无法达到让线程休眠的效果）。 注意：让哪个线程休眠，就在哪个线程中调用sleep()方法。 static void sleep(long millis)：让当前正在执行的线程暂停millis毫秒，并进入阻塞状态，该方法受到系统计时器和线程调度器的精度与准确度的影响。 static void sleep(long millis,int nanos)：让当前正在执行的线程暂停millis毫秒加nanos毫微秒，并进入阻塞状态，该方法受到系统计时器和线程调度器的精度与准确度的影响。 示例 反面示例 注意：代码第18行，并不会让t1线程休眠，而是让主线程休眠了5秒钟。 线程在休眠的过程中调用interrupt()方法，会抛出异常 1.3.4.2 LockSupport类LockSupport是JUC提供的一个线程阻塞与唤醒的工具类，该工具类可以让线程在任意位置橘色和唤醒，其所有的方法都是静态方法。 底层实现方法： 示例 当调用park()方法时，会让线程进入WAITING状态，调用parkNanos(long nanos)方法时，线程会进入TIMED_WAITING状态 【重要】LockSort.park和Thread.sleep()的区别： Thread.sleep()无法从外部唤醒，只能自己醒过来；而被LockSupport.park()方法阻塞的线程可以通过调用LockSupport.unpark()方法去唤醒； Thread.sleep()方法声明了InterruptedException中断异常，这是一个受检异常，调用者需要捕获这个异常或者再抛出；而调用LockSupport.park()方法时不需要捕获中断异常。 被LockSupport.park()方法、Thread.sleep()方法所阻塞的线程有一个特点，当被阻塞时，线程的Thread.interrupt()方法被调用，被阻塞线程的中断标志将被设置，该线程将被唤醒。不同的是，二者对中断信号的响应方式不同：LockSupport.park()方法不会抛出InterruptedException异常，仅仅设置了线程的终端标志；而Thread.sleep()方法会抛出InterruptedException异常。 与Thread.sleep()相比，调用LockSupport.park（）能更精准，更加灵活的阻塞、唤醒指定线程。 醒示例如下： 注意：通过LockSupport.park（）方法进入阻塞的线程和通过Thread.sleep()进入阻塞的线程一样，都不会释放锁。 1.3.4.3 yield() 线程让步暂停正在执行的线程，线程调度器重新调度在就绪队列中的线程，优先级高的线程获得执行的概率较大，也有可能刚才正在执行的线程被重新执行。 sleep()方法和yield()方法的区别： sleep()方法暂停当前线程后，会给其他线程执行机会，不会理会其他线程的优先级；但yield()方法会给优先级相同，或优先级更高的线程执行机会。 sleep()方法会将线程转入阻塞状态，直到经过阻塞时间才会转入就绪状态；而yield()不会将线程转入阻塞状态，它只是强制当前线程进入就绪状态。因此完全有可能某个线程调用yield()方法暂停之后，立即再次获得处理器资源被执行。 sleep()方法声明抛出了 InterruptedException 异常，所以调用 sleep()方法时要么捕捉该异常，要么显式声明抛出该异常；而yield()方法则没有声明抛出任何异常。 1.3.5 线程优先级线程的优先级并不能绝对线程的执行顺序，也就是说优先级高的线程并不一定优先执行，只是线程优先级高的线程获得CPU时间片的概率更大一些。 示例 线程优先级具有继承性，也就是说在某个线程中创建的线程，其优先级和父线程相同。 示例 1.3.6 线程的停止线程停止有2种办法 stop()：该方法已被废弃，我们是不能随便中断一个线程的，我们无法知道这个线程正运行在什么状态，它可能持有某把锁，强行中断线程可能导致锁不能释放的问题；或者线程可能在操作数据库，强行中断线程可能导致数据不一致的问题。正是由于调用stop()方法来终止线程可能会产生不可预料的结果，因此不推荐调用stop()方法。 异常中断法 【次重要】interrupt()和interrupted()的区别 interrupt()是实例方法，用于为正在运行的线程添加中断标记，当线程正在运行时，该方法并不会影响线程的运行。如果线程被Object.wait()、Thread.join()和Thread.sleep()三种方法之一阻塞，此时线程处于WAITING或者TIMED_WAITING状态时，调用该方法时，线程会抛出中断异常。 interrupted()是类方法，用于检测线程是否有中断标记，如果线程有中断标记，调用该方法时会清除标记，清除标记后再次调用该方法会返回false，除非再次为线程添加中断标记 1.4 jMM模型JMM（Java Memory Model）：Java 内存模型，是 Java 虚拟机规范中所定义的一种内存模型，Java 内存模型是标准化的，屏蔽掉了底层不同计算机的区别。也就是说，JMM 是 JVM 中定义的一种并发编程的底层模型机制。 。下： 所有的共享变量都存储于主内存。这里所说的变量指的是实例变量和类变量，不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。 每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。 线程对变量的所有的操作（读，写）都必须在工作内存中完成，而不能直接读写主内存中的变量。 不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存中转来完成。 总结： 每个线程都有自己的私有内存（工作内存） 线程对共享变量的操作只能在私有内存中进行，操作完成后写入到主内存中 共享比那里都存储在主内存中。 特性：1.原子性原子性是指，一个或者多个操作不可分割，要么全部执行，并且执行过程中不会被任何因素打断，要么就都不执行。Java中可以使用synchronized保证原子性。 [#](第15章 多线程基础.html#_2-可见性)2.可见性可见性是指当一个线程修改了某一个共享变量的值时，其他线程是否能够立即知道这个修改。Java中的volatile、synchronized、Lock都能保证可见性。如一个变量被volatile修饰后，表示当一个线程修改共享变量后，其会立即被更新到主内存中，其他线程读取共享变量时，会直接从主内存中读取。而synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。 [#](第15章 多线程基础.html#_3-有序性)3.有序性对于一个线程的执行代码而言，我们总是习惯性地认为代码是从前往后依次执行的。这么理解也不能说完全错误，因为就一个线程内而言，确实会表现成这样。但是，在并发时，程序的执行可能就会出现乱序。给人的直观感觉就是：写在前面的代码，会在后面执行。听起来有些不可思议，有序性问题的原因是程序在执行时，可能会进行指令重排，重排后的指令与原指令的顺序未必一致。 在单核CPU的场景下，当指令被重排序之后，如何保障运行的正确性呢？其实很简单，编译器和CPU都需要遵守As-if-Serial规则。As-if-Serial规则的具体内容为：无论如何重排序，都必须保证代码在单线程下运行正确。为了遵守As-if-Serial规则，编译器和CPU不会对存在数据依赖关系的操作进行重排序，因为这种重排序会改变执行结果。但是，如果指令之间不存在数据依赖关系，这些指令可能被编译器和CPU重排序。下面是一段非常简单的示例代码： 在示例代码中，③和①之间存在数据依赖关系，同时③和②之间也存在数据依赖关系。因此，在最终执行的指令序列中，③不能被重排序到①和②的前面，因为③排到①和②的前面，程序的结果将会被改变。但①和②之间没有数据依赖关系，编译器和CPU可以重排序①和②之间的执行顺序。虽然编译器和CPU遵守了As-if-Serial规则，无论如何，也只能在单CPU执行的情况下保证结果正确。在多核CPU并发执行的场景下，由于CPU的一个内核无法清晰分辨其他内核上指令序列中的数据依赖关系，因此可能出现乱序执行，从而导致程序运行结果错误。因此As-if-Serial规则只能保障单内核指令重排序之后的执行结果正确，不能保障多内核以及跨CPU指令重排序之后的执行结果正确。 synchronizedsynchronize是一个修饰符，表示同步的意思，可以修饰方法，也可以修饰代码块。修饰的方法叫做同步方法，修饰的代码块叫做同步代码块，被synchronized修饰的方法或则代码，也叫做临界区，临界区的特点在同一时刻有且只能又一个现场访问。 时刻 线程A 线程B T1 抢锁，且成功 就绪 T2 读变量i 就绪 T3 修改变量i 就绪 T4 时间片到 运行 T5 就绪 抢锁，但是抢不到（处于阻塞状态），直到时间片结束 T6 获得时间片，继续执行，写入主内存 就绪 T7 退出临界区，并释放锁 抢锁，且成功 如果多个线程分别持有自己的锁，则加锁没有意义： 证明线程处于休眠状态时，不会释放锁。 证明多个线程持有同一把锁时，如果A线程持有锁，则B线程处于BLOCKED状态。 synchronized修饰类方法时，锁时当前类对象即类名.class，当synchronized修饰实例方法时，锁时当前对象即this。 修饰类方法示例 修饰实例方法示例 运行上面的示例,发现结果并不同步,这是因为两个线程分别将当前对象当做锁,也就不存在锁竞争,因此在临界区也不会存在互斥性 【重要】synchronized实现原理主要有两个重要的指令monitorenter和monitorexit monitorenter指令时会尝试获取相应对象的monitor，获取规则如下： 如果monitor的进入数为0，则该线程可以进入monitor，并将monitor进入数设置为1，该线程即为monitor的拥有者。 如果当前线程已经拥有该monitor，只是重新进入，则进入monitor的进入数加1，所以synchronized关键字实现的锁是可重入的锁。 如果monitor已被其他线程拥有，则当前线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor。 monitorexit只有拥有相应对象的monitor的线程才能执行monitorexit指令。每执行一次该指令monitor进入数减1，当进入数为0时当前线程释放monitor，此时其他阻塞的线程将可以尝试获取该monitor。 【重要】synchronized的内存语义 进入synchronized内存语义是把在synchronized块内使用到的变量从线程的工作内存中清除，这样在synchronized块内使用到该变量时就不会从线程的工作内存中获取，而是直接从主内存中获取。 退出synchronized块的内存语义是把在synchronized块内对共享变量的修改刷新到主内存。 其实这也是加锁和释放锁的语义，当获取锁后会清空锁块内本地内存中将会被用到的共享变量，在使用这些共享变量时从主内存进行加载，在释放锁时将本地内存中修改的共享变量刷新到主 内存。除可以解决共享变量内存可见性问题外，synchronized经常被用来实现原子性操作。 死锁产生死锁的条件 互斥条件：指线程对已经获取到的资源进行排它性使用，即该资源同时只由一个线程占用。如果此时还有其他线程请求获取该资源，则请求者只能等待，直至占有资源的线程释放该资源。 请求并持有条件：指一个线程已经持有了至少一个资源，但又提出了新的资源请求，而新资源已被其他线程占有，所以当前线程会被阻塞，但阻塞的同时并不释放自己已经获取的资源。 不可剥夺条件：指线程获取到的资源在自己使用完之前不能被其他线程抢占，只有在自己使用完毕后才由自己释放该资源。 环路等待条件：指在发生死锁时，必然存在一个线程—资源的环形链，即线程集合{T0, T1, T2, …, Tn}中的T0正在等待一个T1占用的资源，T1正在等待T2占用的资源，……Tn正在等待已被T0占用的资源。 死锁示例 死锁诊断 jps -l :打印出正在运行的Java进程ID jstack pid 同步锁 示例 lock() 上面的示例中，t1线程获得锁后，并没有释放锁，t2线程会一直阻塞。 tryLock() tryLock()方法的特点是，如果锁可用则获取，如果锁不可用则立即返回false，上面的实例中，如果删除22行代码，并不会影响t2线程的执行。 注意：使用lock()方法加锁后，一定要使用unlock()方法解锁，通常unlock()方法放置在finally中，此外同一线程中，unlock()方法调用前，必须要调用lock()方法，否则会抛出异常 lockInterruptibly()示例 在上面的示例中，t1线程在获得锁以后，并没有释放做，因此t2线程会一直处于阻塞状态，此时调用interrupt()方法，中断获取锁的过程 lockInterruptibly会抛出InterruptedException。 学习心得：这两天学习多线程这块相对于前面的内容比较难理解，王哥很明显放慢了讲课速度，学起来轻松多了。今天太热了，到下午这会都快热的学不动了，不过在我的坚强的意志，端正学习态度，和在Byte公司无限的关怀，和细心的照料之下还是挺过来了。"},{"title":"异常","date":"2022-08-10T12:00:10.000Z","url":"/2022/08/10/xianTrain20-Exception/","categories":[["XiAnTrain - java高级篇","/categories/XiAnTrain-java%E9%AB%98%E7%BA%A7%E7%AF%87/"]],"content":"***&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Java基础学习打卡第2天 如果看一门编程语言是否健壮，那么是否提供异常处理机制就是很重要的判断标准之一，除了传统的C语言以外，目前主流的编程语言都提供了成熟的异常机制，例如C#，Python等。异常机制可以使程序中的异常处理代码和业务代码分离，保证程序更加的优雅，提高程序的健壮性。Java 的异常机制主要依赖干 try、catch、finally、throw 和 throws 五个关键字，其中 try 关键字后紧跟一个花括号扩起来的代码块（花括号不可省略），简称 try 块，它里面放置可能引发异常的代码。catch后对应异常类型和一个代码块，用于表明该 catch 块用于处理这种类型的代码块。多个 catch 块后还可以跟一个 finally 块，finally 块用于回收在 try 块里打开的物理资源，异常机制会保证 finally 块总被执行。 throws 关键字主要在方法签名中使用，用于声明该方法可能抛出的异常；而 throw 用于抛出—个实际的异常，throw 可以单独作为语句使用，抛出一个具体的异常对象 。Java 7 进一步增强了异常处理机制的功能，包括带资源的 try 语句、捕获多异常的 catch 两个新功能，这两个功能可以极好地简化异常处理。 开发者希望所有的错误都能在编译阶段被发现，就是在试图运行程序之前排除所有错误，但这是不现实的，余下的问题必须在运行期间得到解决。Java将异常分为两种，Checked 异常和 Runtime 异常， Java 认为 Checked 异常都是可以在编译阶段被处理的异常，所以它强制程序运行前处理所有的 Checked 异常；而 Runtime 异常则无须处理。 13.1 异常类的继承体系Java提供了丰富的异常类，这些类有着严格的继承关系，如下图：从图示中可以看出，Java把所有的非正常情况分为两大类：异常（Exception）和错误（Error），他们都是Throwable的子类。 Error：和虚拟机有关的问题，如系统崩溃、虚拟机错误等，这些错误无法恢复或者不可能被抓取，将导致应用程序中断，应用程序通常无法处理这些错误，因此不应该用异常处理方法来处理Error。同样，也不能在throws字句中声明该方法可能抛出Error。Exception：程序中出现的非正常情况，其中异常又分为两类，RuntimeException（运行时异常）和CheckedException（检查时异常），这两类异常都是Exception的子类，其中RuntimeException及其子类不需要开发者显示处理。如果一个Exception没有继承RuntimeException类，则属于CheckedException，这类异常通常需要开发者显示处理。否则会出现编译错误。下面，先通过示例来演示运行时异常和检查时异常的区别 在上面的示例中，定义了Student类以及两个实例方法：其中say()方法抛出了一个ArithmeticException，因为ArithmeticException继承了RuntimeException，所以它是一个运行时异常，因此，在上述代码第25行调用该方法时，即使没有显式的处理该异常，程序也不会出现编译错误。hello()方法抛出了ClassNotFoundException，ClassNotFoundException没有继承RuntimeException，因此是一个检查时异常，而检查时异常需要开发者显式处理，如果不处理，则会出现编译错误。 13.2 异常处理机制对于计算机程序而言，没有人能保证自己写的程序永远不会出错！就算程序没有错误，你能保证用户总是按你的意愿来输入? 就算用户都是非常”聪明而且配合”的，你能保证运行该程序的操作系统永远稳定？你能保证运行该程序的硬件不会突然坏掉？你能保证网络永远通畅？对于一个程序设计人员，需要尽可能地预知所有可能发生的情况，尽可能地保证程序在所有糟糕的情形下都可以运行。也就是说要时时刻刻考虑程序的健壮性。Java 的异常处理机制可以让程序具有极好的容错性，让程序更加健壮。当程序运行出现意外情形时，系统会自动生成一个 Exception 对象来通知程序，从而实现将”业务功能实现代码”和”错误处理代码”分离，提供更好的可读性。 13.2.1 try…catch捕获异常正如前面示例中编写的代码，在代码28行如果不做任何处理，将会出现编译错误，代码也就无法执行。为了解决这个问题，可以使用try…catch捕获异常，并对异常进行处理，如果执行try语句块中的代码出现异常，系统会自动生成一个异常对象，该对象被提交给Java运行时环境，这个过程被称为throw（抛出）异常。当Java运行时环境受到异常对象时，会寻找对应处理该异常对象的catch块，如果找到合适的catch块，则把该异常对象交给catch块处理，这个过程叫做catch（捕获）异常；如果Java运行时环境找不到捕获异常的catch块，则运行时环境终止，Java程序也将退出。下面将演示上例中代码中异常的处理方式： 从上面的程序可以看出，将第9行可能抛出异常的代码放入了try语句块中，当这一行代码发生异常时，就会到后续的catch语句块中寻找与之对应的异常，如果找到则进入catch语句块中继续执行。避免了程序的中断。接下来，通过示例来学习当代码发生异常时如果catch中有对应的异常和没有对应的异常时发生的情况。 在上面的程序中，使用了反射获取Student中的name变量，因为在Student中并没有定义name变量，所有当代码运行至第9行时，一定会发生NoSuchFieldException，并且在try后的catch中就存在与之对应的异常处理语句。程序将进入对应的catch语句块中，并向下执行。运行结果如下图所示：image.png如果程序发生异常时在catch语句中没有找到对应的异常，那么程序将终止运行，通过下面的示例来演示这种情况。 image.png 13.2.2 Java 7提供的多异常捕获在Java 7以前，每个catch块只能捕获一种类型的异常；但是从Java 7开始，一个catch块可以捕获多种类型的异常。使用catch块捕获多种类型异常时需要注意以下两点： 捕获多种类型异常时，多种异常类型之间使用 | 隔开捕获多种类型异常时，异常变量有隐式的final修饰，因此程序不能对异常变量重新赋值我们重构上一小节的程序： 通过重构代码可以发现在一个catch中捕获了NoSuchFieldException和SecurityException两个异常，在代码12行重新对e赋值发现编译出错，这是因为变量e是使用隐式的final修饰的，final修饰的变量初始化后不能被重新赋值。所以会编译错误。 13.2.2 使用finally回收资源在开发中经常会打开一些资源，例如数据库连接，网络连接和磁盘文件等，这些资源在打开后都必须要显式回收。并且这些资源必须要进行回收，否则会持续占用内存资源。而且不会释放。为了保证资源一定能被回收，异常处理机制提供了finally块，不管try块中的代码是否出现异常，也不管哪个catch语句块被执行，甚至在try块或者catch块中执行了return语句，finally中的代码总会被执行。其语法结构如下： 异常处理语法结构中只有 try 块是必需的，也就是说，如果没有 try 块，则不能有后面的 catch 块和 finally 块；catch 块和 finally 块都是可选的，但 catch 块和 finally 块至少出现其中之一，也可以同时出现;可以有多个 catch 块，捕获父类异常的 catch 块必须位于捕获子类异常的后面；但不能只有 try 块，既没有 catch 块，也没有 finally 块；多个 catch 块必须位于 try 块之后，finally 块必须位于所有的 catch块之后。并且finally语句块不能单独出现，只能和try…catch搭配使用。下面，通过示例来了解finally的作用： 在上面的程序中第10行因为用整数除0，所以会抛出ArithmeticException，在try后的catch语句块中可以捕获该异常，并执行catch中的代码，catch后还有finally语句块，finally语句块的特点是不管是否会抛出异常，finally中的语句都会执行，所以程序结果运行如下图：image.png修改上例中的代码，即使try语句块中的代码不抛出异常，finally中的代码也会执行。 上面的代码中try语句块中被不会抛出异常，所以代码不会进入catch语句块中，但是仍然会进入finally语句块中并执行代码，结果如下图：image.png除此以外Java还提供了增强版的try-with-resource语法，这节内容将在下一章中详细讲解。 13.2 使用throws声明抛出异常throws用于方法头中抛出异常，当定义一个方法并且该方法不知道如何处理这种类型的异常时，该异常交由调用者处理；如果main方法也不知道如何处理这种类型的异常，也可以使用throws声明抛出异常，该异常将交有JVM处理。JVM对异常的处理方法是，打印异常的跟踪栈信息，并终止程序的运行。throws声明抛出异常只能在方法签名中使用，throws可以声明抛出一个异常类，多个异常类之间用逗号隔开。语法格式如下： throws Exception1,Exception2…如果某段代码中调用了一个带throws声明的方法，该方法抛出了Checked异常，则表明该方法要求调用者来处理该异常。也就是说方法的调用者要么在try语句块中显示捕获该异常，要么放在另一个带throws声明抛出的方法中。下面的示例将演示这种用法。 上面的程序中定义了Teacher类，在Teacher中定义了say()方法，并且该方法在方法头中使用throws抛出了ClassCastException，SQLException，在main方法中创建了Teacher对象t，并调用了say方法，因为ClassNotFoundException，SQLException都是Checked异常，所以调用say方法时，必须显示的处理这两个异常，在上例中使用了try…catch对异常进行了处理。当然也可以在调用say方法代码所在的方法头继续使用throws抛出异常，但是由于say方法是在main方法中调用的，也就是说如果继续throws异常的话，会抛给虚拟机，但是并不建议将异常抛给虚拟机。下面的程序将演示这种情况 上面的程序中第8行say方法抛出了异常，但是并没有处理，而是直接向上抛出，因为say方法是在main方法中调用的，如果继续抛出异常，main方法只能将异常抛给虚拟机。 13.3 使用throw抛出异常当程序出现错误时，系统会自动抛出异常；除此之外，Java也允许程序自行抛出异常，自行抛出异常使用throw语句来完成（注意此处的throw没有后面的s，与前面声明抛出的throws是有区别的）。 13.3.1 抛出异常很多时候，系统是否要抛出异常，可能需要根据应用的业务需求来决定，如果程序中的数据、执行与既定的业务需求不符，这就是一种异常。由于与业务需求不符合产生的异常，必须由程序员来决定抛出，系统无法抛出这种异常。如果需要在程序中自行抛出异常，则应使用throw语句，throw语句可以单独使用，throw语句抛出的不是异常类，而是一个异常实例，而且每次只能抛出一个异常实例。throw语句的语法格式如下： throw ExceptionInstance;在开发中登录是常见的业务，当用户输入用户名和密码后，开发者需要对用户名进行校验其合法性，例如长度符合规定，如果不符合规定，就可以抛出一个异常。下面的程序将演示throw的用法： 上面的程序中，在valid方法中，如果用户输入的用户名长度小于6或者大于12就使用throw在方法内抛出异常，也就是说当用户名长度小于6或者大于12程序认定这是异常。当Java运行时接收到用户自行抛出的异常时，同样会中止当前的执行流，跳到该异常对应的catch块，由该catch块来处理该异常。也就是说，不管是系统自动抛出的异常，还是程序员手动抛出的异常，Java运行时环境对异常的处理没有任何差别。如果throw语句抛出的异常是Checked异常，则该throw语句要么处于try块里，显式捕获该异常，要么放在一个带throws声明抛出的方法中，即把该异常交给该方法的调用者处理；如果throw语句抛出的异常是Runtime异常，则该语句无须放在try块里，也无须放在带throws声明抛出的方法中；程序既可以显式使用try…catch来捕获并处理该异常，也可以完全不理会该异常，把该异常交给该方法调用者处理。例如下面例子程序。 在上面的程序中修改了valid方法，当用户输入的用户名长度不合法时，使用throw抛出了一个Checked异常，因此在方法头上需要使用throws声明抛出异常（当然，也可以在valid方法中使用try…catch处理，但是这么做没有意义，相当于自己的异常自己处理了，那么调用者也不清楚输入的数据是否合法）。当该方法抛出Checked异常后，也要求方法的调用者显示的处理，所以在main方法中显示了处理了异常。 13.4 自定义异常类在上一小节学习了如何使用throw在方法内抛出异常，但是在程序开发选择抛出异常时，应该选择合适的异常类，从而可以明确地描述该异常情况。在这种情形下，应用程序常常需要抛出自定义异常。用户自定义异常都应该继承Exception基类，如果希望自定义Runtime异常，则应该继承RuntimeException基类。定义异常类时通常需要提供两个构造器：一个是无参数的构造器；另一个是带一个字符串参数的构造器，这个字符串将作为该异常对象的描述信息（也就是异常对象的getMessage()方法的返回值）。例如上一小节的示例，直接使用了RuntimeException或者Exception，这样并不能很清晰的描述异常信息，因此，可以自定义一个异常，专门描述校验用户名过程中发生的异常。 上面程序创建了AuctionException异常类，并为该异常类提供了两个构造器。尤其是第11行代码部分创建的带一个字符串参数的构造器，其执行体也非常简单，仅通过super来调用父类的构造器，正是这行super调用可以将此字符串参数传给异常对象的message属性，该message属性就是该异常对象的详细描述信息。如果需要自定义Runtime异常，只需将AuctionException.java程序中的Exception基类改为RuntimeException基类，其他地方无须修改。 13.4.1 异常转义前面介绍的异常处理方式有如下两种。 在出现异常的方法内捕获并处理异常，该方法的调用者将不能再次捕获该异常。该方法签名中声明抛出该异常，将该异常完全交给方法调用者处理。在实际应用中往往需要更复杂的处理方式——当一个异常出现时，单靠某个方法无法完全处理该异常，必须由几个方法协作才可完全处理该异常。也就是说，在异常出现的当前方法中，程序只对异常进行部分处理，还有些处理需要在该方法的调用者中才能完成，所以应该再次抛出异常，让该方法的调用者也能捕获到异常。为了实现这种通过多个方法协作处理同一个异常的情形，可以在catch块中结合throw语句来完成。如下例子程序示范了这种catch和throw同时使用的方法。 13.5 访问异常信息如果程序需要在 catch 块中访问异常对象的相关信息，则可以通过访问 catch 块的后异常形参来获得。当 Java运行时决定调用某个 catch 块来处理该异常对象时，会将异常对象赋给 catch 块后的异常参数，程序即可通过该参数来获得异常的相关信息。 所有的异常对象都包含了如下几个常用方法。 getMessage()∶ 返回该异常的详细描述字符串。printStackTrace()∶将该异常的跟踪栈信息输出到标准错误输出。getStackTrace()∶ 返回该异常的跟踪栈信息。下面例子程序演示了程序如何访问异常信息。 上面程序调用了 Exception 对象的 getMessage（）方法来得到异常对象的详细信息，也使用了 printStackTrace（）方法来打印该异常的跟踪信息。运行上面程序，会看到下图所示的界面。image.png 13.6 异常链对于真实的企业级应用而言，常常有严格的分层关系，层与层之间有非常清晰的划分，上层功能的实现严格依赖于下层的API，也不会跨层访问。把底层的原始异常直接传给用户是一种不负责任的表现。通常的做法是：程序先捕获原始异常，然后逐级向上抛出，直到某一层将该异常进行处理。下面的程序将演示这种情况： "},{"title":"泛型","date":"2022-08-10T11:56:35.000Z","url":"/2022/08/10/xianTrain19-genericParadigm/","categories":[["XiAnTrain - java高级篇","/categories/XiAnTrain-java%E9%AB%98%E7%BA%A7%E7%AF%87/"]],"content":"***&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Java基础学习打卡第2天 在集合框架的内容中，对泛型已经有了初步的了解。泛型是JDK 1.5中新增的特性，在集合框架中使用，某种程度上是为了让集合记住其保存的元素的类型。在泛型产生之前，集合中存入一个元素，集合并不知道存入元素的数据类型，集合会把所有对象全部当做Object类型处理。当从集合中取出元素以后，就需要对元素进行向下转型，这样很容易引发ClassCastException异常。当Java新增了泛型支持以后，集合就可以记住所添加元素的数据类型。并且在编译时可以检查被添加元素的数据类型，当试图添加和泛型规定的类型不一致的元素时会发生编译错误。本章内将介绍泛型类、泛型接口、以及类型通配符、泛型方法等内容。 12.1 泛型入门在集合框架的内容中可以得知，集合中只能保存引用类型的数据，换句话说集合中只能保存对象。但是当把一个对象添加进集合时，集合并不确定被添加元素的类型，这是因为集合的设计者并不确定开发者会在集合中添加何种类型的元素，因此，设计者将所有的对象都当做Object对象处理，但是这么做会带来如下两个问题： 集合对添加元素的类型没有限制，当存放时不会出现问题，但是在获取元素时，就有可能引发转型异常，例如一个集合中只能保存Student类型的对象，因为集合并不会对元素的类型进行检查，因此即使添加一个Teacher对象也不会出现问题。但是当取出元素时，将Object类型向下转型时，Teacher类型的对象转型时就会发生异常当把对象放进集合时，集合会认为添加的类型都是Object类型的对象。取出时通常需要向下转型，这样无形中增加了编程的复杂度。12.1.1 泛型JDK5以后，Java引入了泛型，即“参数化类型”。允许程序在创建集合时指定集合元素的类型（允许程序在创建对象或者调用方法时动态的指定）。例如：List中只能添加Integer类型的对象，如果试图添加一个字符串时，将会发生编译错误。也就是说Java中参数化类型被称为泛型。 在上例中，创建了一个List集合，并且该List中只能保存Integer类型的对象（在List后增加了尖括号，在括号内放了Integer类型，此时这个尖括号连同里面的Integer类型表明此List只能存放Integer类型的对象）。在代码第13行试图在List中添加一个字符串，此时将发生编译错误。 12.1.2 菱形语法在Java 7以前，如果使用带泛型的接口、类定义变量，那么调用构造器创建对象时构造器后面也必须带泛型，例如下面的语句： List list = new ArrayList();在Java 7以前必须要这么书写，但是从Java 7以后，Java允许构造器后不需要带完整的泛型信息，只需要给出一对尖括号即可，Java编译器可以自动推断出尖括号中是什么数据类型。因此，上面的代码可以进行简化： List list = new ArrayList&lt;&gt;();当将尖括号内的数据类型省略后，两个尖括号合并在一起很像是一个“菱形”，因此这种语法也被称为“菱形”语法。目的就是为了简化代码。 12.2 深入泛型所谓泛型，就是允许在定义类、接口、方法时使用类型形参，这个类型形参将在声明变量、创建对象、调用方法时动态地指定（即传入实际的类型参数，也可称为类型实参）。Java 5 改写了集合框架中的全部接口和类，为这些接口、类增加了泛型支持，从而可以在声明集合变量、创建集合对象时传入类型实参，这就是在前面程序中看到的 List 12.2.1 泛型类和泛型接口下面是List接口的代码片段： List的接口声明比较简单，尖括号中的内容就是泛型的实质：允许在定义接口、类时声明类型形参，类型形参在整个接口、类中当成类型使用，几乎所有可使用普通类型的地方都可以使用这种类型形参。例如使用List时，如果E形参传入String类型，则该List只能存放String类型的数据。在开发中可以为任何类、接口增加泛型声明。下面定义一个自定义泛型Student类。 上例中定义了一个带泛型声明的Student类，使用Student类是就可以为T类型传入实际类型。定义泛型接口的方法和泛型类的方法类似，只需要在接口名后添加即可。 12.3 泛型通配符当使用一个泛型类型时（包括声明变量和创建对象两种情况），都应该为这个泛型类传入一个类型实参，如果没有传入类型实际参数，编译器就会提出泛型警告。例如如下示例： 上面的代码中创建了一个ArrayList()集合，代码没有任何问题，但是由于List是一个有泛型声明的接口，此处使用List接口时没有传入实际类型参数，这将引起泛型警告。因此，要为List接口传入实际的类型参数——因为List集合里的元素类型是不确定的。修改上述代码： Java中可以使用类型通配符，类型通配符是一个问号（?）,将一个问号做为实际类型传给List集合，写作：List&lt;?&gt;，意思是元素类型未知的List。它的元素类型可以匹配任何类型。修改上例代码： 但这种带通配符的List仅表示它是各种泛型List的父类，并不能把元素加入到其中，上例中第4行就会发生编译错误，因为程序无法确定集合中元素的类型，所以不能向其中添加对象。查看List接口源码可以发现，add()方法有参数类型E作为集合的元素类型，所以传给add的参数必须是E类对象或者其子类的对象，但是在上例中不知道E是什么类型，所以无法将任何对象添加进集合。 12.3.1 通配符上限如果想让上例中的代码正常工作，就需要学习通配符的上下限，也就是说我们得给定统配符的上限或者下限，本小节内，将介绍通配符上限的内容。Java 泛型不仅允许在使用通配符形参时设定上限，而且可以在定义类型形参时设定上限，用于表示传给该类型形参的实际类型要么是该上限类型，要么是该上限类型的子类。下面程序示范了这种用法。所谓通配符的上限就是规定泛型通配符在传入化类型时只能是某个类本身或者其子类。下面通过示例来学习： 在上例中定义了一个泛型类，并且设置了泛型的上限Number，也就是说，当创建Teacher对象指定泛型类型时，只能传入Number类型或者Number类型的子类，在测试类中，分别传入了Number类型，Integer类型和Double类型，因为这些类型都是Number类型的子类，但是当传入String类型时，因为String并不是Number类型的子类，所以第9行代码会出现编译错误。所以设置通配符上限的目的就是限定参数化类型的传入值，只能是限定类型或者限定类型的子类。 12.4 泛型方法前面介绍了在定义类、接口时可以使用类型形参，在该类的方法定义和成员变量定义、接口的方法定义中，这些类型形参可被当成普通类型来用。在另外一些情况下，定义类、接口时没有使用类型形参，但定义方法时想自己定义类型形参，这也是可以的，Java 5 还提供了对泛型方法的支持。 12.4.1 定义泛型方法所谓泛型方法就是在声明方法时定义一个或多个类型形参，泛型方法的语法格式如下： 修饰符 返回值类型 方法名(形参列表){ //方法体}下面通过实例学习泛型方法的定义。 在上面的程序中第8行定义了一个泛型方法，并且指定了say()方法的参数和返回值都是指定的参数化类型，在main()方法中调用say()方法时，由于传入了一个String类型的参数，因此该方法的返回值类型也是指定的String类型，如果在第13行中将say的方法参数修改为整型，那么这个方法的返回值类型也会变成Integer类型，此时再使用String类型的变量接收返回值就会编译出错。需要着重注意的是，在类和接口中定义的泛型，泛型的作用域是在当前类中，而方法中定义的泛型其作用域只是在当前方法。 12.4.2 通配符下限在上一节中学习了通配符的上限，同样也可以规定，通配符的下限。一旦规定了通配符下限，则只能传入指定类型的父类。在TreeSet的构造方法中就是用了通配符下限。 在上面的程序中就是用了通配符的下限，也就是说在使用该构造方法时，?所能传入的类型只能是E的父类，而E的类型则是在创建TreeSet对象时指定的对象。请看下面的示例。 通过上面的代码可以看出Comparator接口中定义了泛型下限，下限是创建TreeSet时规定了泛型是String类型，因此Comparator接口中的泛型只能是String或者其父类，如果修改为Integer类型，则会编译出错。 12.5 泛型擦除在严格的泛型代码里，带泛型声明的类总应该带着类型参数。但为了与老的 Java 代码保持—致，也允许在使用带泛型声明的类时不指定实际的类型参数。如果没有为这个泛型类指定实际的类型参数，则该类型参数被称作 raw type（原始类型），默认是声明该类型参数时指定的第一个上限类型。 当把一个具有泛型信息的对象赋给另一个没有泛型信息的变量时，所有在尖括号之间的类型信息都将被扔掉。比如一个 List类型被转换为 List，则该 List 对集合元素的类型检查变成了类型参数的上限（即 Object）。下面程序示范了这种擦除。 上面的程序中定义了一个泛型类，并且泛型规定了上限，只能是CharSequence的子类 在测试类中创建了Bird类的对象b，并且制定了泛型为String类型，将b赋值给不带泛型的对象b2，此时编译器就会丢失b对象的泛型信息，即所有尖括号中的信息都会丢失。在代码11行，调用getType()方法时，此时编译器只知道该方法的返回值是CharSequence，但是具体是哪个子类就不清楚了，所以出现编译错误。"},{"title":"HeahMap","date":"2022-08-03T09:37:09.000Z","url":"/2022/08/03/xianTrain18-HeahMap/","categories":[["XiAnTrain -java初级篇","/categories/XiAnTrain-java%E5%88%9D%E7%BA%A7%E7%AF%87/"]],"content":"***&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Java基础学习打卡第2天 1.1 Map概述Map用于保存具有映射关系的数据，因此Map集合里保存着两组值，一组用于保存Map里的key，另外一组用于保存Map里的value，key和value都可以是任何引用类型的数据。Map的key不允许重复，即同一个Map对象的任何两个key通过equals方法比较总是返回false。key和value之间存在单向一对一的关系，即通过指定的key，总能找到唯一的、确定的value。从Map中取出数据时，只要给出指定的key，就可以取出对应的value.Map的实现类有HashMap、Hashtable、Properties、SortedMap等等。 1.2 HashMap1.2.1 HashMap常用API方法 描述 下面，通过示例学习HashMap的方法： 1.2.2 HashMap存放元素流程HashMap元素存放是一个相对是复杂的过程，整个过程涉及到的有哈希表扩容，红黑树和链表的相互转换等过程，在本小节从源码查看整个过程。在学习HashMap存放元素之前需要对HashMap中的几个关键成员变量进行了解。 HashMap添加元素会调用put(K key,V value)方法，从源码可以看出在put()方法内部调用了putVal()方法。 putVal(hash(key), key, value, false, true); hash(key)：位置 key:输入的键 value：输入的值 第4个参数 onlyIfAbsent 表示只有当对应 key 的位置为空的时候替换元素，一般传 false，在 JDK1.8中新增方法 public V putIfAbsent(K key, V value) 传 true 第 5 个参数 evict 如果是 false。那么表示是在初始化时调用的:获取hash值： 注：Integer类型的hashcode值为本身。返回值没有65536； 继续查看putVal()方法，这个方法即HashMap存放元素的核心流程。 哈希冲突：两个不相等的元素在hash表中的位置相同。 解决hash冲突的办法： 拉链法 开放寻址1.2.3 HashMap扩容流程在上一小节中我们了解了HashMap添加元素的详细流程，在HashMap添加元素的过程中涉及到一个很重要的操作，那就是扩容。因为如果在HashMap内添加元素，当HashMap内部数组无法装载更多元素时，就需要扩大数组长度，以便放入更多元素，由于Java中数组是无法自动扩容的，这就需要创建一个新的数组替代已有的数组，在本小节内将详细了解HashMap的扩容机制。 纵观整个代码HashMap扩容时会存在以下几种情况： 调用无参构造器时，实例化的HashMap底层数组是null，当第一次调用put()方法时进行扩容，初始容量为16。 调用有参构造指定了容量和负载因子时，会根据指定的正整数找到不小于指定容量的2的次幂，将这个数赋值给扩容阈值（threshold），当第一次put()方法时，会将阈值赋值给容量，并计算新的阈值=容量x负载因子。 如果不是第一次扩容，则容量变为原容量的2倍，阈值也变为原来的2倍。 get方法底层源码 remove方法底层源码 Java 7 和Java 8中HashMap的区别 Java7中HashMap数据结构采用了数组+链表，而Java8中采用了数组+链表+红黑树，当链表长度大于8并且容量大于64时，会将链表转换成红黑树（注意，如果此时如果链表长度已经是8，但是数组长度并没有到64时会先进行扩容）。当红黑树节点个数小于等于6时会退化成链表。 Java7中链表使用的是头插法，但是使用头插法在多线程环境下有概率出现环形链表死循环的问题，在Java8中链表采用了尾插法以及使用了红黑树，避免了出现链表死循环的问题。 1.2.4 HashMap的遍历方式HashMap的遍历在开发中属于必备技能，HashMap的遍历方式有很多种，但是总的来说只有三种： 获取keySet()后遍历keySet()获取到key然后通过key获取value获取entrySet()后遍历entrySet()，相比于第一种写法稍显复杂，但是能更好的体现Map中的数据结构使用Lambda表达式遍历，相比前两种是最简洁的方式，但是代码可读性略差在HashMap的遍历中，应该综合考虑性能、效率等因素做出合适的选择。下面通过实例学习HashMap的遍历。 1.2.5 HashMap和HashtableHashMap 和 Hashtable 都是 Map 接口的典型实现类，它们之间的关系完全类似于 ArrayList 和 Vector的关系∶ Hashtable 是一个古老的 Map 实现类，它从 JDK 1.0起就已经出现了，当它出现时，Java还没有提供Map 接口，所以它包含了两个烦琐的方法，即 elements() 类似于 Map接口定义的 values()方法）和 keys() 类似于 Map 接口定义的 keySet()方法。除此之外，Hashtable 和 HashMap 存在三点典型区别。 Hashtable 是一个线程安全的 Map接口实现，但 HashMap 是线程不安全的实现，所以 HashMap 比 Hashtable 的性能高一点;但如果有多个线程访问同一个 Map 对象时，使用 Hashtable 实现类会更好。 Hashtable 不允许使用 null 作为 key 和 value，如果试图把 null 值放进 Hashtable 中，将会引发 NullPointerException 异常; 但 HashMap 可以使用 null 作为 key 或 value。 HashMap数组初始长度为16，扩容后长度是原长度的2倍，Hashtable初始长度为11，扩容后的长度是原长度的2n+1 1.3 LinkedHashMapHashMap也有一个LinkedHashMap子类;LinkedHashMap 也使用双向链表来维护 key-value 对的次序（其实只需要考虑 key 的次序），该链表负责维护 Map 的迭代顺序，迭代顺序与 key-value 对的插入顺序保持一致。 LinkedHashMap 可以避免对 HashMap、Hashtable 里的 key-value 对进行排序（只要插入 key-value对时保持顺序即可），同时又可避免使用 TreeMap 所增加的成本（TreeMap的内容将会在下一小节学习）。 LinkedHashMap 需要维护元素的插入顺序，因此性能略低于 HashMap 的性能;但因为它以链表来维护内部顺序，所以在迭代访问 Map 里的全部元素时将有较好的性能，下面通过示例学习LinkedHashMap。 1.4 使用Properties读写文件Properties 类是 Hashtable 类的子类，该对象在处理属性文件时特别方便（Windows 操作平台上的 ini 文件就是一种属性文件）。Properties 类可以把 Map 对象和属性文件关联起来，从而可以把Map 对象中的 key-value 对写入属性文件中，也可以把属性文件中的”属性名=属性值”加载到 Map 对象中。由于属性文件里的属性名、属性值只能是字符串类型，所以 Properties 里的 key、 value 都是字符串类型。该类提供了如下三个方法来修改 Properties 里的 key、value 值。 String getProperty(String key)∶获取 Properties 中指定属性名对应的属性值，类似于 Map 的 get（Object key）方法。 String getProperty(String key，String defaultValue)∶该方法与前一个方法基本相似。该方法多一个功能，如果 Properties 中不存在指定的 key 时，则该方法指定默认值。 Object setProperty(String key， String value)∶设置属性值，类似于Hashtable 的 put() 方法。除此之外，它还提供了两个读写属性文件的方法。 void load(InputStream inStream)∶ 从属性文件（以输入流表示）中加载 key-value 对，把加载到的 key-value 对追加到 Properties 里（Properties 是 Hashtable 的子类，它不保证 key-value 对之间的次序）。 void store(OutputStream out， String comments)∶将 Properties 中的 key-value 对输出到指定的属性 文件（以输出流表示）中。 上面两个方法中使用了InputStream 类和 OutputStream 类，它们是 Java IO 体系中的两个基类，关于流的内容在后续章节讲解。下面通过示例先演示基本用法。 上面的示例分别演示了Properties读写配置文件，在JDBC中将会使用配置文件配置数据库连接信息。 1.5 SortedMap和TreeMapMap 接口也派生出一个 SortedMap 子接口，SortedMap 接口也有一个 TreeMap 实现类。 TreeMap 就是一个红黑树数据结构，每个 key-value 对即作为红黑树的一个节点。TreeMap 存储 key-value 对（节点）时，需要根据 key 对节点进行排序。TreeMap 可以保证所有的 key-value 对处于有序状态。TreeMap 也有两种排序方式。 自然排序∶TreeMap的所有key 必须实现 Comparable 接口，而且所有的 key 应该是同一个类的 对象，否则将会抛出 ClassCastException 异常。定制排序∶ 创建 TreeMap 时，传入一个 Comparator 对象，该对象负责对 TreeMap 中的所有key进行排序。采用定制排序时不要求 Map 的 key 实现 Comparable 接口。 类似于 TreeSet 中判断两个元素相等的标准，TreeMap 中判断两个 key 相等的标准是∶ 两个 key 通过 compareTo()方法返回 0，TreeMap 即认为这两个 key 是相等的。如果使用自定义类作为 TreeMap 的 key，且想让 TreeMap 良好地工作，则重写该类的 equals()方法和 compareTo（方法时应保持一致的返回结果∶ 两个 key 通过 equals()方法比较返回 true 时，它们通过 compareTo()方法比较应该返回 0。如果 equals()方法与 compareTo()方法的返回结果不一致， TreeMap与 Map 接口的规则就会冲突。TreeMap 中也提供了一系列根据 key 顺序访问 key-value 对的方法。 Map.Entry firstEntry()∶ 返回该 Map 中最小 key 所对应的 key-value 对，如果该Map为空，则返回 null。 Object firstKey()∶返回该 Map 中的最小 key值，如果该 Map为空，则返回 null。 Map.Entry lastEntry()∶ 返回该 Map 中最大 key 所对应的 key-value 对，如果该 Map为空或不存 在这样的 key-value 对，则都返回 null。 Object lastKey()∶ 返回该 Map 中的最大 key 值，如果该 Map 为空或不存在这样的 key，则都返回nulI。 Map.Entry higherEntry(Object key)∶ 返回该 Map 中位于key 后一位的 key-value 对（即大于指定 key 的最小 key 所对应的 key-value 对）。如果该 Map 为空，则返回 null。 Object higherKey(Object key)∶返回该 Map 中位于key 后一位的 key 值（即大于指定 key 的最小 key 值）。如果该 Map 为空或不存在这样的 key-value 对，则都返回 null。 Map.Entry lowerEntry(Object key)∶ 返回该 Map 中位于key 前一位的 key-value 对（即小于指定 key 的最大 key 所对应的 key-value 对）。如果该 Map 为空或不存在这样的 key-value 对，则都返回 null。 Object lowerKey(Object key)∶返回该Map 中位于key前一位的 key 值（即小于指定 key 的最大 key 值）。如果该 Map 为空或不存在这样的 key，则都返回 null。 1.6 各Map性能分析对于 Map 的常用实现类而言，虽然 HashMap 和 Hashtable 的实现机制几乎一样，但由于Hashtable是一个古老的、线程安全的集合，因此 HashMap 通常比 Hashtable 要快。 TreeMap 通常比 HashMap、Hashtable 要慢（尤其在插入、删除 key-value 对时更慢），因为 TreeMap底层采用红黑树来管理 key-value 对（红黑树的每个节点就是一个 key-value 对）。 使用 TreeMap 有一个好处∶ TreeMap 中的 key-value 对总是处于有序状态，无须专门进行排序操作。当 TreeMap 被填充之后，就可以调用 keySet() ，取得由key 组成的 Set，然后使用 toArray()方法生成 key的数组，接下来使用 Arrays 的 binarySearch() 方法在已排序的数组中快速地查询对象。 对于一般的应用场景，程序应该多考虑使用 HashMap，因为 HashMap 正是为快速查询设计的（HashMap 底层其实也是采用数组来存储 key-value 对）。但如果程序需要一个总是排好序的 Map 时，则可以考虑使用TreeMap。 LinkedHashMap 比 HashMap 慢一点，因为它需要维护链表来保持 Map中 key-value 时的添加顺序。 学习心得今天学习了heahmap添加元素put的底层实现。总体来说，不是很容易理解，在上课的时候听的是半懂，晚自习敲了几遍时得以掌握这块内容。今天又老了一岁，算起来今年都满十八了，果果也是。再次隆重地祝果果永远十八，永驻容颜、有成鱼落雁之容、闭月羞花之貌，赛过貂蝉，胜似西施，犹如洛神赋中髣髴兮若轻云之蔽月，飘飖兮若流风之回雪"},{"title":"学习心得[List和Queue]","date":"2022-07-29T11:33:02.000Z","url":"/2022/07/29/xianTrain17-ListAddQueue/","categories":[["XiAnTrain","/categories/XiAnTrain/"]],"content":"***&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Java基础学习打卡第2天 java集合体系概述 Java集合大致可以分为List、Set、Map和Queue，其中List代表有序、可重复的集合，Set代表无序、不可重复的集合，而Map则代表具有映射关系的集合。(最少也要记住绿色背景的接口和方法) collection接口和set类似无须、不重复。 1.1 ArrayListList集合代表一个元素有序、有索引、可重复的集合。ArrayList的底层就是用数组保存数据以及对数据操作的。ArrayList继承关系图以及主要方法： 通过继承关系图可以看出ArrayList的继承关系，下面先对各个接口进行解释：RandomAccess：随机访问接口，因为ArrayList底层使用数组实现，所以支持在允许范围内随机访问。Cloneable：克隆接口，说明ArrayList支持克隆Serializable：序列化接口，说明ArrayList支持序列化（关于序列化的内容，将会在Java高级中讲解）。List：接口，提供数组的添加、删除、修改、迭代遍历等操作。AbstractList：AbstractList 提供了 List 接口的骨架实现，大幅度的减少了实现迭代遍历相关操作的代码 1.1.1ArrayList常用API1.1.1.1 构造方法 public ArrayList(int initialCapacity) ：创建给定容量的ArrayList，initialCapacity的值不能小于0，不能大于Integer能表示的最大值 public ArrayList()：创建ArrayList对象，默认创建一个空数组。 public ArrayList(Collection&lt;? extends E&gt; c)：传入一个集合，以集合中元素为初始元素创建对象 注：从jdk1.7开始在初始化ArrayList的时候，默认值初始化为空数组,而在jdk1.2到jdk1.6,这个值始终都为10；创建Arrays时长度为0；在添加第一个元素时，ArrayList初始长度为10,扩容后新长度是原长度的1.5倍 1.1.1.2 常用API 方法 描述 add(Object o) 添加数据 add(int index,Object o) 在制定索引处添加元素 size() 获取元素个数 get(int index) 获取索引处的元素 isEmpty() 判断集合是否为空 indexOf(Object o) 判断某个元素第一次出现的位置 E remove(int index) 移除索引处元素，并返回该元素 boolean remove(Object o) 移除元素 clear() 清空元素 set(int index ,E e) 修改索引处的元素 iterator() 获取迭代器 trimToSize() 减少容量至当前元素个数 contains(Object o) 判断是否包含某个元素 lastIndexOf(Object o) 判断某个元素最后一次出现的位置 toArray() 将集合转换为数组 addAll(Collection&lt;? extends E&gt; c) 集合中添加集合 addAll(int index, Collection&lt;? extends E&gt; c) 索引处添加集合 retainAll(Collection c) 求两个集合的交集 removeAll(Collection&lt;?&gt; c) 移除传入集合内的元素 subList(int fromIndex, int toIndex) 获取子集合 1.1.1.3四种遍历方式 迭代器 有且只有一个抽象方法的接口称之为函数接口反射会破坏封装 1.2 ArrayList 基本操作底层源码1.2.1 ArrayList 初始化 1.2.2 ArrayList添加元素 1.2.3 ArrayList和Vector和ArrayList具有相同功能的类是Vector，Vector是Java早期提供的一个集合类，Vector和ArrayList的方法以及底层的实现基本相似，唯一不同的是Vector的方法都是线程安全的，打开Vector源码可以发现Vector的方法都是用synchronized修饰的（关于synchronized修饰符，会在多线程中讲解），因此Vector效率低于ArrayList。除此之外ArrayList和Vector的区别还体现在以下几个方面： ArrayList扩容后的长度是原长度的1.5倍，而Vector扩容后的长度是原长度的2倍 ArrayList调用无参构造方法创建对象时，会创建一个空的Object数组，当添加第一个元素时进行扩容，初始容量为10，当Vector调用无参构造创建对象时，则会直接初始化保存数据的数组，长度为10。 1.3 LinkedList通过上一小节的内容可以看出ArrayList底层实现主要依赖数组，而LinkedList底层实现则是依赖链表。并且LinkedList底层数据结构是双向链表 1.3.1 手动实现LinkedList定义链表数据节点： 第一步：LinkedList的实现是双向链表，因此需要定义首节点和尾结点。并且需要保存链表中元素的个数。此外，还需要提供无参构造方法，在构造方法内初始化一个空链表。 第二步：添加元素 第二步：定义删除元素方法 第三步：定义查找方法。 第四步：定义修改方法 1.3.2 ArrayList和LinkedList的区别ArrayList和LinkedList虽然都是List接口的子类，但是在底层实现以及效率上存在以下区别 ArrayList和LinkedList都实现了List接口 ArrayList和LinkedList都是非线程安全的，因此在多线程环境下可能会出现出现不同步的情况 ArrayList底层实现是数组，LinkedList底层实现是双向链表 ArrayList因为底层实现是数组，并且支持随机访问因此查找效率高，但是ArrayList在新增元素时会扩容以及复制数组元素，并且删除时也会进行数组复制，所以增删效率低。而LinkedList不支持随机访问，获取元素时必须从首节点开始从前往后遍历查找，因此查找效率低。但是增加和删除时最多涉及到两个节点的操作，因此增删效率高。 1.5 QueueQueue 用于模拟队列这种数据结构，队列通常是指”先进先出”（FIFO）的容器。新元素插入（offer）到队列的尾部，访问元素（poll）操作会返回队列头部的元素。通常，队列不允许随机访问队列中的元素。 boolean add(Object e)∶将指定元素加入此队列的尾部。 boolean offer(Object e)∶将指定元素加入此队列的尾部。当使用有容量限制的队列时，此方法通常比 add(Object e)方法更好。 Object element()∶获取队列头部的元素，但是不删除该元素。 Object peek()∶获取队列头部的元素，但是不删除该元素。如果此队列为空，则返回 null。 Object poll()∶获取队列头部的元素，并删除该元素。如果此队列为空，则返回 null。 Object remove()∶获取队列头部的元素，并删除该元素。 Queue 还有一个 Deque 接口，Deque 代表一个”双端队列”，双端队列可以同时从两端来添加、删除元素，因此 Deque 的实现类既可当成队列使用，也可当成栈使用。Java 为 Deque提供了ArrayDeque 和 LinkedList 两个实现类。 1.5.1 PriorityQueue实现类PriorityQueue保存队列元素的顺序并不是按照加入的顺序，在PriorityQueue内部会对元素的大小进行重新排序。因此，当调用peek()方法或者poll()方法取出队列中的元素时。并不是取出最先进入队列的元素，而是取出队列中最小的元素。 注：PriorityQueue不允许插入null元素，它还需要对队列元素进行排序， PriorityQueue的元素有两种排序方式： 自然排序：采用自然顺序的PriorityQueue队列中的元素必须实现Comparable接口，并且应该是同一个类的多个示例，否则可能导致转型异常 定制排序：创建PriorityQueue队列是，传入一个Comparator对象，该对象负责对队列中的所有元素进行排序。采用定制排序时不要求队列元素实现Comparator接口。 1.5.2 Deque接口与ArrayDequeDeque是Queue的子接口，它代表的了一个双端队列，Deque接口中定义了一些双端队列的方法，这些方法允许从队列两端来操作队列中的元素。 void addFirst(Object e)：将指定元素插入该双端队列的开头。 void addLast(Object e)：将指定元素插入该双端队列的末尾。 Iterator descendinglterator()：返回该双端队列对应的迭代器，该迭代器将以逆向顺序来迭代队列中的元素。 Object getFirst()：获取但不删除双端队列的第一个元素。 Object getLast()：获取但不删除双端队列的最后一个元素。 boolean offerFirst(Object e)：将指定元素插入该双端队列的开头。 boolean offerLast(Object e)：将指定元素插入该双端队列的末尾。 Object peekFirst()：获取但不删除该双端队列的第一个元素;如果此双端队列为空，则返回 null。 Object peekLast()：获取但不删除该双端队列的最后一个元素;如果此双端队列为空，则返回 null。 Object pollFirst()：获取并删除该双端队列的第一个元素;如果此双端队列为空，则返回 null。 Object pollLast()：获取并删除该双端队列的最后一个元素;如果此双端队列为空，则返回 null。 Object pop()(栈方法)：pop 出该双端队列所表示的栈的栈顶元素。相当于removeFirstO。 void push(Object e)(栈方法)：将一个元素 push 进该双端队列所表示的栈的栈顶。相当于addFirst(e)。 Object removeFirst()：获取并删除该双端队列的第一个元素。 Object removeFirstOccurrence(Object o)：删除该双端队列的第一次出现的元素 o。 Object removeLast()：获取并删除该双端队列的最后一个元素。 boolean removeLastOccurrence(Object o)：删除该双端队列的最后一次出现的元素o。 创建Deque时可以指定一个numElement参数，该参数用于指定Object[]数组的长度，如果不指定该参数，则ArrayDeque底层数组的默认长度为16。由于ArrayDeque既可以当做队列使用，又可以当做栈使用，下面的示例首先示范将ArrayDeque使用。 注：当程序中需要使用栈这种数据结构时，推荐使用ArrayDeque，尽量避免使用Stack，这是因为Stack是一个比较古老的集合，并且性能方面也不尽人意。 当然ArrayDeque也可以当做队列使用，ArrayDeque会按照“先进先出”的方式操作集合。 1.5.3 LinkedList实现类LinkedList类时List接口的实现类，也就是说LinkedList可以根据索引来随机访问放入其中的元素，除此以外LinkedList也可以被当做栈和队列使用。 学习心得 今天学习了ArrayList基层代码。之前只是直接拿过来引用，并未查看底层是怎么运行的。通过王哥对底层代码讲解得以了解ArrayList底层的从创建到销毁的整个过程。还讲解了vactor与ArrayList的区别，虽然vactor已经被淘汰，但让我掌握到新的知识点。"},{"title":"学习心得[String和常用类]","date":"2022-07-27T12:03:04.000Z","url":"/2022/07/27/xianTrain16-String/","categories":[["XiAnTrain","/categories/XiAnTrain/"]],"content":"***&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Java基础学习打卡第2天 1. 字符串1.1 StringString类是一个不可变类，不可变类即类中的成员变量都使用final修饰，这也就说明一个String对象被创建以后，包含在这里对象中的字符序列是不可改变的，直到整个对象被销毁。并且在Java中所有字符串相关的类都是Charsquence接口的子类。String类提供了大量的构造方法来创建String对象，先来看以下几个： String()：创建一个包含0个字符的String对象 String(byte[] bytes,Charset charset)：使用指定的字符集将指定的byte[]解码成一个新的String对象 String(String original)：根据字符串字面量来创建String对象。 String(StringBuffer buffer)：根据StringBuffer对象来创建String String(StringBuilder builder)：根据StringBuilder来创建对应的String对象。 下面，通过示例来学习以上构造方法： 除了以上创建字符串的方式，还可以通过字面量的方式创建字符串对象： 除此之外，String还提供了诸多API用来操作字符串。 方法名称 描述 equals(String string) 判断两个字符串是否相等 equalsIgnoreCase(String string) 忽略大小写判断两个字符串是否相等 length() 获取字符串长度 charAt(int index) 获取某个索引处的字符 indexOf(String string) 获取字符串第一次出现的位置 indexOf(String string,int startIndex) 从startIndex处查找第一次出现的位置 lastIndexOf(String string) 字符串最后一次出现的位置 startsWith(String string) 判断是否以string开始 endsWith(String string) 判断是否以string结尾 compareTo(String string) 比较字符串大小 toLowerCase() 字符串转小写 toUpperCase() 字符串转大写 subString(int index) 从index位置处截取到字符串末尾 subString(int startIndex,int endIndex) 从startIndex位置开始，到endIndex结束，前闭后开 trim() 去除字符串首尾空格 split(String string) 以string对字符串进行分割，此方法会省略末尾空字符 split(String string,int limit) 对字符串进行分割，此方法不会省略末尾空字符 join(String s,String…str) 以s为连接符，连接str内字符串 concat(String str) 连接字符串 valueOf() 基本类型转字符串 contains(String str) 判断是否包含str toCharArray() 将字符串转换成字符数组 intern() 判断字符串在常量池中是否存在，如果不存在，则复制，1.6是将实例复制，1.7及以后是将引用复制。 isEmpty() 判断字符串是否为空 下面，通过示例学习String的常用API 上面的实例中演示了字符串的常用API，因为String是一个不可变类，因此要大量操作字符串时，并不建议使用String对象，而应该使用StringBuilder和StringBuffer [#](第8章 String和常用类.html#_1-2-stringbuilder和stringbuffer)1.2 StringBuilder和StringBufferStringBuffer和StringBuilder通常也用于操作字符串，但是StringBuffer和StringBuilder中的字符数组不是用final修饰的，所有字符数组可以指向新的数组，也就是说用这两个类创建的字符串对象是可变的，StringBuffer和StringBuilder为开发者提供了以下几个方法。用于操作字符串： 方法 描述 append(String str) 字符串末尾追加字符串 delete(int start, int end) 删除区间内字符 deleteCharAt(int index) 删除索引处字符 replace(int start, int end, String str) 替换区间内的字符 substring(int start) 从start处截取到末尾 substring(int start, int end) 从start处截取到end insert(int offset, String str) 索引处插入字符串 indexOf(String str) 字符串str第一次出现的位置 reverse() 字符序列反转 toString() 对象转成字符串 因为StringBuffer和StringBuilder提供的方法都一样，所以方法都是通用的，下面通过示例学习首先，StringBuilder提供了一下几个构造方法： StringBuilder StringBuilder()：创建一个空的StringBuilder对象，一个空的字符序列 StringBuilder StringBuilder(StringBuilder builder)：传入StringBuilder对象创建字符序列 StringBuilder StringBuilder(String str)：根据字符串创建字符序列 StringBuilder(int capcity)：指定容量的StringBuilder对象 下面通过示例学习StringBuilder的方法。 1.3 Java对String的优化Java在底层对String进行了优化，节省了一定的内存空间，在前面的章节中可以看到，通过字面量的形式创建String对象，所谓字面量（也叫做直接量），就是在定义变量后直接给定的值。例如： 因为String是一个不可变类，也就是说一旦定义好一个字符串后，字符串的值是不能被改变了，如果发生了改变一定是指向了一个新的对象。那么这样的话无疑会占用大量的内存空间。因此Java对String进行了一定的优化，在JVM中有一块区域叫做常量池，常量池里放着字符串的字面量和常量。当字面量出现一个字符串后，Java会将该字面量放入常量池，如果再有变量引用该字符串时，直接返回常量池中字符串的引用，而不创建对象。通过下面的示例可以验证以上结论： 在前面的章节中知道，两个对象用“==”判断相等时，如果返回true，则这两个变量一定指向了相同的对象。从上面的结果可以看出变量a和变量b指向了同一个对象。总结一下就是常量池中的字符串有且只有一个，一旦创建后如果出现相同的字符串则直接返回字符串对象的引用，而不创建新的字符串。下面深入学习Java对字符串的优化 上面的结果可能会很疑惑，我们对上例中的代码逐行分析：当代码执行到第1行时，此时出现了字面量“张三”。因为未将该对象放入常量池，因此，运行时直接该对象的引用保存在a中。代码第2行，又出现了“张三”，此时常量池已经有了这个对象，此时就不再创建，此时先返回该对象的引用，返回该引用后，又new了一个String对象，此时在堆中分配了一块内存区域，这块内存中保存这刚才返回的引用。然后将堆中的引用保存在b中，因为a指向了常量池，变量b指向了堆中，所以a和b中保存的引用不同，所以用==判断时返回false。但是两个对象的内容相等，所以使用equals时两个变量的内容相等。继续看下面的示例： 运行上面的示例，可以看到结果都为true，这又是为什么呢？这也是Java对字符串的一项优化，也就是说在编译期间就可以确定变量d的结果为“HelloWorld”,而在确定变量d的结果之前，变量a的值已经放入了常量池，此时不再创建对象，直接返回引用，因此就有了上例中的结果。上面的示例可以看出字面量和字面量拼接结果是确定的，那么字面量和变量拼接，变量和变量拼接又会出现什么结果呢，针对上述的问题，JVM还对String做了优化，看下面的示例： 因为变量d是两个堆中的对象拼接，此时java会用StringBuilder对两个对象拼接，也就是说在堆中新创建一个对象，保存拼接后的字符串，并将引用返回给d保存，因为不是执行同一块内存，所有a中的地址和d中的地址不相同，所以返回false，两个对象的内容相同，所以使用equals方法时返回true，下面的代码也是一样，java会使用StringBuilder对两个对象进行拼接，所以返回的地址不同。 变量a的字面量“HelloWorld” 之前未在常量池中存放，此时将a对应的字面量存入常量池中，返回存入的地址。变量b在编译期间就已经形成“HelloWorld”,但由于a已将相同字面量“HelloWorld”放入变量池中，所以不再放入，只是将地址返回给变量b。此时a和b指向同一个地址，所以输出true； 1.4 String和StringBuffer以及StringBuilder的区别 String、StringBuffer、StringBuilder都是Charsquence接口的子类 String、StringBuffer、StringBuilder都是final修饰的，不能被继承，也就是说三者都没有子类 String是不可变类，创建的字符串序列不能被修改，StringBuffer和StringBuilder是可以修改的 StringBuffer是线程安全的，StringBuilder是非线程安全的，因此StringBuilder效率更高，在不考虑线程安全或者单线程情况下优先考虑使用StringBuilder。 判断邮箱是有合法，代码如下： 2、Scanner获取键盘输入 hasNextXXX()：是否还有下个输入项，其中XXX可以是Int，Long等代表基本类型的字符串。如果判断是否有 下一个字符串则直接使用hasNext()。 nextXxx()：获取下个输入项，输入项可以是基本类型数据，如果是字符串则直接使用next() 3、 系统相关 Map&lt;String,String&gt;getenv:获取系统所有的环境变量，保存在map集合中。 String getenv(String name) : 获取指定的环境变量。 Properties getProperties():获取系统的属性。 long currentTimeMillis()：获取当前时间的毫秒数，返回当前时间与UTC 1970年1月1日 00:00:00的时间差，以毫秒为单位 int identityHashCode(Object x)：获取指定对象的精确hashCode值. System还提供了一个复制数组的方法： void arraycopy(Object src, int srcPos, int destPos, int length)：该方法的作用是复制数组，第一个src是指被复制的数组，srcPos是指定复制的起始位置，dest则是指将元素粘贴到哪个数组，destPos是指目标数组粘贴的起始位置，length则可以理解为复制元素的个数。 void exit(int status)：退出虚拟机。 3.2 Runtime类Runtime类代表Java程序的运行时环境，每个Java程序都有一个与之对应Runtime实例。可以访问JVM相关信息，处理器数量，内存信息等 int availableProcessors()：获取处理器数量 long freeMemory()：获取jvm空闲内存 long totalMemory()：获取最大内存 long maxMemory()：获取虚拟机可以用最大内存 Runtime还提供了exec()方法，用于启动一个进程来运行操作系统的命令。 运行示例中的代码可以打开记事本 4、数学相关4.1 Math 工具类 方法 描述 Math.sqrt() 求平方根，参数为负数时返回NAN Math.pow(x,a) 幂运算，x的a次方 Math.floor(a) 向下取整 Math.ceil(a) 向上取整 Math.floorMod(x,y) 求余，x%y Math.toDegree() 弧度转换成角度 Math.toRadians() 角度转换成弧度 Math.sin() 求正弦 Math.cos() 求余弦 Math.tan() 求正切 Math.abs() 求绝对值 Math.max() 两个数的最大值 Math.min() 两个数最小值 Math.random() 0.0到1.0的随机数 4.2、 Random 生成随机数Random类用于生成一个伪随机数，Random类包含两个构造方法： Random（）：以当前时间作为种子 Random (long seed):需要开发者显示传入long型的种子 4.3、 BigDecimal在之前使用float和double在计算时很容易出现精度问题，如下问题： 输出结果为：0.300000000000000001 使用BigDecimal类的方法得以解决这个精度问题，如下所示： 5、 包装类定义基本类型变量时，并没有new对象，也就是说8中基本类型并不支持面向对象，不具备对象的特征，没有成员变量和成员方法可以被调用。 java针对每个基本类提供了对应的包装类，如下表所示： 基本类型 包装类 byte Byte short Short int Integer long Long char Character float Float double Double boolean Boolean 5.1 基本类型和包装类之间的转换 基本类型转换成包装类叫做自动装箱 包装类转换成基本类型时叫做自动拆箱 Integer 类中的缓存Integer类提供了缓存，将-128到127之间的Integer对象创建好放置在内存中，使用时直接返回对象的引用，如下所示： ‘==’如果指向同一地址就相等，运行结果为true，当创建a、b两个对象时，直接从缓存中获取对象，即a和b指向相同的地址。如果变量的值超出了缓存范围，则会创建新的对象。 注意： Byte、Short、Integer、Long这4个包装类，都具有-128到127之间的缓存，Float和Double类型则不具有。Boolean类型中表示true和false的对象则是两个常量 1.5.2 Integer 类常用方法6、 日期时间类6.1 Date类 Date()：创建一个代表当前时间的Date对象。 Date(long date)：根据指定的long类型整数生成一个Date对象。其中参数表示创建Date对象和GMT 1970年1月1日08:00:00之间的时间差。单位是毫秒。 Date类还为开发者提供了四种方法： boolean after（Date when）:测试日期是否在指定日期when之后。 boolean before（Date when）：测试该日期是否在指定日期when之前。 long getTime()：返回该时间对应的long型整数，即从GMT1970-01-01 00∶00∶00 到该Date 对象 之间的时间差，以毫秒作为计时单位。 void setTime(long time):设置该Date对象的时间。 6.2 Calender类Calender是一个抽象类。它用了几个静态方法用来获取Calender对象，如下所示： void add(int field,int amount)：根据日历的规则，为给定的日历字段添加或减去指定的时间量。 int get(int field)：返回指定日历字段的值。 int getActualMaximum(int field)：返回指定日历字段可能拥有的最大值，例如月，最大值为11. int getActualMinimum（int field）∶ 返回指定日历字段可能拥有的最小值。例如月，最小值为 0。 void roll（int field， int amount）∶与 add()方法类似，区别在于加上 amount 后超过了该字段所能表 示的最大范围时，也不会向上一个字段进位。 void set（int field， int value）∶将给定的日历字段设置为给定值。 void set（int year， int month， int date）∶ 设置 Calendar 对象的年、月、日三个字段的值。 void set（int year， int month，int date，int hourOfDay， int minute，int second）∶设置 Calendar 对象的年、 月、日、时、分、秒6个字段的值。 注：Calendar.MONTH字段代表月份，月份的起始值不是1，而是0，所以要设置8 月时，用7 而不是8。 add（int field，int amount）的功能非常强大，add 主要用于改变 Calendar 的特定字段的值。如果需要增加某字段的值，则让 amount 为正数;如果需要减少某字段的值，则让 amount 为负数即可。 add（int field， int amount）有如下两条规则： 当被修改的字段超出它允许的范围时，会发生进位，即上一级字段也会增大。 如果下一级字段也需要改变，那么该字段会修正到变化最小的值 roll()的规则与 add()的处理规则不同∶当被修改的字段超出它允许的范围时，上一级字段不会增大。 6.3 java.time包（java8新增） LocalDate：该类代表不带时区的日期。 LocalTime：该类代表不带时区的时间。 LocalDateTime：该类代表不带时期的时间，日期。 以上类提供了静态的 now()方法来获取 当前日期，它还提供了 minusXxx()方法在当前年份基础上减去几年、几月、几周或几日等，也提供了 plusXxx()方法在当前年份基础上加上几年、几月、几周或几日等 7、 格式化7.1 数字格式化NumberFormat 是所有数值格式的抽象基类。此类提供格式化和解析数值的接口。NumberFormat提供了以下方法用于格式化。 getInstance()、getNumberInstance()。返回当前默认语言环境的通用数值格式。 getInstance(Locale)、getNumberInstance(Locale)。返回指定语言环境的通用数值格式。 NumberFormat.setMinimumIntegerDigits(int)。设置数的整数部分所允许的最小位数。 NumberFormat.setMaximumIntegerDigits(int)。设置数的整数部分所允许的最大位数。 NumberFormat.setMinimumFractionDigits(int)。设置最少小数点位数，不足的位数以0补位，超出的话按实际位数输出。 NumberFormat.setMaximumFractionDigits(int)。设置最多保留小数位数，不足不补0。 7.2 日期格式化SimpleDateFormat对象格式化日期，yyyy（年）、MM（月）、dd（日）、 HH（小时）、mm（分）、ss（秒） 如下所示： Java 8位开发者提供了更强大的格式化工具DateFormatter，格式化之前需要先获取DateFormatter对象。 1.8 正则表达式正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。 字符 描述 \\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\\n’ 匹配一个换行符。序列 ‘\\‘ 匹配 “&quot; 而 “(“ 则匹配 “(“。 ^ 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\\n’ 或 ‘\\r’ 之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\\n’ 或 ‘\\r’ 之前的位置。 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。 . 匹配除换行符（\\n、\\r）之外的任何单个字符。要匹配包括 ‘\\n’ 在内的任何字符，请使用像”(.|\\n)“的模式。 (pattern) 匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘(‘ 或 ‘)‘。 (?:pattern) 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y|ies) 就是一个比 ‘industry|industries’ 更简略的表达式。 (?=pattern) 正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，”Windows(?=95|98|NT|2000)”能匹配”Windows2000”中的”Windows”，但不能匹配”Windows3.1”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern) 正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如”Windows(?!95|98|NT|2000)”能匹配”Windows3.1”中的”Windows”，但不能匹配”Windows2000”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?&lt;=pattern) 反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，”`(?&lt;=95 (?&lt;!pattern) 反向否定预查，与正向否定预查类似，只是方向相反。例如”`(?&lt;!95 x|y 匹配 x 或 y。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。 [xyz] 字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’、’l’、’i’、’n’。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 \\B 匹配非单词边界。’er\\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 \\cx 匹配由 x 指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 \\d 匹配一个数字字符。等价于 [0-9]。 \\D 匹配一个非数字字符。等价于 [^0-9]。 \\f 匹配一个换页符。等价于 \\x0c 和 \\cL。 \\n 匹配一个换行符。等价于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等价于 \\x0d 和 \\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。 \\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。 \\t 匹配一个制表符。等价于 \\x09 和 \\cI。 \\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。 \\w 匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’。 \\W 匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’。 \\xn 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\\x41’ 匹配 “A”。’\\x041’ 则等价于 ‘\\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码。 \\num 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\\1’ 匹配两个连续的相同字符。 \\n 标识一个八进制转义值或一个向后引用。如果 \\n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。 \\nm 标识一个八进制转义值或一个向后引用。如果 \\nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \\nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \\nm 将匹配八进制转义值 nm。 \\nml 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。 \\un 匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \\u00A9 匹配版权符号 (?)。 Java中为开发提供了2个类用于正则表达式： Pattern 类：pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。 Matcher 类：Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。 下面我们通过一个简单的示例，来了解正则表达式 学习心得今天学习了一些琐碎的知识点如格式化、时间等，不是能很好的完全掌握。晚上的作业题出现了一点歧义，我们知道数组的长度是固定不变的，但第一题就题目是“add(int e):默认在数组末尾添加元素”。我是要在开辟空间添加到在加到新开辟的空间，数组指向新的地址。想了想这样写有点大费周章，所以我在数组内，在添加的元素后进行添加。"},{"title":"学习心得[抽象类和接口]","date":"2022-07-26T00:37:39.000Z","url":"/2022/07/26/xianTrain15-abstractInterface/","categories":[["XiAnTrain","/categories/XiAnTrain/"]],"content":"***&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Java基础学习打卡第2天 抽象类和接口1.1抽象类和抽象方法​ 抽象类就是使用abstract修饰的类。抽象方法就是使用abstract修饰的方法 ​ 抽象类中抽象方法可有可无。 1.1.1 抽象类​ 普通类中包含的内容，在抽象类中都可以包含（成员变量、成员方法、构造类、内部类）。 ​ 当普通类继承了抽象类，那么就必须要重写抽象方法，否则普通类也必须是抽象类 ​ 抽象类不能被实例化 定义子类并重写父类的方法： 1.1.2 抽象方法​ 抽象方法止只有方法头，没有方法体，声明方法头后直接以分号结束。 ​ 抽象方法不能用static、final、private修饰 1.2 接口​ 接口可以理解为对抽象类的抽象，因为抽象类中不但有抽象方法，还有实例方法以及类方法等等。一个接口可以有多个直接父类接口，但接口只能继承接口不能继承类。 接口中只能包含：常量，抽象方法，私有方法，类方法，内部类（包括内部接口和枚举）不能包含构造器，初始化块，静态初始化块。 接口中定义的变量都是常量，默认的修饰符就是public static final ,因此即使不加，在编译时编译器也会自动添加。 定义接口里的普通方法时不管是否使用 public abstract 修饰符，接口里的普通方法总是使用public abstract 来修饰。 接口里的普通方不能有方法实现（方法体）；但类方法默认方法。私有方法都必须有方法体。 从上例中我们可以得出接口中的抽象方法子类必须重写，否则就需要用abstract修饰，默认方法则可以选择性重写，而私有方法则不需要重写。 接口和抽象类的区别 接口和抽象类都不能被实例化 接口和抽象类都可以包含抽象方法，实现接口或继承抽象类的普通子类都必须实现这些抽象方法。 接口里只能包含抽象方法、静态方法、默认方法和私有方法， 抽象类则完全可以包含实例方法。 接口里只能定义静态常量，不能定义普通成员变量;抽象类里则既可以定义普通成员变量，也 可以定义静态常量。 接口里不包含构造器; 抽象类里可以包含构造器，抽象类里的构造器并不是用于创建对象。 接口里不能包含初始化块; 但抽象类则完全可以包含初始化块。 一个类最多只能继承一个类，包括抽象类;但一个类可以直接实现多个接口 1.3 内部类在类内部定义的类叫做内部类，包含内部类的类叫做外部类或者宿主类。 内部类比外部类 多三个修饰符：private、protected、static。 1.3.1 非静态内部类 内部类可以直接访问外部类的私有变量（被当作外部成员类），反之不可以。 外部类访问内部类的成员，必须显示创建非静态内部类对象来调用访问其实例成员。 非静态内部类里不饿能有静态方法，静态成员变量、静态初始化块，但是可以包含初始化块。 创建初始化内部类时，先初始化外部类再初始化内部类，如下所示： 实例如下： 1.3.2 静态内部类 static关键字的作用是把类的成员变成类相关，即static修饰的成员属于整个类，而不是属于单个对象。 静态内部类可以包含静态成员，也可以包括非静态成员 静态内部类不能访问外部类的实例成员，只能访问外部类的类成员 创建初始化内部类时，如下所示： 1.3.3 局部内部类如果把一个内部类放在方法里定义，则这个内部类就是一个局部内部类，局部内部类仅在该方法里有效。由于局部内部类不能在外部类的方法以外的地方使用，因此局部内部类也不能使用访问控制符和 static 修饰符修饰。 1.3.4匿名内部类匿名内部类必须继承一个父类，或实现一个接口，但最多只能继承一个父类，或实现一个接口。 匿名内部类不能是抽象类，因为系统在创建匿名内部类时，会立即创建匿名内部类的对象。 匿名内部类不能定义构造器，由于匿名内部类没有类名，所以无法定义构造器。 匿名内部类可以定义初始化块，可以通过实例化块来完成构造器需要完成的事情。 1.4 枚举类在特定情况下，一个类的对象是有限且固定的，例如季节、星期、性别等，这种实例有限且固定的类，Java中称为枚举类 枚举类和普通类存在一下差异： 枚举类可以定义一个或多个接口，使用enum定义的枚举类默认继承了java.lang.Enum类，而不是默认继承Object类，因此枚举类不能显示继承其他父类。 使用 enum 定义、非抽象的枚举类默认会使用 final 修饰，因此枚举类不能派生子类。 枚举类的构造器只能使用private访问控制符，如果省略了构造器的访问控制符。 枚举类的所有实例必须在枚举类的第一行显示列出来，否则这个枚举类永远都不能产生实例，列出这些实例时，系统会自动添加public static final修饰，无需程序员显示添加。 1.4.1 定义枚举类 枚举类可以使用Enum类中的方法，下面介绍3个重要的方法： String name()∶ 返回此枚举实例的名称，这个名称就是定义枚举类时列出的所有枚举值之一。与 此方法相比，大多数程序员应该优先考虑使用 toString（O方法，因为 toStringO）方法返回更加用户友好的名称。 int ordinal()∶返回枚举值在枚举类中的索引值（就是枚举值在枚举声明中的位置，第一个枚举 值的索引值为零）。 String toString()∶返回枚举常量的名称，与name 方法相似，但 toStringO方法更常用。 1.4.2 枚举类的构造方法在枚举中定义构造方法： 在枚举类中列出枚举值时，实际上就是调用构造器创建枚举类对象，只是这里无须使用 new 关键字，也无需显式调用构造器。前面列出枚举值时无需传入参数，甚至无需使用括号，仅仅是因为前面的枚举类包含无参数的构造器。 7.4.2 枚举中的抽象方法假设有一个 Operation 枚举类，它的 4个枚举值 PLUS，MINUS，TIMES，DIVIDE 分别代表加、减、乘、除 4 种运算，该枚举类需要定义一个eval（）方法来完成计算。 从上面描述可以看出，Operation 需要让PLUS、MINUS、TIMES、DIVIDE 四个值对 evalO方法各有不同的实现。此时可考虑为 Operation 枚举类定义一个eval()抽象方法，然后让4个枚举值分别为eval()提供不同的实现。例如如下代码。 编写测试类： 注意：枚举类里定义抽象方法时不能使用 abstract 关键字将枚举类定义成抽象类（因为系统自动会为它添加 abstract 关铰字），但因为枚举类需要显式创建枚举值，而不是作为父类，所以定义每个枚举值时必须为抽象方法提供实现，否则将出现编译错误。"},{"title":"学习心得[高级篇]","date":"2022-07-21T13:23:31.000Z","url":"/2022/07/21/xianTrain14-object/","categories":[["XiAnTrain","/categories/XiAnTrain/"]],"content":"&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Java基础学习打卡第2天学习链接： 第5章 面向对象（基础篇) 密码：bqhg 面向对象（高级篇）java面向对象的三大特征：封装、继承和多态 1.1 封装封装是指将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象内部信息，只能通过该类提供的方法来访问来实现对内部信息的操作和访问。 1.1.1 访问控制符java提供了4个访问控制级别分别为（从小到大）：private 、default（缺省）、protected、public public:公共的，任意位置都可以访问 protected:同包和子类（同包子类，同包非子类，非同包子类） 缺省：同包（同包子类，同包非子类） private：私有(类内) public protected 缺省 private 类内 √ √ √ √ 同包子类 √ √ √ × 同包非子类 √ √ √ × 非同包子类 √ √ × × 非同包非子类 √ × × × 类的访问修饰符只有public和缺省 1.1.2 package、import和import static 包（package）机制，提供了类的多层命名空间，用于解决类的命名冲突、类文件管理等问题。包名应该全部是小写字母。package 语句必须作为源文件的第一条非注释性语句。 从操作系统层面来看，包就是一个文件夹或者路径 从项目开发角度来看，包可以有效的管理类 Java中引入包概念，目的是为了解决类名冲突的问题，不同包下可以有同名的类。如果某个类在某个包中，那么在类中代码的第一行一定要声明类所在的包：package packageName 包的命名一般使用域名的倒置例如：cn.bytecollege.util Java中定义一个类，会默认导入java.lang包 常用的包java.io：输入输出流 java.lang：通用包 java.lang.reflect：反射相关 java.math:数学相关 java.text：格式化相关 java.util：集合框架相关 java.sql：数据库相关 如果需要使用不同包中的其他类是，我们需要在类名前加包名。例如如下写法： 简化上述方法引入import关键字 import语句应该出现在package语句后、类定义之前，一个Java源文件只能包含一个package语句，但可以包含多个import语句 导入还有一种静态导入，静态导入使用import static语句，用于导入指定类的单个静态成员变量、方法和全部静态成员变量、方法。例如我们使用的System.out.print()。 1.3 构造器构造器主要用于被其他方法调用，用以返回该类的实例，因而通常把构造器设置成 public 访问权限，从而允许系统中任何位置的类来创建该类的对象。 1.3.1 构造器重载同一个类里具有多个构造器，多个构造器的形参列表不同，即被称为构造器重载。 1.2 类的继承Java的继承具有单继承的特点，也就是所每个类有且只能有一个父类。 所谓继承就是在已有类的基础上构建一个新类，使用extends关键字来实现，从而达到代码复用的目的，其中已有类也叫做父类、基类或者超类，新扩展的的类叫做子类或者派生类。 1.2.1 继承的特点java中继承的语法格式如下： Java中所有的类都是Object的子类，每个类都会直接或者间接继承Object。 1.2.2 方法重写当子类从父类继承的方法不能满足子类需要时，子类可以对父类的方法进行重写，也叫方法覆盖 方法重写的特征 方法重写只存在于继承关系中 方法名相同参数列表相同 返回类型和父类方法返回值类型一致或者是父类方法的返回值类型的子类 访问修饰符权限大于等于父类方法访问修饰符权限 子类方法抛出异常小于等于父类方法抛出异常 一大两小两相等 构造方法能不能被重写？ 构造方法不能被重写，因为构造方法不属于类的成员，而继承的前提条件是继承类的成员。 1.2.3 super关键字super指代父类对象 ，用于访问从父类继承得到的实例变量或者方法，同时可以访问父类的构造方法。 注： 1、在构造方法中super（）必须放在第一行。 2、创建子类对象时会先创建父类对象，如果没有手动加super（），编译时会自动添加super（）。 如果在某个方法中访问某个成员变量，但是没有显式的指定调用者，则编译器查找顺序如下： 查找该方法中是否含有该局部变量 查找当前类中是否包含该实例变量 查找直接父类中是否包含该变量，依次向上追溯所有父类，如果直到Object类还是没有找到，则编译错误 1.2.4 object类Object是所有类的父类，当一个类没有使用extends关键字显式的指定父类，则该类继承Object类， 方法 描述 getClass() 获得当前对象的类对象 hashCode() 返回当前对象的hashCode() equals() 判断两个对象是否相等 clone() 克隆并返回当前对象副本 toString() 打印该对象 notify() 线程唤醒 notifyAll() 线程唤醒 wait() 线程等待 finalize() 通知垃圾回收器回收，该方法不确实实际执行时间，不推荐使用 1.2.4.2 重写equals()方法重写equals()方法需要满足以下条件： 自反性∶ 对任意 x，x.equals（x）一定返回 true。 对称性∶ 对任意x和 y，如果 y.equals（x）返回 true，则x.equals（y）也返回 true。 传递性∶ 对任意x，y，z，如果x.equals（y）返回 ture，y.equals（z）返回 true，则x.equals（z）一定返回 true。 一致性∶ 对任意x和 y，如果对象中用于等价比较的信息没有改变，那么无论调用 x.equals（y） 多少次，返回的结果应该保持一致，要么一直是 true，要么一直是 false。 对任何不是 null 的x，x.equals（null）一定返回 false。 重写步骤： 判断是否是同一引用，如果是则返回true 判断obj是否为null，如果是则返回false； 判断是否是同一类型 转换为同一类型对象 判读那所有实例变量是否相等，基本类型使用“==”，引用类型使用equals。 1.2.4.3 ==和equals的区别我们在判断两个基本类型是否相等时，通常使用双等号，但是判断两个对象相等，使用==就比较有局限性了，因为使用双等号只能判断两个变量指向同一引用的情况，而我们在日常开发中通常两个对象的所有实例变量相等，即可认为两个对象相等。从内存的角度来说，==用于判断变量栈内存中保存的内容是否相等，而equals则是判断对象在堆内存中的内容是否相等。简而言之，基本类型相等的判断使用==，而判断两个对象是否相等，则需要重写equals方法来判断。 1.3 多态java中创建对象时，有编译时类型和运行时类型（分别在等号左边和等号右边）。当编译时类型和运行时类型不一样时，就会产生多态。多态可以理解为同一对象调用相同方法，展示的不同行为，主要通过方法重写和方法重载实现。 父类引用指向子类对象时，调用方法看右边（子类对象中如果存在该方法则调用子类对象的，如果不存在该方法则调用父类对象的），访问实例变量看左边。 ” 对象的实例变量不具备多态性 “ 1.3.1 instabceof运算符instanceof 运算符的作用是判断对象是否是某个类型，第一个操作数通常是一个引用类型的变量，后面的操作数通常是一个类，或者是其子类等等，如果是则返回true，如果不是则返回false。在使用 instanceof 运算符时需要注意; instanceof 运算符前面操作数的编译时类型要么与后面的类相同，要么与后面的类具有父子继承关系，否则会引起编译错误。 1.3.2 向上转型和向下转型我们通过示例来学习向上转型和向下转型： 1.4 初始化块一个类中可以存在多个初始化块，相同类型的初始化块按照书写的先后顺序执行 输出结果： 执行了第1个初始化块 执行了第2个初始化块 执行了构造方法 main方法中访问name属性：张三 注：从反编译的角度来看，初始化块中的代码在运行时会合并进构造器中 1.4.1 静态初始化块使用static修饰的初始化块，称之为静态初始化块（类初始化块）。 普通初始化块负责对对象进行初始化，类初始化块则负责对类进行初始化。静态初始化块是类相关的，系统将在类初始化阶段执行静态初始化块，而不是在创建对象时才执行，因此静态初始化块比普通初始化块先执行。并且类初始化块通常用于对类变量进行初始化处理，静态初始化块不能对实例变量进行初始化。 系统在类初始化阶段执行静态初始化块时，不仅会执行本类的静态初始化块，而且还会一直上溯到 java.lang.Object 类。然后依次向下执行静态初始化块 注意：静态初始化块也被称为类初始化块，同样静态成员不能访问非静态成员，因此静态初始化块不能访问实例变量和实例方法。 我们通过示例来学习静态初始化块： 我们可以归纳出静态代码块和初始化块的顺序 父类静态块–》子类静态块–》父类初始化块和构造器–》子类初始化块和构造器 1.5 final 关键字final关键字可以用于修饰类、变量和方法，用于表示不可改变的意思 final修饰成员变量初始化后不能被重新赋值 (成员变量是随类初始化或对象初始化而初始化的) 类变量:必须在 静态初始化块中指定初始值 或 声明该类变量时指定初始值 ，而且只能在两个地 方的其中之一指定。 实例变量∶ 必须在非静态初始化块、声明该实例变量或构造器中指定初始值，而且只能在三个 地方的其中之一指定。 final修饰的方法不可被重写（但可以被重载） final修饰类不能被继承 java共有9个类是final修饰的：八个包装类、一个java.lang.String类。 八个包装类：Integer、Character、Long、Double、Float、Short、Byte、Boolean 1.6 软件设计原则 单一职责原则（Single Responsibility Principle） ​ 单一职责简要来说就是对于一个类而言，应该只专注做一件事情 里式替换原则(Liskov Substitution Principle) ​ 只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或者异常。但是反过来则不行，子类能出现的地方，父类一不定能出现，这一点要尤为注意 学习心得今天王哥给我们看了一下之后要学习的内容，好多东西我都没听过什么这个锁那个锁的，这个算法那个算法的实在太多了。感觉现在才学到这有点慢了，后面还有那么多知识点，况且还不熟悉，总之卷死他们，先开始预习了。 今天学会了什么？​ 今天温度还算比较凉快，上课比较精神，偶尔只是打个盹。现在开始内容慢慢的变得有趣，因为有些知识之前没有考虑到被忽略了。今天买了一个电饭锅准备以后有时间自己烧饭，还买了一点餐具，调味品杂七杂八的。"},{"title":"学习心得[基础篇]","date":"2022-07-20T12:52:38.000Z","url":"/2022/07/20/xianTrain13-objectO/","categories":[["XiAnTrain","/categories/XiAnTrain/"]],"content":"&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Java基础学习打卡第2天学习链接： 第5章 面向对象（基础篇) 密码：bqhg 面向对象什么是类？ 类是一系列具有相同行为和属性的对象的集合，用来描述客观世界中一类对象的共同特征。它是一种抽象的数据类型，它是对所具有相同特征实体的抽象。在面向对象的程序设计语言中，类是对一类“事物”的属性与行为的抽象。 什么是对象？ 对象就是一个真实世界中的实体，对象与实体是一一对应关系的，意思就是现实世界的每一个实体都是一个对象，所以对象是一个具体的概念。 对象是类的实例，类是对象的模板，二者相互依存 1.1 类和对象类是面向对象的重要内容，可以把类当做一种自定义类型，可以使用类来定义变量，这种类型的变量统称为引用类型变量。 1.1.1 定义类面向对象的程序设计中有两个重要的概念：类（class）和对象（object，也叫实例） 类是对一群对象的抽象，可以把类理解为某个群体。对象则是具体的存在 java中定义类的简单语法如下： 修饰符可以是：public、final、abstract、或者完全省略四个修饰符。 注：类名一般使用帕斯卡命名法（所有首字母单词均大写，且单词间不用任何分隔符） 定义成员变量如下： 修饰符：可以省略、public 、protected、 private（四选一）、 static、 final、 transient 类型：基本类型、引用类型。 注：成员变量命名一般使用驼峰命名法（第一个单词首字母小写，其余单词的首字母均大写，并且要做到见名知意） 定义方法的语法格式如下： 注：方法名的命名规则同成员变量的命名规则基本一致； 定义构造器语法格式如下： 注： 1、如果开发者没有为类编写构造器，编译器会为该类提供一个默认无参数的构造器，一旦开发者提供了构造器，则编译器不在提供构造器。 2 、构造器是一种特殊的方法，其方法名和类名形同，但没有方法返回值，也不用void修饰 1.2 创建对象和使用对象创建对象最根本的途径是调用构造器，java中通过new关键字来调用构造器创建对象。 当创建了对象之后，我们可以对对象进行如下操作 访问对象的实例变量 调用对象的方法 注：static 修饰的方法和成员变量，称为类变量和类方法，即可通过类来调用，也可通过实例来调用；没有static修饰的方法和成员变量，称为实例变量和实例方法， 1.3 基本类型和引用类型定义一个基本类型的变量： 当执行上述代码时，其内存中的结构如下图所示： 定义一个引用类型的变量： 综上所述，我们可以简单的理解为基本类型在栈中保存的是变量真实的值，而引用类型保存的并不是对象而是一个地址或者说引用，这就是基本类型和引用类型的根本区别，这也就是说我们通常判断基本类型相等时，用双等号即可，而判断引用类型则不能用双等号。 1.4 this关键字this代表当前对象，this可以访问类中的构造器，可以访问类中的实例方法，可以访问实例变量。 this访问实例变量时，一个作用是区分实例变量和局部变量，另一个作用是再实例方法中访问实例变量（this可以省略） this可以在方法中调用类中的其他实例方法，this可以省略。 this调用构造方法，只能在构造器中使用，并且必须是构造器代码第一行。 this不能出现的类方法中 final修饰的变量就是常量，常量一旦被初始化后，其值不能被改变，常量命名要求所有字符大写，多个单词间用下划线分割。 this关键字可以指代当前对象 ，this作为当前对象的默认引用有两种使用方式： 构造器中使用this可以调用其他构造器 方法中使用this可以访问其他方法或者实例变量，通常this可以省略； this最大的作用就是让类中一个方法，访问该类中的另一个方法或者实例变量 切记：this调用构造方法只能在构造方法中使用，不能写在实例方法中，并且要放在构造犯法中代码的第一行 注意：this不能出现在类方法中，因为类方法在类加载后，创建对象前就已经准备完毕，此时还没有对象，也就不存在this 1.5 方法详解方法是类或对象的行为特征的抽象，方法石磊会对象最重要的组成部分。方法在逻辑上要么属于类，要么属于对象。 1.5.1 实例方法和类方法 被static修饰的方法叫做类方法，方法属于类，调用时不依赖于对象通过类名.方法即可调用。（也可以通过创建类的对象来进行调用，但这样一般不推荐使用） 不被static修饰的方法叫做实例方法，方法属于对象，调用时依赖对象，必须先创建对象才能调用，因此其调用方式是 对象名.方法名。 注：同一个类的一个方法调用另一个方法时，如果被调方法是实例方法，则默认使用this作为调用者；如果被调方法是静态方法，则默认使用类作为调用者。方法不能独立定义，方法只类中定义。 通过示例来区别类方法和实例方法： 编写Person类： 编写测试类： 在static修饰的方法调用实例方法（错误演示）： 注意：类方法中一定不能调用共实例方法；（这个说法是错误的） 错误原因：在类初始化时，实例方法还有被初始化。 错误解决方法：可以在类方法中创建类的对象，再通过对象调用实例方法 在实例方法中可以调用类方法： 这是因为static修饰的都是所有对象所共有的，不依赖于对象，并且如果在同一类中，可以省略类名，但是一般不推荐在实例方法中调用类方法。 1.5.2 方法的参数传递java的是实参值是如何传入方法的？ ​ 这是由于java方法的参数传递机制来控制的，Java 里方法的参数传递方式只有一种： 值传递 （ 即将实际参数值的副本 传入方法内，而参数本身不受影响）。​ 形参是基本数据类型：将实参基本数据类型变量的“数据值”传递给形参​ 形参是引用数据类型：将实参引用数据类型变量的“地址值”传递给形参基本类型示例如下： 结果并没有交换两个数的值。 引用类型示例如下： 传递参数的本质是值传递为什么会出现以上两种情况？ ​ 这是因为在进行值传递时，将变量所对应在栈中的值进行传递。基本类型在栈中存储的是数据本身，而引用类型在栈中存储的是地址。所以在以上两个实例中会出现不同效果；所谓的引用传递本质上都是值传递。 1.5.3可变参数jdk1.5以后允许定义形参个数可变的参数，从而允许为方法指定数量不确定的参数。格式：最后一个参数类型后添加三个点； 注：可变参数只能处于参数列表的最后一个参数，一个方法中只能包含一个可变参数，可变参数的本质就是一个数组。 1.5.4 方法重载同一个类中包含了两个或者两个以上方法名相同，但参数列表不同（个数不同、数据类型不同），则被称为方法重载。与访问修饰符、方法返回值、方法抛出异常无关。 注意下面类中方法不构成方法重载： 通过传入的参数由JVM决定调用哪个方法，编译器尝试从给定的重载方法定义中解析方法调用的过程称为重载解析。如果编译器找不到确切的匹配项，则仅通过使用向上转换来查找最接近的匹配（永远不会进行向下转换）。 计算矩形面积喝圆面积实例如下： 学习心得​ 今天学习了类和对象相关的知识点，这块内容在之前就已经掌握，但在王老师的讲解之后发现还是有几个知识点被忽略了，在之前并没有深层次去理解只是记住了一个概念，通过今天学习让我把这些遗漏的知识点弥补了。"},{"title":"The requested URL returned error: 403","date":"2022-07-19T06:04:01.000Z","url":"/2022/07/19/fatal220719-request403/","categories":[["fatal","/categories/fatal/"]],"content":" 报错结果： 解决方法：（1）进入github官网，点击头像，弹出下拉列表，点击Settings 复制完生成的令牌之后修改_config.yml文件中 此类问题多数为网络不稳定，多次刷新即可，再者关机重启。 "},{"title":"培训心得[数组]","date":"2022-07-18T12:22:40.000Z","url":"/2022/07/18/xianTrain12-Array/","categories":[["XiAnTrain","/categories/XiAnTrain/"]],"content":"&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Java基础学习打卡第2天学习链接： 《第4章 数组》密码：mg6w 1 数组数据就是：具有相同数据类型且按照一定次序排列的一组数据的集合 注意：1、具有相同的数据类型 ​ 2、按照一定次序排列 ​ 3、一组数据 1.1 定义数组数组的定义方式有两种语法：(推荐使用第一种) type[] arrayName; type arrayName[]; 注意： 1、数组的初始化一旦完成，数组在内存中所占的空间将被固定下来，因此数组的长度不可改变。 2、数组是一种引用类型的变量，当仅仅是定义了数组，定义了一个变量后，这个变量还未指向任何有效内存，此时整个数组还不能使用，只有对数组初始化后才能使用。 1.1.1 数组的初始化所谓初始化，就是为数据的元素分配内存空间，并为每个元素赋初值。 数组的初始化有两种方式： 静态初始化：由程序员指定每个元素的初始值。由熊指定数组的长度。 格式如下： 下面通过示例来定义并初始化数组 动态初始化：程序员指定数组长度，由系统为元素分配初始值。 格式如下： 指定初始值时，系统按如下规则分配初始值： 数组元素的类型是基本类型中的整型(byte,shor,int,long)，则数组元素的初始值为0; 数组元素的类型是基本类型中的浮点型(float，double),则数组元素的值是0.0; 数组元素的类型是基本类型中的字符型(char) ,则数组元素的值是’\\uo000’; 数组元素的类型是基本类型中的布尔型(boolean)，则数组元素的默认值是false。 数组元素的类型是基本类型中的引用类型，则数组元素的默认值是null。 1.2 使用数组 1.2.1 for循环遍历数组 1.2.2 foreach遍历数组使用foreach遍历数组和集合元素时，毋须获得数组和集合长度，无需根据索引来访问数组元素。遍历数组示例如下: 1.3 深入数组1.3.1内存中的数组定义一个数组类型的变量只是一个引用，这个引用变量可以指向任何有效内存。 int[] a 此时只是定义了一个数组类型的变量，该变量没有指向任何有效内存，如果此时访问数组元素时，将会引发空指针异常。 实际的数组对象被存储在堆内存中，如果引用该数组对象的数组引用变量是一个局部变量，那么它将被存储在栈内存中。 如果堆内存中数组不在被任何变量引用，这个数组将成为垃圾，该数组所占有的内存将会被jvm中的垃圾回收器回收。 1.3.2数组长度不能被改变数组一旦被初始化后长度不可变，如果发生了变化，一定是指向了新的数组 注：java语言提供了多维数组的支持，但是实际上并不存在多维数组。因为java语言中数组类型是引用类型，因此数组变量其实是一个引用，这个引用指向真实数组的内存。 1.4 Array 工具类 int BinarySearch(long[] a, long key) 使用二分查找法查询key元素值在数组a中出现的索引，如果a数组不包含key元素，则返回复数，调用此方法时要求数组中的元素已经是升序的。 T[] copyOf(T[] original,int newlength) 该方法会把original数组复制成一个新数组，其中length是新数组的长度，如果length小于original数组的长度，则新数组就是原数组的前面length个元素，如果lenght大于original数组的长度，则新数组的前面元素就是原数组的所有元素，后面补充默认值，根据数组类型确定 copyOfRange(T[] original, int from, int to) 这个方法与前面的类似，但是这个方法只复制原数组form索引到to索引的元素。 boolean equals(type[] a, tyte[]a2) 如果数组a和a2长度相等，并且a和a2每个元素也相等则返回true，否则返回false。 void fill(long[] a,val) 该方法会把a数组的所有元素都赋值为val void sort(type[] a) 该方法对a数组进行排序 String toString(type[] a) 该方法将一个数组转换成字符串，该方法按顺序吧多个元素连接在一起，元素之间用逗号隔开。 学习心得​ 今天学习了一些java的控制流程和数组，基本全部掌握，毕竟在学校里这一块知识经常用到，所以再学起来也是很容易的。由于之前在客厅睡，睡的不好。昨天就给安老师说完之后，就要我搬了宿舍，现在一个人住，超喜欢一个人的感觉，超自由。刷视频想外放，就外放。"},{"title":"培训心得[java控制流程]","date":"2022-07-18T10:57:52.000Z","url":"/2022/07/18/xianTrain11-controllerStream/","categories":[["XiAnTrain","/categories/XiAnTrain/"]],"content":"&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Java基础学习打卡第2天学习链接： 《第3章 流程控制》密码：zk84 1 控制流程 可分为：顺序结构、分支结构、循环结构 1.1 顺序结构 程序自上而下依次执行，中间没有任何判断和跳转。 1.2 分支结构 java提供了两种分支结构：if语句和switch语句 1.2.1 if条件语句 if语句使用布尔表达式或者布尔值作为分支条件进行分支控制，if语句有一下三种形式： 单分支结构 if(logic expression){ statement;}else{ statement;} 多分支结构 1.2.2 switch条件语句 switch语句有一个控制表达式和多个case标签组成，和if语句不同的是，switch语句后面的控制表达式的数据类型只能是byte、short、chat、int四种类型、从java7以后添加了枚举类型和String类型，switch语句和语法格式如下： 1.2.2 分支嵌套 1.3 循环结构循环结构是指在满足某个循环条件的情况下，反复执行同一代码，只到不满足循环条件为止。恰当的循环结构包含：初始化语句、循环条件、循环体、迭代语句； 1.3.1 for循环语法格式如下： 其中init_statement指初始化条件，test_exoression指循环条件，statement是循环体，iteration_statment迭代语句，在statement执行结束以后执行。先执行init_statement初始化语句只在混循环条件开始前执行一次，每次执行循环体之前，先计算test_exression循环条件的值。 例如：计算1-100的和 注意： 除非特殊情况尽量不要在循环体内修改循环变量的值。 for循环圆括号中只有两个分号是必须的，初始化语句、循环条件、迭代语句部分都是可以省略的。如：for( ; ; ) 1.3.2 while循环如果while循环的循环体部分和迭代语句合并在一起，且只有一行代码，则可以省略。（但是通常不建议省略） 使用while循环时，一定要保证循环条件有变成false的时候，否则这个循环将变成循环，用于无法结束循环。 语法格式如下： 例如：计算1-100的和 1.3.3 do while循环do while循环是先执行一次循环体，再判断循环条件，而while循环是先判断循环条件再执行一次循环体。 语法格式如下： 1.4 控制循环结构java提供了continue和break空值循环结构，在java中goto只作为了保留字 1.4.1使用break结束循环break用于完全结束一个循环，跳出循环体，不管那这个哪种循环，一旦循环体中遇到break，系统将完全结束该循环，开始执行循环结构以后的代码。 循环嵌套中使用break 遇到一个break outer语句，该语句将会导致结束outer标签指定的循环，不是break所在的循环，而是结束break循环的外层循环。 1.4.2 使用continue跳转次循环continue只是跳出次循环，继续执行剩下的循环，并不是完全终止循环。 示例如下： 循环嵌套中使用continue 在多层循环中，continue会忽略当前循环，直接到外层循环继续进行循环 课后作业：1.请将101转换成二进制，并将二进制的前3位替换为1，并求出原码 0000 0000 0000 0000 0000 0000 0110 0101 101的二进制1110 0000 0000 0000 0000 0000 0110 0101 替换后的补码1110 0000 0000 0000 0000 0000 0110 0100 补码减一1001 1111 1111 1111 1111 1111 1001 1011 取反求出原码"},{"title":"培训心得[java数据类型和运算符]","date":"2022-07-16T06:38:44.000Z","url":"/2022/07/16/xianTrain10-javaDateTypeAddOperation/","categories":[["XiAnTrain","/categories/XiAnTrain/"]],"content":"&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Java基础学习打卡第2天学习链接： 《第2章 Java数据类型和运算符》密码：ekp0 java是一门强类型语言： 所有的变量都必须先声明，后使用 变量的类型一旦确定，那么变量的值必须和数据类型相匹配。 java标识符 标识符：类名、方法名、变量名 可以包含数字、字母、下划线、$ 不能数字开头 不能使用Java关键字 java中总共有50个关键字，如下表： abstract continue for new switch assert default if package synchronized boolean do goto private this break double implements protected throw byte else import public throw case enum instanceof return transient catch extends int short try char final interface static void class finally long strictfp volatile const float native super while Java命名方式 (Pascal)帕斯卡命名法：所有单词首字母均大写。适用于类名，例如：StudentManager (Camel)驼峰命名法：第一个单词的首字母小写，如果有多个但是，其余单词首字母均大写，适用于方法名，变量名。例如：studentAge，studentGender Java数据类型 基本类型：byte short int long float double boolean char 引用类型: 数组， 类，接口 整数 整数通常可以分为以下4种： byte:占一个字节（占8位）,可表示范围：-128 ——— 127 short:占2个字节（占16位）,可表示范围：-2^15 ——— 2^15-1 int:占4个字节（占32位），可表示范围：-2^31 ——— 2^31-1 long:占8个字节（占64位），可表示范围：-2^31 ——— 2^31-1(定义时需要在数值后添加L) JAVA中整数值有四种表示方式：十进制、二进制、十六进制、八进制，其中二进制的整数以0b或者0B开头；八进制的整数以0开头;十六进制的整数以0x或者0X开头，其中10-15分别以a-f表示。 浮点数 浮点数可以分为：float和double。 float类型:占四个字节，第一位表示符号位，接下来8位表示指数，接下来的23位表示尾数； double类型:占八个字节，第一位表示符号位，接下来11位表示指数，接下来的52位表示尾数； 浮点数可用十进制和科学计数法进行表示 java还提供了特殊的浮点数：正无穷大（infinity）、负无穷大（-infinity）、非数（NaN）。注意：所有的正无穷大都是相等的，所有的负无穷大都是相等的，但是NAN与任何数值都不想等，甚至和NAN都不相等。另外，只有浮点数以0才可以得到正无穷大或者负无穷大，如果一个整数除以0，则会抛出一个异常。 字符型字符型占两个字符，通常表示单个字符，字符型值必须要用单引号括起来。Java语言使用16位的Unicode字符集作为编码方式。字符型值有3种表示形式。 整数 整数通常可以分为以下4种： byte:占一个字节（占8位）,可表示范围：-128 ——— 127 short:占2个字节（占16位）,可表示范围：-2^15 ——— 2^15-1 int:占4个字节（占32位），可表示范围：-2^31 ——— 2^31-1 long:占8个字节（占64位），可表示范围：-2^31 ——— 2^31-1(定义时需要在数值后添加L) JAVA中整数值有四种表示方式：十进制、二进制、十六进制、八进制，其中二进制的整数以0b或者0B开头；八进制的整数以0开头;十六进制的整数以0x或者0X开头，其中10-15分别以a-f表示。 浮点数 浮点数可以分为：float和double。 float类型:占四个字节，第一位表示符号位，接下来8位表示指数，接下来的23位表示尾数； double类型:占八个字节，第一位表示符号位，接下来11位表示指数，接下来的52位表示尾数； 浮点数可用十进制和科学计数法进行表示 java还提供了特殊的浮点数：正无穷大（infinity）、负无穷大（-infinity）、非数（NaN）。注意：所有的正无穷大都是相等的，所有的负无穷大都是相等的，但是NAN与任何数值都不想等，甚至和NAN都不相等。另外，只有浮点数以0才可以得到正无穷大或者负无穷大，如果一个整数除以0，则会抛出一个异常。 字符型字符型占两个字符，通常表示单个字符，字符型值必须要用单引号括起来。Java语言使用16位的Unicode字符集作为编码方式。字符型值有3种表示形式。 基本类型的转换 转换的方式有两种：自动类型转换和强制类型转换java中当把一个表示范围小的数值或变量赋值给另一个表示范围大的变量时，系统将自动进行转换，反之需要强制转换。 自动类型转换 自动转换可以理解为将一个小容器的桶中的水倒入大容量的桶中，当小容量桶中的水倒入大容量的桶时通常不会有什么问题，但是当把大容量的桶中的水倒入小容量的桶就很容易溢出的情况 强制类型转换 格式：(targetType)value;注意：这种类型转换容易造成数据的溢出 自动类型提升 当一个算数表达式中包含多个基本类型的值时，整个算是表达式的数据类型讲噶生自动提升，提升的规则如下： 所有的byte、short和char类型被提升到int类型 整个算数表达式的数据类型自动提升到表达式中最高等级操作数相同的类型。 运算符 java的运算符可以分为以下几类： 算术运算符 赋值运算符 比较运算符 逻辑运算符 位运算符 类型相关的运算符 算术运算符 用于执行基本的数学运算:加（+）、减（-）、乘（*）、除（/）、取余（%） 学习心得"},{"title":"培训心得[Java语言概述]","date":"2022-07-15T11:33:58.000Z","url":"/2022/07/15/xianTrain9-JavaSummary/","categories":[["XiAnTrain","/categories/XiAnTrain/"]],"content":"&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Java基础学习打卡第1天学习链接： 《第1章 Java语言概述》密码：syl5 java语言概述Java发展简史 Java是由Sun公司于1995年5月推出的，可以编写跨平台，分布式应用软件的面向对象的程序设计语言。 java一分为三： J2ME:主要用于移动设备和信息家电设备等（现已被淘汰） J2SE:JAVA技术的核心和技术 J2EE:java技术中应用最广泛的部分 java程序的运行机制 运行Java程序过程：编写源程序—&gt;编译—&gt;运行 java编译之后，不会生成特定的平台机器码，而是一种与平台无关的字节码(.class文件)。 字节码（.class文件）不能直接执行，而是运行在java虚拟机中 （面试题）java跨平台实现的核心原理： java源代码在运行之前会先根据JVM规范生成平台无关的字节码文件（class文件）,字节码文件不依赖于任何平台。 Java为不同平台实现对应的虚拟机，JVM在加载字节码文件后由JVM生成对应平台的计算机指令 Java语言的特点 简单性：相对于c语言少了指针、头文件等，并增加了垃圾回收机制。 面向对象：将重点放在数据和对象上，而不是过程中 分布式：java应用程序能够通过URL打开和访问网络上的对象 安全性：防范个各种攻击 多线程：解决高并发存在的问题 可移植：不同平台可生成相同字节码文件，通过不同平台对应的JVM来运行。 技术名词JDK(Java Develop Kit):Java 开发工具 JRE(Java Runtime Environment)：Java 运行环境 JVM(Java Virtual machine )：Java虚拟机 Java下载安装JAVA的核心代码存放在lib文件夹中 JDK下载官网： (安装java SE 11,点击运行安装即可) 配置环境变量： 配置JAVA_HOME 变量名：JAVA_HOME变量值: (JDK的安装路径) 配置Path 找到Path在变量值中添加：%JAVA_HOME%\\bin 编写第一个程序HelloWorld在txt中编写： 保存后修改扩展名.java打开终端，进入创建该txt的文件夹(cd 位置)源程序进行编译:javac Hello.java运行:java Hello 注意事项：1、Java源文件的命名和类名一致，并且首字符大写，如果有多个单词，所有单词的首字母均大写 课后作业1、请简述你对java的认识 java是一个可编写跨平台、分布式应用软件的面向对象的程序设计语言，主要的特点有简单性、安全性、分布式、可移植、面向对象、多线程。java源程序需要先编译再运行。2、Java的平台无关性是怎么实现的？由于不同平台有相应的JVM，java源程序经过编译在不同的平台生成相同的字节码文件，再经过运行再不同的JVM中从而实现java平台的无关性。3、请简述java源文件命名规则？Java源文件的命名和类名一致，并且首字符大写，如果有多个单词，所有单词的首字母均大写java通过 学习心得 今天上午进行了一次面试，说是面试实质了解了一下我们个人情况。当时做了一下自我介绍，就没了，还期待人家问问题，结果没有。下午就进行了分班，分到了王老师的班中，第一次听他教课，给我的感觉还算通俗易懂、挺好的。期待接下来的四个月，让自己的知识储备更加巩固，更加完善。最终取得一个满意的offer。 "},{"date":"2022-07-15T01:49:51.260Z","url":"/2022/07/15/baidu_verify_code-lKi6sS4j7S/","categories":[["undefined",""]],"content":"f2c7aa5496980a4ac5b119f84ca39e87"},{"title":"培训心得 [JQuery]","date":"2022-07-13T07:06:55.000Z","url":"/2022/07/13/xianTrain8-JQuery/","categories":[["XiAnTrain","/categories/XiAnTrain/"]],"content":"&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;学习打卡第嗯-2天 JQuery的定义 它是javaScript的封装，它可以说是开源的JavaScript的函数 简化了JavaScript开发 JQuery的下载及引用 下载： 应用方法： JQuery选择器 JQuery选择器可以用来快速的选中一个元素，获取或修改其信息，其使用规则和CSS样式是一样的。 种类 标签选择器 类选择器 id选择器 后代选择器（层级选择器） 使用方法即$(CSS选择器使用规则) $(“#id”) $(“.class”) $(“.class ul li”) $(“div”) 选择器过滤 过滤就是在选择标签的集合中过滤出自己需要的标签 has() has(选择器名称)， 表示选取指定选择器的标签 eq(索引)，表示选取指定索引的元素 选择转移 我们可以以一个元素为参照，找到其它元素（节点选择） 详细如下： $(‘#box’).prev(); 表示选择id是box元素的兄弟节点$(‘#box’).prevAll(); 表示选择id是box元素的上面所有的同级元素$(‘#box’).next(); 表示选择id是box元素的兄弟节点$(‘#box’).nextAll(); 表示选择id是box元素的下面所有的同级元素$(‘#box’).parent(); 表示选择id是box元素的父元素$(‘#box’).children(); 表示选择id是box元素的所有子元素$(‘#box’).siblings(); 表示选择id是box元素的其它同级元素$(‘#box’).find(‘.myClass’); 表示选择id是box元素的class等于myClass的元素 html方法的使用 在jquery中可以通过html属性为元素设置html内容 获取和设置元素的属性 prop方法：css方法可以设置元素的样式属性，而该方法可以设置元素的其他属性 JQuery事件 常用事件 click()鼠标点击事件 blur() 离焦事件 focus() 聚焦事件 mouseover() 鼠标进入事件 mouseout() 鼠标离开事件 ready() DOM加载完毕触发 "},{"title":"培训心得 [JavaScript BOM与DOM]","date":"2022-07-12T12:24:53.000Z","url":"/2022/07/12/xianTrain7-JSBomDom/","categories":[["XiAnTrain","/categories/XiAnTrain/"]],"content":"&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;学习打卡第嗯-2天 BOM (borwser object Model)浏览器对象模型 使用对象描述浏览器的各个部分 BOM提供与浏览器窗口交互的对象 BOM主要用于管理窗口与窗口之间的通讯，所以核心对象是窗口(window) BOM中有什么 图示 与浏览器进行交互的一些对象 移动,调整浏览器大小的window对象 用于导航的location对象history 获取浏览器,用户屏幕信息的navigator与screen对象 window对象 open()方法用于打开一个新窗口或查找一个窗口 window.open(url,name,feature,replace) 案例： 窗口特性表 setlnterval()每秒指定的毫秒运行指定的代码、函数 setTimeout()经过指定毫秒数运行一次指定的代码 location地址对象 href:设置或获取整个URL为字符串 reload():重新加载 replace():用新文档替换当前文档 屏幕对象（Screen）用来获取电脑屏幕的一些数据 avaiHeight:获取系统屏幕的工作高度（浏览器的页面高度） availWidth：获取系统屏幕的工作区宽度（浏览器页面宽度） height：获取屏幕的垂直分辨率 width：获取屏幕的水平分辨率 DOM编程文档对象模型(doucment) 当一个HTML页面加载到浏览器的时候，那么浏览器会为每个标签都创建一个对应的对象，描述该标签的所有信息。 我们此时所看到的网页信息实际上就是看到了这些标签的对象信息，如果我们需要操作页面的数据，我们就可以通过这些标签对象进行操作 用来获取页面节点的方法 获取也页面的所有节点：document.all nodeName:节点名字 通过标签获取节点（返回一个数组） doucment.getElementsByTagName(标签名); 通过标签的Name属性获取节点 doucment.getElementByName(&quot;标签的name属性&quot;) 通过关系找节点 parentNode：获取当前元素的父节点 childNodes：获取当前元素的所有下一级子元素 firstChild:获取当前节点的第一个子节点 lastChild：获取当前节点的最后一个字节点 nextElementSibling：获取当前节点的下一个节点（兄弟节点） previousElementSibling：获取当前节点的上一个节点（兄弟节点） nodeType：获取节点类型 创建，删除，插入节点 创建：var 节点 = document.creatElement(“标签名”);创建新元素节点 节点 .setAttribute(“属性名”,”属性值”); 节点.appendChild(e);将某个节点添加到该节点的最后位置 节点.insertBefore(e,child);将某个新节点添加到该节点中，某个子节点之前 节点.removeChild(要删除的子节点)；删除指定的直接点 节点必须为直接父节点 利用节点操作css 我们可以通过上边获取节点的方式获取到节点，我们可以通过节点对象去操作标签的的样式 节点.style.要操作的样式=”值”; JavaScript中常用的事件 点击事件（onclick） 鼠标进入事件（onmouseover(),onmousemove()） 鼠标离开事件（onmouseout()) 获取焦点（onfocus()） 失去焦点（onblur()） 滚动事件(onscroll()) 键盘按下并松开（onkeypress()） 键盘按下事件（onkeydown()） 键盘抬起事件（onkeyup()） keyCode获取按下的键 onmousedown / onmouseup 鼠标按下/抬起事件 当鼠标左键或右键按下或者抬起的时候触发 按下或抬起滚动轮也会触发，滑动滚动轮不能触发 如果鼠标比较高级，有其他按键的情况下，按下或抬起也会触发 "},{"title":"培训心得 [动画]","date":"2022-07-08T11:05:14.000Z","url":"/2022/07/08/xianTrain6-animation/","categories":[["XiAnTrain","/categories/XiAnTrain/"]],"content":"&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;学习打卡第嗯-2天 CSS动画是W3C于2009年发布3D变形动画（标准草案），在年底发布了2D变形动画浏览器支持使用代码形成网页动画，并且有些浏览器在添加时为了更好的兼容性，需要添加浏览器引擎的私有属性 谷歌：-webkit- 火狐：-moz- IE9：-ms- 其它一些浏览器不需要添加这些私有属性 CSS 2D动画● 2D动画可以用于元素的旋转、缩放、位移等● 基本语法transform-function:none|transfrom-functionnone:默认值transfrom-function:变形函数（可以是一个，也可以是多个函数列表）函数是以（）结尾● 常见的变形函数&emsp;○ translate(左值，上值):移动元素&emsp;○ scale宽度放大倍数,高度放大倍数):元素缩放，可以是任意尺寸发生变形&emsp;○ rotate:旋转元素，去一个度数值，度数后缀为deg(当度数为正时为顺时针旋转，为负时为逆时针旋转)&emsp;○ skew（Y轴角度，X轴角度）:元素斜切，取度数值让元素发生形状的变化 例：简单照片墙 过渡● 过渡是元素从一种样式逐渐改变成另一种样式● 语法 自定义动画属性 &emsp;&emsp;&emsp;说明&emsp; &emsp;&emsp;初始值animation&emsp;&emsp; 包含所有属性animation-name&emsp; 动画名称&emsp;&emsp; noneanimation-duration&emsp; 动画时间 &emsp;&emsp;0animation-timing-function 动画播放方式&emsp; easeanimation-iteration-count 动画播放的次数&emsp; 1，infinite为重复播放 从开始到结束以相同的速度播放动画:animation-timing-function:linear;-webkit-animation-timing-function:linear; /* Safari and Chrome */ 制作动画需要一下两个步骤：&emsp;○ 第一步：需要在样式表中添加动画过程属性 &emsp;○ 第二步：将制作好的动画通过animation引入给标签使用 光盘旋转效果 3D旋转相册"},{"title":"培训心得 [javaScript基础]","date":"2022-07-07T12:07:24.000Z","url":"/2022/07/07/xianTrain5-jsBasics/","categories":[["XiAnTrain","/categories/XiAnTrain/"]],"content":"&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;学习打卡第嗯-1天 概述javascript是一种属于网络的脚本语言，用于web应用开发，来为网页添加动态的功能，来为用户提供更流畅的浏览效果。 ● 是一种解释性脚本语言（代码不进行预编译）。● 主要用来向HTML（标准通用标记语言下的一个应用）页面添加交互行为。● 可以直接嵌入HTML页面，但写成单独的js文件有利于结构和行为的分离。● 跨平台特性，在绝大多数浏览器的支持下，可以在多种平台下运行（如Windows、Linux、Mac、Android、iOS等）。Javascript脚本语言同其他语言一样，有它自身的基本数据类型，表达式和算术运算符及程序的基本程序框架。Javascript提供了四种基本的数据类型和两种特殊数据类型用来处理数据和文字。而变量提供存放信息的地方，表达式则可以完成较复杂的信息处理 JavaScript能做什么● 使网页具有交互性，例如响应用户点击，给用户提供更好的体验● 可以处理表单，检验用户的输入，并提供及时反馈节省用户时间。例如，表单中要你输入电子邮箱而你却输入一个手机号，那么应该给你一个提醒。● 还可以根据用户的操作，动态的创建页面。例如，发邮件时，添加附件操作。● 设置cookie，cookie是存储在浏览器上的一些临时信息，例如你浏览过的网站地址，使用过的用户名● JavaScript 是有规律地重复的HTML元素简化，减少下载时间。● 浏览器与服务器进行数据通讯，比如现在最流行的Ajax异步传输； JavaScript构成● JavaScript由以下三部分组成： ○ ECMAScript，它用来描述语法和基本对象 ○ 文档对象模型Doucment Object Model（DOM），用来处理网页内容 ○ 浏览器对象模型Borwser Object Model（BOM），用来处理浏览器交互 JavaScript的开发环境与运行环境● JavaScript为轻型脚本语言，可在任意文本编辑器中编辑● 由于JavaScript是内嵌在HTML中执行，所以其运行环境即浏览器 JavaScript的使用● JavaScript需在HTML中内嵌运行，其内嵌方式有两种： ○ 在网页中创建&lt;script&gt;&lt;/script&gt;,在标签之间写JavaScript代码 ○ 在外部创建“.js”文件，通过&lt;script src=&quot;文件路径&quot;&gt;引入到HTML文件中执行 javascript基础值 ○ 数字类型的值(数字) ○ 算术值(加减乘除等与运算,需要两个或两个以上的数字) ○ 特殊数字(三种) infinity:表示正无穷大 -infinity:负无穷大 NaN:不是数字,不正当的算数运算得到不正当的值(0/0) ○字符串(用于表示文本,使用引号引起来即可) 注: 在引号中添加特殊字符时比较难加，但是只需要添加反引号” &quot;就可解决这个问题(console.log(hello my “son”`);) 转义字符(\\) 出现在引用文本中,表示后面有特殊字符 ○ 换行符(\\n) ○ 制表符(\\t) ○ 如果希望字符串中的斜杠只是斜杠，可以使用两个斜杠 运算符 一元运算符：有单词构成的符号 如（typeof） 布尔值 ○ 比较运算符(&gt;,&lt;,&lt;=,&gt;=….) [比较运算符属于二元运算符] ○ 逻辑运算符（与&amp;&amp;，或||，非!） &amp;&amp;:表示逻辑与，表示结果为真才为真 ||：表示逻辑或，表示一个为真，则为真 !：表示逻辑非，表示取反注：||具有最低优先级，然后时&amp;&amp;，然后是比较运算符，再然后时其他运算符 ○ 三元运算符，由问号和冒号写成 (ture?1:2) 空值 使用null和undefined表示空值 注： ○ Undefined表示变量不含值 ○ Null可以通过将变量的值设置为Null来清空变量 自动类型转换 表达式 例：console.log(1+1); 绑定（变量） 注：1.var全称(variable)表示变量，多用于以前得JavaScript中声明绑定2.const全称（constant），表示定义一个常量绑定，只要它存在，它就一直指向相同得值 分号 ○ 分号用于分隔JavaScript语句 ○ 通常我们在每条可执行的语句结尾添加分号，代表作一句JavaScript语句的结束 ○ 使用分号的另一个好处就是。。。。能在一行多写点代码嘛 JavaScript代码 ○ JavaScript代码是JavaScript语句的序列 ○ 浏览器按照编写顺序依次执行每条语句 JavaScript代码块 ○ JavaScript可以分批地组合起来 ○ 代码块以左花括号开始，以右花括号结束 ○ 代码块的作用是一并执行语句序列 JavaScript语句标识符 ○ JavaScript语句通常以一个语句标识符为开始，并执行该语句。 ○ 语句标识符是保留关键字不能作为变量名使用 ○ JavaScript语句标识符（关键字） JavaScript数据类型数据类型 具体描述number 能存储整数和小数类型string 用单引号或双引号来声明的字符串boolean 只能是两个值选择：true、falseundefined 变量被声明后，但未被赋值object javascript中的对象、数组和null ○ 在JavaScript中可以使用typeof()函数来检查变量的返回值类型 ○ javaScript拥有动态类型，相同变量可用作不同的类型 ○ 当声明新变量时，可以使用关键词“new”来声明其类型实例： 数组 数组对象是使用单独的变量名来存储一系列不相同类型的值 ○ 创建数组，不同的方式： 常规方式： 简洁方式： 字面方式： ○ 数组访问 语法：数组名[下标] arr[] [0]表示第一个元素 在一个数组可以有不同的对象 ○ 数据方法和属性 --用数组的元素组合字符串-join() arrayObject.join(separator) separator：指定要使用的分隔符，如果省略改参数，则使用逗号作为分隔符 –数组排序（按字母顺序升序）-sort() –数组排序（按字母顺序降序）-sort(function(a,b){return a-b}) –数组排序（按字母顺序降序）-sort(function(a,b){return b-a)} index: 必需。规定从何处添加/删除元素。该参数是开始插入和(或)删除的数组元素的下标，必需是数字哦 howmant: 必需。规定应该删除多少元素。必须是数字，但可以是（0）。如果未规定此参数，则删除从index开始到原数组结尾的所有元素 element1: 可选。规定要添加到数组的新元素。从index所指的下标处开始插入 elementN: 可选。可向数组添加若干元素。 返回值： 如果次年arrayObject中删除了元素，则返回的是含有被删除的元素的数组 --转换数组到字符串-toString() --在数组开头添加新的元素-unshift() javaScript对象 ● 对象属性 ○ JavaScript对象是变量的容器 ○ JavaScript对象是键值对的容器 ○ 键值对的基本写法为name:value（上边的例子就是喽） ○ 键值对在JavaScript对象中统称为对象属性。 ○ 访问对象属性 ■ 可以用对象名点属性（如：person.one） ■ 也可以用对象名[“属性”]（如：person[“one”]） ● 对象方法 ○ 对象的方法定义了一个函数，并作为对象的属性存储 ○ 对象方法通过添加()调用（当成函数调用） ○ 下边的这个例子访问了person对象的all()方法（如果直接访问person对象的all属性，它将作为定义一个函数的字符串返回，也就是说把后边的代码直接返回，并且打印出来） ■ 访问方法（例：person.all()） ■ 访问属性（例：person.all）"},{"title":"培训心得 [javaScript对象]","date":"2022-07-07T11:58:17.000Z","url":"/2022/07/07/xianTrain4-jsObject/","categories":[["XiAnTrain","/categories/XiAnTrain/"]],"content":"&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;学习打卡第嗯天 1、什么是对象？ 2、认识对象 3、属性的类型（两种） 4、访问器属性 5、对象合并 6、增强对象语法 "},{"title":"培训心得&emsp;&emsp;[HTML5]","date":"2022-06-30T12:40:38.000Z","url":"/2022/06/30/xianTrain3/","categories":[["XiAnTrain","/categories/XiAnTrain/"]],"content":"&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;学习打卡第三天学习链接： 3.1新增元素3.1.1 新增的结构元素● &lt;section&gt;元素&lt;section&gt;元素表示页面中的内容区块，如：页眉，页脚，章节等部分代码： ● &lt;article&gt;元素&lt;article&gt;元素表示页面中的一块与上下文不相关的独立内容，如：新闻页中诸多文章中的某篇文章代码： ● &lt;aside&gt;元素&lt;aside&gt;表示&lt;article&gt;元素的内容之外的，它的内容应该与附近内容相关代码： html> ● &lt;header&gt;元素&lt;header&gt;元素表示页面中的一个内容块或整个页面的标题代码： ● &lt;footer&gt;元素&lt;footer&gt;元素表示整个页面或页面中一个区域内的脚注，一般包含作者的基本信息代码： ● &lt;nav&gt;元素&lt;nav&gt;元素通常在内嵌套&lt;a&gt;标签表示页面的导航链接部分代码： ● &lt;video&gt;元素 ○ &lt;video&gt;元素用来插入视频 ○ &lt;video&gt;元素仅支持MP4，WebM，Ogg视频格式 ○ 元素属性表： ● &lt;audio&gt;元素 ○ &lt;audio&gt;元素用来插入音频 ○ &lt;audio&gt;元素仅支持Ogg和MP3格式 ○ 元素属性表 ● &lt;mark&gt;元素&lt;mark&gt;元素主要用来在视觉上向用户呈现哪些需要突出显示或高亮显示的文字，一般用在搜索结果中向用户高亮显示搜索关键词代码： ● &lt;ruby&gt;元素&lt;ruby&gt;表示中文注音或字符 ● &lt;rt&gt;元素&lt;rt&gt;元素与&lt;ruby&gt;配合使用用来解释或发音 ● &lt;rp&gt;元素&lt;rp&gt;元素与&lt;ruby&gt;一起使用，以定义不支持&lt;ruby&gt;元素的浏览器显示内容，以括号的形式出现如：汉字(Han Zi)代码： ● &lt;details&gt;元素&lt;details&gt;元素表示用户要求得到的细节信息，与&lt;summary&gt;配合使用，&lt;summary&gt;提供标题或图例，用户点击标题时，会显示户细节信息，&lt;summary&gt;元素应该是&lt;details&gt;元素的第一个元素代码： 3.2 全局属性3.2.1 contentEditable属性contentEditable属性由微软开发并被其它浏览器反编译投入引用的一个全局属性，该属性允许用户编辑元素内容，该属性是一个布尔值的属性，可以被指定false或true该属性默认inherit（继承）状态，属性为true时，元素被指定为允许编辑；属性为false时，元素被指定为不允许编辑状态；未指定值时，则由inherit状态决定，如果父元素是可编辑元素，则该元素也可编辑在编辑完成后，如果想要保存其中的内容，只能把该元素的innerHTML发送到服务器端进行保存，目前还没有特别的API来保存编辑后的元素内容代码： 3.2.2 designMode属性designModel属性用来指定整个页面是否可编辑，当页面可编辑时，页面中任何支持contenteditable属性的元素都变成可编辑状态。该属性只能在JavaScript脚本里被编辑修改，该属性有两个值 “on”或“off”，当属性被指定为“on”时，页面为可编辑状态，为“off”时，页面不可编辑代码： 3.2.3 hidden属性在HTML 5中，所有的元素都允许使用一个hidden属性。该属性类似于input元素中的 hidden元素，功能是通知浏览器不渲染该元素。使该元素处干不可见状态。但是元素中的内容还是浏览器创建的，也就是说页面装载后允许使用JavaScript脚本将该属性取消，取消后该元素变为可见状态，同时元素中的内容也即时显示出来。Hidden属性是一个布尔值的属性。当设为true时，元素处于不可见状态;当设为false时，元素处于可见状态"},{"title":"培训心得&emsp;&emsp;[表单]","date":"2022-06-29T00:40:56.000Z","url":"/2022/06/29/XiAnTrain20220628/","categories":[["XiAnTrain","/categories/XiAnTrain/"]],"content":"&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;学习打卡第二天学习链接： 第二章 表单表单是用来显示，收集，提交用户信息，表单在网页中主要负责数据采集功能，一个表单由三个基本部分组成：表单元素、表单域、按钮 2.1表单表单是一个包含表单元素的区域，使用&lt;form&gt;...&lt;/form&gt;定义，通过在表单中添加对应的表单元素使得用户可以在网页上输入数据&lt;form&gt;中含有诸多属性用来规定表单的格式，详见下表 2.2 表单元素2.2.1 输入标签多数情况下使用的表单元素是输入标签&lt;input&gt;元素内输入类型有标签中的type属性定义，常用的元素类型如下表： 2.2.2 下拉标签● &lt;select&gt;元素为表单控件，用于在表单中接收数据 ○ &lt;select&gt;元素可创建单选或多选菜单 ○ &lt;option&gt;标签定义了菜单中的可选项● 下拉列表支持属性 2.2.3 按钮● 按钮在网页中一般用于提交，重置页面数据，也可以与javascript配置做一些交互响应事件● 在HTML中按钮一般使用&lt;input&gt;或&lt;button&gt;来定义● 按钮属性 ● &lt;button&gt;与&lt;input&gt;按钮区别 ○ &lt;button&gt;按钮如果不设置type属性，在不同浏览器中可能会提交不同值 ○ &lt;button&gt;按钮是成对出现的，可放置文本，图像等，&lt;input&gt;标签只能通过value属性为其设置文本 ○ 需要注意的是虽然&lt;button&gt;按钮可以嵌套其它标签，但不能再去嵌套按钮示例 2.3 HTML5 表单增强2.3.1 form属性在HTML4中，表单内的从属元素必须书写在表单内部，但在HTML5中，可以把它书写在页面的任意地方，然后给该元素指定一个form属性，属性值为该表单的id，这样就可以声明该元素从属于指定的表单示例 代码解析： 第一个input标签从属form表单，它被书写在form表单内部，所以用不着对它指定form属性 第二个input表单被书写在form之外，但想要它从属form，这时就可以为其添加form属性并指定表单id让它从属form表单2.3.2 formaction属性在HTML 4中，一个表单内的所有元素都只能通过表单的action属性统一提交到另一个页面，而在HTML 5中可以给所有的提交按钮，诸如&lt;input type=&quot;submit&quot;&gt;、&lt;inputtype=&quot;image&quot;&gt;、&lt;button type=&quot;submit&quot;&gt;都增加不同的formaction属性，使得点击不同的按钮，可以将表单提交到不同的页面，formaction属性的使用方法如下： 注：该属性目前支持的浏览器并不多，慎重使用2.3.3 list属性在HTML 5中，为单行文本框(&lt;input type=&quot;text&quot;&gt;)增加了一个list属性，该属性的值为某个datalist元素的id。datalist元素也是HTML 5中新增元素，该元素类似于选择框( select&gt;)，但是当用户想要设定的值不在选择列表之内时，允许其自行输入。该元素本身并不显示，而是当文本框获得焦点时以提示输入的方式显示。为了避免在没有支持该元素的浏览器上出现显示错误，可以用CSS等将它设定为不显示。示例 2.3.4 autocomplete属性辅助输入所用的自动完成功能，是一个节省输入时间，同时也十分方便的功能。在HTML5之前，因为谁都可以看见输入的值，所以存在安全隐患，但只要使用autocomplete属性，安全性就可以得到很好的控制。.对于autocomplete属性，可以指定“on”、“off”与“”(不指定）这三种值。不指定时，使用浏览器的默认值(取决于各浏览器的决定)。把该属性设为on时，可以显式指定候补输入的数据列表。使用detalist元素与list属性提供候补输入的数据列表，自动完成时，可以将该datalist元素中的数据作为候补输入的数据在文本框中自动显示。autocomplete属性的使用方法如下所示。 2.3.5 output标签● output为H5的新增标签，用来定义不同类型的输出，长和form表单一起使用，用来输出显示计算结果● 语法 ● 标签属性 ○ for：定义输出域相关的一个或多个元素，以空格隔开； ○ form：定义输入字段所属的一个或多个表单，以空格隔开； ○ name：定义对象的唯一名称（表单提交时使用）。示例 示例二 注：oninput为表单事件，表示当对元素输入数据时触发parseInt为javascript函数，用来解析一个字符串，并返回一个整数 2.3.6 表单验证在H5中，新增了大量在提交时对表单与表单内新增元素进行有效性验证的功能 2.3.6.1 自动验证在H5中，新增的一些表单元素本身就带有简单的提交格式验证，如邮箱（email）就有固定的格式“@”，“.”，但普通的表单元素就要通过对元素使用属性的方法，来实现在表单提交时执行自动验证的功能普通表单元素的验证属性 required属性HTML 5中新增的required属性可以应用在大多数输入元素上（除了隐藏元素、图片元素按钮上)。在提交时，如果元素中内容为空白，则不允许提交，同时在浏览器中显示信息提示文字，提示用户这个元素中必须输入内容。 pattern属性之前提到的一些新增的input元素，譬如email、number、url等，要求输入内容符合–定的格式，对input元素使用pattern属性，并且将属性值设为某个格式的正则表达式，在提交时会检查其内容是否符合给定格式。当输入的内容不符合给定格式时，则不允许提交，同时在浏览器中显示信息提示文字，提示输入的内容必须符合给定格式。譬如下面所示，要求输入内容为三个大写字母。 min属性与max属性min与max这两个属性是数值类型或日期类型的input元素的专用属性，它们限制了在input元素中输入的数值与日期的范围。 "},{"title":"培训心得&emsp;&emsp;[走进HTML]","date":"2022-06-27T12:40:38.000Z","url":"/2022/06/27/XiAnTrain20220627/","categories":[["XiAnTrain","/categories/XiAnTrain/"]],"content":"&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;学习打卡第一天学习链接： 1. 1HTML简介&emsp;&emsp;&emsp;HTML的英文全称是 Hyper Text Markup Language，即超文本标记语言。HTML是由Web的发明者 Tim Berners-Lee和同事 Daniel W. Connolly于1990年创立的一种标记语言，它是标准通用化标记语言SGML的应用。用HTML编写的超文本文档称为HTML文档，它能独立于各种操作系统平台(如UNIX， Windows等)。使用HTML，将所需要表达的信息按某种规则写成HTML文件，通过专用的浏览器来识别，并将这些HTML文件“翻译”成可以识别的信息，即现在所见到的网页。&emsp;&emsp;&emsp;自1990年以来，HTML就一直被用作万维网的信息表示语言，使用HTML描述的文件需要通过web浏览器显示出效果。HTML是一种建立网页文件的语言，通过标记式的指令(Tag)，将影像、声音、图片、文字动画、影视等内容显示出来。事实上，每一个HTML文档都是一种静态的网页文件，这个文件里面包含了HTML指令代码，这些指令代码并不是一种程序语言，只是一种排版网页中资料显示位置的标记结构语言，易学易懂，非常简单。HTML的普遍应用就是带来了超文本的技术―通过单击鼠标从一个主题跳转到另一个主题，从一个页面跳转到另一个页面，与世界各地主机的文件链接超文本传输协议规定了浏览器在运行HTML文档时所遵循的规则和进行的操作。HTTP的制定使浏览器在运行超文本时有了统一的规则和标准。&emsp;&emsp;&emsp;万维网（world wide web，简称www）上的一个超媒体文档称之为一个页面（外语：page）。作为一个组织或者个人在万维网上放置开始点的页面称为主页（外语：Homepage）或首页，主页中通常包括有指向其他相关页面或其他节点的指针（超级链接），所谓超级链接，就是一种统一资源定位器（Uniform Resource Locator，外语缩写：URL）指针，通过激活（点击）它，可使浏览器方便地获取新的网页。这也是HTML获得广泛应用的最重要的原因之一。在逻辑上将视为一个整体的一系列页面的有机集合称为网站（Website或Site）。超文本标记语言（英文缩写：HTML）是为“网页创建和其它可在网页浏览器中看到的信息”设计的一种标记语言。&emsp;&emsp;&emsp;网页的本质就是超文本标记语言，通过结合使用其他的Web技术（如：脚本语言、公共网关接口、组件等），可以创造出功能强大的网页。因而，超文本标记语言是万维网（Web）编程的基础，也就是说万维网是建立在超文本基础之上的。超文本标记语言之所以称为超文本标记语言，是因为文本中包含了所谓“超级链接”点。 1.2 HTML版本&emsp;&emsp;&emsp;HTML是用来标记Web信息如何展示以及其他特性的一种语法规则，它最初于1989年由CERN的Tim Berners-Lee发明。HTML基于更古老一些的语言SGML定义，并简化了其中的语言元素。这些元素用于告诉浏览器如何在用户的屏幕上展示数据，所以很早就得到各个Web浏览器厂商的支持。 [5]HTML历史上有如下版本： [5]①HTML 1.0：在1993年6月作为互联网工程工作小组(IETF)工作草案发布。②HTML 2.0：1995年1 1月作为RFC 1866发布，于2000年6月发布之后被宣布已经过时。③HTML 3.2：1997年1月14日，W3C推荐标准。④HTML 4.0：1997年12月18日，W3C推荐标准。⑤HTML 4.01（微小改进）：1999年12月24日，W3C推荐标准。⑥HTML 5：HTML5是公认的下一代Web语言，极大地提升了Web在富媒体、富内容和富应用等方面的能力，被喻为终将改变移动互联网的重要推手。Internet Explorer 8及以前的版本不支持。 1.3 迎接新的Web时代&emsp;&emsp;&emsp;HTML5并不是革命性的改变，而只是发展性的。而且对于之前HTML4的很多标准都是兼容的，所有通过最新HTML5标准制作的Web应用也可以轻松的在老版本的浏览器上运行。HTML5标准中的确是集成了很多实用的功能比如：音视频、本地存储、Socket通信、动画等都是之前应用开发中确实感觉到Web端的鸡肋才得到重视和升级的。HTML5的目标是：它通过一些新标签，新功能为开发更加简、独立、标准的通用Web应用提供了标准。新的标准解决了三大问题：浏览器兼容问题，解决了文档结构不明确的问题，解决了Web应用程序功能受限等问题。号称“CSS之父”的Hakon Wium Lie认为，HTML5与CSS3将是全球互联网发展的未来趋势。自从2010年HTML5正式推出以来，它就以一种惊人的速度被迅速推广使用，微软也因此在IE上做了关于HTML5的标准改进，使其能够支持HTML5，google Chrome，Safari，Opera，Mozilla等主要Web浏览器也针对HTML5制定了相应的支持措施。目前主流的浏览器厂商也纷纷在研发HTML5相关产品，从目前这些浏览器对HTML5的支持来看，Web的未来属于HTML5 1.4 HTML的开发环境和运行环境&emsp;&emsp;&emsp;HTML本质上就是一个文档，市面上常见的一些简单的文本编辑器都是可以用来开发HTML，编辑之后只需将后缀修改为”.html”即可 如：记事本，EditPlus等&emsp;&emsp;&emsp;前端开发也有众多专业的开发软件，如：Webstrom，Sublime Text，Dreamweaver，HBuilder等，本书主要以webstrom为主要开发软件HTML运行环境即各种浏览器，如:IE，edge，Chrome，Firefox，Safari等均可作为HTML的运行环境 1.5 HTML文档结构HTML文档有明确的文档结构，包含三个部分：&lt;HTML&gt;中包含&lt;head&gt;...&lt;/head&gt;部分和&lt;body&gt;...&lt;/body&gt;部分 1.6 Hello World1. 创建html文件，并键入如下代码： 2. 运行结果1.7 标签● *&lt;meta&gt;标签位于&lt;head&gt;*标签区域内提供了HTML的文档元数据（注：元数据是数据的数据信息且元数据不会显示在客户端，但是会被浏览器解析）● *&lt;meta&gt;*标签提供了文档的字符集，使用语言，作者等基本信息，此外还涉及关键词和网页等级设定● *&lt;meta&gt;*标签常用属性表| 属性 | 值 | 描述 || — | — | — || charset | character_set | 定义文档的字符编码。|| content | text | 定义与 http-equiv 或 name 属性相关的元信息。|| http-equiv | content-typ edefault-style refresh | 把 content 属性关联到 HTTP 头部。| |name| application-nameauthordescriptiongeneratorkeywords| 把 content 属性关联到一个名称。| |scheme| format/URI | HTML5不支持。定义用于翻译 content 属性值的格式。| 代码： 1.8 元素&emsp;&emsp;&emsp;HTML文档由HTML元素定义，一个基本元素由“开始标签”，“元素内容”，“结束标签”构成&lt;开始标签&gt; 元素内容 &lt;/结束标签&gt;HTML元素以开始标签起始 元素内容即开始标签和结束标签之间的内容 HTML元素以结束标签终结 1.9 块级标签和行级标签HTML中，所有标签都是预定义的，也就是说所有的标签都有各自的特点属性，根据这些特点可将标签分为块级标签和行级标签两类 1.9.1 块级标签块级标签编译后在浏览器中默认没有高度，其高度由其添加的内容决定，其宽度默认为屏幕宽度，也就是说块级标签默认占一行 1.9.2 行级标签行级标签编译后在浏览器中默认没有宽度和高度，其宽高均有添加的内容决定，也就是说行级标签在其内容不满一行时不会换行 1.10 HTML常用标签1.10.1 常用的块级标签● 标题标签 ○ 标题（Heading）通过&lt;h1&gt;....&lt;h6&gt;标签定义，表示一级标题至六级标题，其中&lt;h1&gt;最大，&lt;h6&gt;最小 ○ 标题标签只用于标题 ○ 标题标签不单单用于字体放大加粗，更多的是为搜索引擎使用标题帮助网页索引 代码： ● 段落标签 ○ 段落通过&lt;p&gt;...&lt;/p&gt;标签定义，表示文档中的一个自然段 ○ 注：段落标签不能嵌套使用，若想要段落标签中的内容换行显示可使用&lt;br/&gt;标签换行代码 ● div标签 ○ div标签用于定义文档中的分区或节 ○ 可以把文档分割为独立的，不同的部分 ○ 在后期通过学习样式表，div可以与CSS配合对整个网页进行页面布局，模块划分，让网页制作不再有难度 ○ div若不带样式单独使用则与段落标签&lt;p&gt;相似，没有特定的含义代码 ● 无序列表 ○ 列表可以结合链接标签用来定义新闻标题等一些较为常用的标题类链接 ○ 无序列表使用定义列表，定义列表中的条目，默认此列项目使用黑色小圆点进行标记 ○ 通过在中添加type属性更改列表的展示标记，其中disc表示实心圆，square表示矩形显示，circle表示空心圆代码： ● 有序列表 ○ 有序列表使用定义列表，定义列表中的条目，默认此列项目使用阿拉伯数字进行标记 ○ 通过在中添加type属性更改列表的展示标记，其中‘A’表示大写字母，‘a’表示小写字母，‘I’表示大写罗马数字，‘i’表示小写罗马数字，‘1’表示阿拉伯数字（默认）代码： ● 自定义列表 ○ 使用定义列表，定义列表中的项目，定义列表条目 ○ 自定义列表不单单只用了区分项目，后期通过样式，标签嵌套可以胜任诸多任务，如：商城，外卖类网站商品的模块划分代码： ● 嵌套列表 ○ 列表可以通过多层嵌套实现多级列表代码： 1.10.2 常用的行级标签 ● 内联元素 ○ 使用…表示 ○ 单独使用没有特定的含义 ○ 当与CSS一同使用，用来组合文档中的行内元素，如：在一行文字中给某一个字单独设置样式，再或者在某行字中添加小图标代码： ● 链接标签 ○ 使用…表示 ○ 用于从一个页面跳转到另一个页面 ○ href表示跳转的链接目标 ○ 默认情况下链接将以以下形式出现在网页中 ■ 在未点击访问时链接字体程蓝色并带同色下划线 ■ 在点击后链接字体会程红色显示并带同色下划线 ○ 标签常用属性属性 属性值 作用download filename 指定下载链接href URL 规定链接目标target _blank_parent_self_top _blank：新窗口打开。_parent：在父窗口中打开链接。_self：默认，当前页面跳转。_top：在当前窗体打开链接，并替换当前的整个窗体(框架页)。 ○ 在网页开发中常用的链接有以下四种：链接分类 属性参数 作用空链接 href=”#”href=”javascript:void(0)” 空链接即只能点击不会做页面跳转的链接，用于向页面上添加对象或行为 如：设为首页，添加收藏等本地链接 href=”本地路径” 用于本地工程/服务器页面之间的相互跳转网络链接 herf=”url” 用于给网站添加外部链接，点击后跳转到其它网站锚链接 href=”#name” 用于添加页面内快速引导，可以从页面的一个位置快速的转到另一个位置空链接示例代码： 附：空链接“#”与“javascript:void(0)”的区别： “#”包含一个位置信息，默认为网页顶端，当页面高度大于一屏时，点击后会跳转到网页顶部 “javascript:void(0)”是一个伪协议，表示url内容通过javascript执行，而void(0)则表示不作任何操作，这样该标签既保留了链接样式还能防止页面跳转 空链接通常通过添加javascript事件去做一些其它操作，如：设置收藏，设置首页，弹窗等，这些会在本书javascript事件章节详细讲解 本地链接示例代码： 附：绝对路径和相对路径绝对路径：是指文件在硬盘上的真正存在的路径，如：一张名为“头像.jpg”的图片或一个名为“index.html”的网页存放在我计算机中的“C:\\Users\\document\\WebstormProjects\\untitled15”目录中，则图片的绝对路径为“C:\\Users\\document\\WebstormProjects\\untitled15\\头像.jpg”，网页的绝对路径为“C:\\Users\\document\\WebstormProjects\\untitled15\\index.html”，但在开发时很少使用绝对路径，当指定了决定路径后在项目路径在本地计算机上是没问题的，但上传到服务器或在其它计算机上时很可能会出现找不到路径，路径错误等问题。相对路径：指由文件本身相对于目标文件的路径，使用相对路径的三种写法，下边以网页index.html引用网页Login.html为例说明：1.若Login.html相对index.html是在同一目录，那么网页在引用图片时则只需要通过Login.html名称+后缀引用即可位置关系图示 代码示例 位置关系图示 代码示例 3.若网页index.html和网页Login.html都存在不同的文件夹中，两个不同的文件夹属于同一目录，那么网页index.html在引用网页Login.html时则需要通过“../”返回上一级路径再去引用存放网页Login.html的文件夹再使用分隔符“/”引用网页Login.html，这里需要注意一个“../”，表示网上返回一级，如果要返回多个则需要使用多个“../”位置关系图示 代码示例 网络链接示例代码： 锚链接示例代码： 附： 锚链接是在页面内的不同位置跳转，本质上就是元素间的跳转 使用锚链接首先要建立锚点目标，只需要给元素添加id或name属性即可 如：&lt;a name=&quot;top&quot;&gt;,&lt;div id=&quot;top&quot;&gt; 建立好锚点目标后再使用&lt;a href=&quot;#id值或name值&quot;&gt;引用锚点 如果不同页面跳转，同时存在锚点，则先跳转到要跳转的页面，然后在寻找锚点元素进行跳转 ● 图片标签 ○ 图片标签使用&lt;img/&gt;表示，图片标签没有结束标签“/”表示结束 ○ 标签属性属性 属性值 作用src（必需） url 图片路径或网络地址title text 图片标题描述，当鼠标悬停在图片上时显示alt text 图片替换文本，当图片路径发生错误时显示width pixels 图片宽度height pixels 图片高度代码： ● 图片增强（map） ○ &lt;map&gt;标签有助于定义图像映射。图像映射指的是图像中包含一个或多个可点击区域。&lt;map&gt;标签与&lt;area&gt;标签一起确定可点击区域。可点击区域可以是矩形、圆形或多边形区域这些形状之一。如果不指定形状，就会认为是整个图像。示例 知识补充： ○ &lt;area&gt;标签定义图像映射中的区域 ○ shape属性 ■ shape属性用于定义图像映射中对鼠标敏感的区域的形状 ● 圆形（circ或circle） ● 多边形（poly或polygon） ● 矩形（rect或rectangle） ○ coords属性 ■ 圆形：shape=”circle”，coords=”x,y,z”这里的 x 和 y 定义了圆心的位置（”0,0” 是图像左上角的坐标），z 是以像素为单位的圆形半径。 ■ 多边形：shape=”polygon”，coords=”x1,y1,x2,y2,x3,y3,…”每一对 “x,y” 坐标都定义了多边形的一个顶点（”0,0” 是图像左上角的坐标）。定义三角形至少需要三组坐标；高纬多边形则需要更多数量的顶点。多边形会自动封闭，因此在列表的结尾不需要重复第一个坐标来闭合整个区域。 ■ 矩形：shape=”rectangle”，coords=”x1,y1,x2,y2”第一个坐标是矩形的一个角的顶点坐标，另一对坐标是对角的顶点坐标，”0,0” 是图像左上角的坐标。请注意，定义矩形实际上是定义带有四个顶点的多边形的一种简化方法。● 常用文本格式化标签标签 描述 代码： 学习心得今天是到这的第一天，一起都充满着好奇。下午老师就开始讲HTML相关内容，因为之前学过目前还算很好理解。听课老师说越到后面学习越困难，不过没事到这就是来学习的，为了能找到更好的工作在所不辞。由于报道的有点迟了，到现在还没求去过宿舍，不知道宿舍的环境怎么样，很是期待。西安相对于甘肃还是很热的，幸好学习的地方都用空调，不然像静下心来学习都是问题。在接下载的几个月中弥补之前的不足，学习更多的知识，向向往的的工作不断迈进。"},{"title":"基于SSM框架的电⼦书城项⽬开发笔记","date":"2022-04-23T13:29:18.000Z","url":"/2022/04/23/SSMknowledge/","categories":[["undefined",""]],"content":" 电⼦书城项⽬开发笔记⼀、项⽬简介电⼦书城项⽬的基本实现的要求与技术指标。系统的功能结构：前端部分：⽤户操作⽤户的⼀些基本操作以及相关的购买⾏为的实现图书浏览按类别浏览图书信息、根据图书的名称搜索相关的图书后端部分：商品管理、销售榜单、公告管理、订单管理 ⼆、数据库设计项⽬中实体E-R图的分析：⽤户实体User E-R图：商品实体products E-R图订单实体orders E-R图订单项orderitem E-R图公告栏实体notice E-R图根据E-R图来创建数据库及相关的表。 创建数据库、数据库名称为xbmubookstorecreate database if not exists xbmubookstore default charset=utf8mb4; 使⽤use xbmubookstore来使⽤该数据库use xbmubookstore;查看当前数据库中存在的表信息show tables; 创建表格 user表 三、SSM项⽬框架搭建使⽤Eclipse创建⼀个Web Project⼯程。 选择创建Dynamic Web Project项⽬，按向导给项⽬填写名称注意个性 Context root为系统的指定的上下⽂路径项⽬创建完成后的结构组织图如下：接着开始完成SSM的项⽬搭建⼯作 1.导⼊spring及springMVC相关的包在spring framework压缩包中的libs⽬录下将以下的jar包，复制到创建的项⽬的webapp–&gt;WEB-INF–lib⽬录下。 2.导⼊mybatis相关的包到mybatis的压缩包中，解压后复制以下jar包到项⽬⼯程的lib⽬录下。 3.导⼊数据库访问及数据库连接池相关的包 4.导⼊其它的相关的jar包 项⽬搭建后的结构图如下：然后，可以启动服务器，查看创建的初步结构。如果启动的过程顺利，没有错误出现，则可以进⾏⼀下步的配置⼯作。 1.配置SpringMVC的相关内容。因为要使⽤SpringMVC的技术来管理web应⽤的请求，所以需要指定替换原来Tomcat中的web应⽤处理请求的Servlet(DefaultServlet)。在项⽬的WEB-INF⽬录下的web.xml中进⾏如下的配置。 配置完成后，启动服务器检查配置的情况。这时会发现，启动过程中出现错误。 这是因为，配置了springmvc的DispatcherServlet后，系统会寻找spring初始化的配置⽂件，默认会到WEB-INF⽬录下寻找以servlet-name为名称前缀，并且后⾯为-servlet.xml的配置⽂件，因为还没有配置该⽂件，所以系统在启动时，初始化spring会报异常。所以要在WEB-INF⽬录下创建⼀个spring初始化配置⽂件：SpringMVC-servlet.xml 再次启动服务器，检查启动过程的⽇志，会发现没有错误出现。到此基本的配置完成。2.编写第⼀个控制器MyController⾸先，创建包路径: com.lz.xbmu在该包路径下新建包 controller及类MyController 当通过请求访问时，系统报异常：如果是循环访问的错误，则需要修改⼀下控制器的返回字符串。修改完循环引⽤访问的问题后，再启动访问发现404错误。这是因为没有配置视图解析器造成的，所以要配置视图解析器，可以参考帮助⽂档中的内容（web.pdf）。如果提示404未找到WEB-INF/jsp⽬录下的hello.jsp⽂件，说明还没有创建该⽂件。创建hello.jsp⽂件，再启动服务器。2.通过springmvc请求数据发送服务器启动后，访问地址时，会默认访问到webapp⽬录下的index.jsp⻚⾯，当访问到该⻚⾯时，其中的的jsp动作，forward会跳转访问到/mytest，也就是请求了MyControll中的相对应的⽅法，该⽅法的返回字符串就是跳转后的⻚⾯的名称。也就是WEB-INF/jsp/hello.jsp⻚⾯。@PostMapping注解的使⽤ModelAndView对象的使⽤通过pojo对象来包装数据中⽂乱码的解决，使⽤全局过滤器来解决。3.部署client前端的资源 在该⽂件夹中存在这资源内容和相关的jsp⻚⾯。将资源⽂件内容与jsp⻚⾯分别进⾏部署。⾸先在webapp⽬录下创建⼀个名为client的⽬录，然后将ad，bookcover，css，images，js这五个⽬录及其中的内容均考⻉到client⽬录中。在WEB-INF/jsp⽬录下再创建⼀个名为client的⽬录，然后将剩余的jsp⽂件都考⻉到该⽬录下。个性MyController类中的mytest请求访问⽅法的返回字符串路径：四、项⽬的前端模块应⽤1.部署相关的资源将资源分为两个部分，⻚⾯jsp都放到webapp–&gt;WEB-INF–&gt;jsp–&gt;⽬录内，可以提⾼安全性。只能通过SpringMVC的视图解析器才能访问到。其它的⻚⾯内的样式表、js、图⽚等内容都放到webapp–&gt;client⽬录下，这些内容是可以通过浏览器直接访问到。⻚⾯中的资源⽆法访问的原因：是因为在web.xml中配置了DispatcherServlet来处理全部的映射请求的路径，⽽该servlet是SpringMVC中的前端控制器，只负责处理url映射请求对应的处理器，⽽⽆法处理静态资源，所以⻚⾯中的静态资源是不能被调⽤。 2.处理静态资源的⽅法a.使⽤Tomcat的默认处理Servlet（defaultServlet）2.将DispatcherServlet的处理url映射请求进⾏设定3.使⽤SpringMVC的配置⽅式将静态资源的处理过程添加到SpringMVC-servlet.xml⽂件中去3.⽤户注册功能要通过注册⻚⾯来实现⽤户的注册功能。因为现在的jsp⻚⾯都在WEB-INF⽬录下，所以不能直接访问到。通过SpringMVC视图解析器来反回⼀个注册⻚⾯。⾸先分析client/index.jsp⻚⾯的组成 需要在对应的⻚⾯中去设置相关的链接或是请求的url在head.jsp⻚⾯中添加以下的内容新⽤户注册这样就可以通过请求UserController中的对应的处理器⽅法来返回指定的jsp⻚⾯。通过form表单提交注册⽤户的信息UserController.java 4.整合spring与mybatis⾸先将相关的spring包及mybatis的包导⼊到项⽬中去。然后是相关的数据库驱动、数据库连接、⽇志等相关的包也要导⼊到项⽬中去。然后就要在项⽬添加整合的配置⽂件。因为spring和springMVC都是springframework框架中的内容，所以它们之间不需要进⾏整合的配置，只是要对spring与mybatis及springmvc与mybatis进⾏整合。配置⽂件参考spring与mybatis整合的章节内容。使⽤三层结构来完成项⽬的功能模块。⾸先创建com.lz.xbmu.mapper包，在该包中创建接⼝及对应的映射⽂件。 } 接着创建⽤户接⼝及实现类 记得要检查所有的配置信息，否则会出现意外的错误。⽐如数据库名称，地址等配置信息的错误。现在已经完成了将前端的数据获取到，并通过业务⽅法再将数据使⽤持久化的机制保存到了指定的数据库。现在就完成了SSM框架的整合⼯作。五、后端业务处理及数据维护1.⽤户登录实现在系统的前端没有设计专⻔的⽤户登录连接，⽽是通过⼏种⽅式跳转到登录⻚⾯。当⽤户访问我的帐户时，因为要判断⽤户是否是登录状态，如是已经登录的状态，则跳转到我的帐户⻚⾯。不是登录状态时则要跳转到登录⻚⾯完成登录后才能访问我的帐户⻚⾯。如何检查⽤户是否是登录状态？在登录⻚⾯中填写⽤户的登录信息，在后端检查⽤户的信息，并且进⾏登录业务处理。我的帐户 "},{"title":"Spring知识点梳理：","date":"2021-11-27T06:50:20.000Z","url":"/2021/11/27/SpringFrame/","categories":[["undefined",""]],"content":" Spring知识点梳理：⼀、spring的基本知识官⽹地址：Spring | Home 1.如何使⽤Ioc技术实现Bean的装配。第⼀步，下载对应的Spring Framework包spring.io–&gt;选择 Projects –&gt;Spring Framework –&gt;点击超链接GitHub - spring-projects/spring-framework: Spring Framework在打开的⻚⾯中 查找 Access to Binaries 并点击跳转Spring Framework Artifacts · spring-projects/spring-framework Wiki · GitHub在该⻚⾯中 查找 Downloading a Distribution 并 . 跳转到下载⻚⾯.下载⻚⾯的地址是: Packages - repo.spring.io点击步骤： 在下图的画⾯中可以看到发布版本的下载路径：repo.spring.io通过该链接地址访问下载库下载完成的事，得到⼀个压缩包，解压该包得到Spring Framework的资源包。第⼀个⽂件夹 docs：⽂件⽂件夹中都是相关的⽂档。javadoc-apikdoc-apispring-framework-reference第⼆个⽂件夹 libs:这⾥⾯都是要⽤到的jar包，其中第个类别的jar包都有三种，分别是XXX-javadoc.jar，XXX-sources.ar，XXX-jar，它们分别代表使⽤api的⽂档，源代码，⼆进制的发布版。第三个⽂件夹 schema:Spring Framework的结构图:⼆、基础IoC案例：⼆、基础IoC案例：如何理解Spring容器管理Java对象，也就是说由Spring来完成Java Bean的创建⼯作。创建⼀个Java Project，创建类对象Student使⽤Spring的IoC技术来完成，Java对象的管理与使⽤。⾸先在项⽬中新添加⼀个⽂件夹在项⽬的根⽬录下，与src⽬录平⾏。然后将beans,context,core,expression，4个jar包拷⻉到该⽬录下(lib)，还要再添加⼀个commons-logging的jar包。接下来就可以使⽤Spring Framework技术。在项⽬的src⽬录下创建applicationContext.xml配置⽂件，⽤于描述spring容器。相关信息可以在下载的解压缩包中的docs⽬录中的spring-framework-reference⽬录中的pdf⽂件夹中的core.pdf⽂件中查找到具体内容。其中标签是定义容器中要管理的java类对象。 通过两种⽅式可以创建容器的上下⽂: 在Spring的配置⽂件中配置相关的bean: 1.使⽤类中定义的带参数的构造⽅法来创建bean 在这⾥需要注意，bean中指定的参数要与构造⽅法的参数个数相匹配。上⾯的配置就要与下⾯的构造⽅法相匹配。 2.利⽤getter/setter⽅法来配置bean:使⽤该试可以⾃由的指定要配置的属性值。 3.使⽤注解的⽅式来实现：注意使⽤注解的⽅式时，因为使⽤了AOP的机制，所以需要再导⼊spring-aop相关的jar包。spring-aop-5.2.18.RELEASE.jar，并且将该包添加到build path路径中去。Spring AOPAOP的全称是Aspect-Oriented Programming，即⾯向切⾯编程（也称⾯向⽅⾯编程）。它是⾯向对象编程（OOP）的⼀种补充，⽬前已成为⼀种⽐较成熟的编程⽅式。虽然AOP是⼀种新的编程思想，但却不是OOP的替代品，它只是OOP的延伸和补充。 Aspect：封装的⽤于横向插⼊系统功能（如事务、⽇志等）的类Joinpoint：在程序执⾏过程中的某个阶段点Pointcut：切⾯与程序流程的交叉点，即那些需要处理的连接点Advice（增强）：Advice 定义了在 Pointcut ⾥⾯定义的程序点具体要做的操作，它通过 before、after 和 around来区别是在每个 joint point 之前、之后还是代替执⾏的代码Target（⽬标对象）：织⼊ Advice 的⽬标对象Weaving（织⼊）：将切⾯代码插⼊到⽬标对象上，从⽽⽣成代理对象的过程 项⽬案例⼀，基于xml的配置⽅式在新建的项⽬中导⼊以下的包: 并将上⾯的包添加到项⽬环境中去。BuildTo–&gt;AddToBuildPath1.⾸先创建业务程序UserDao及实现类UserDaoImpl 基于注解的AOP的配置使⽤注解的myAspect 三、MyBatis的应⽤Hibernate 优点 Mybatis 优点1、hibernate是全⾃动，hibernate完全可以通过对象关系模型实现对数据库的操作，拥有完整的JavaBean对象与数据库的映射结构来⾃动⽣成sql。 2、功能强⼤，数据库⽆关性好，O/R映射能⼒强，需要写的代码很少，开发速度很快。 3、有更好的⼆级缓存机制，可以使⽤第三⽅缓存。 4、数据库移植性良好。 5、hibernate拥有完整的⽇志系统，hibernate⽇志系统⾮常健全，涉及⼴泛，包括sql记录、关系异常、优化警告、缓存提示、脏数据警告等1、易于上⼿和掌握，提供了数据库查询的⾃动对象绑定功能，⽽且延续了很好的SQL使⽤经验，对于没有那么⾼的对象模型要求的项⽬来说，相当完美。 2、sql写在xml⾥，便于统⼀管理和优化， 解除sql与程序代码的耦合。 3、提供映射标签，⽀持对象与数据库的orm字段关系映射 4、 提供对象关系映射标签，⽀持对象关系组建维护 5、提供xml标签，⽀持编写动态sql。 6、速度相对于Hibernate的速度较快Hibernate 缺点 MyBatis 缺点1、学习⻔槛⾼，精通⻔槛更⾼，程序员如何设计O/R映射，在性能和对象模型之间如何取得平衡，以及怎样⽤好Hibernate⽅⾯需要的经验和能⼒都很强才⾏ 2、hibernate的sql很多都是⾃动⽣成的，⽆法直接维护sql；虽然有hql查询，但功能还是不及sql强⼤，⻅到报表等变态需求时，hql查询要虚，也就是说hql查询是有局限的；hibernate虽然也⽀持原⽣sql查询，但开发模式上却与orm不同，需要转换思维，因此使⽤上有些不⽅便。总之写sql的灵活度上hibernate不及mybatis。 1、关联表多时，字段多的时候，sql⼯作量很⼤。 2、sql依赖于数据库，导致数据库移植性差。 3、由于xml⾥标签id必须唯⼀，导致DAO中⽅法不⽀持⽅法重载。4、对象关系映射标签和字段映射标签仅仅是对映射关系的描述，具体实现仍然依赖于sql。 5、DAO层过于简单，对象组装的⼯作量较⼤。 6、不⽀持级联更新、级联删除。 7、Mybatis的⽇志除了基本记录功能外，其它功能薄弱很多。 8、编写动态sql时,不⽅便调试，尤其逻辑复杂时。 9、提供的写动态sql的xml标签功能简单，编写动态sql仍然受限，且可读性低。三、MyBatis的应⽤1.Hibernate与MyBati之间的优点与缺点。Hibernate是全⾃动的，MyBatis是半⾃动的，需要⼿动编写与维护SQL语句。参考资料：Mybatis和Hibernate的区别、优缺点ORM的持久化概念。2.MyBatis的下载：GitHub - mybatis/mybatis-3: MyBatis SQL mapper framework for Java下载发⾏版的压缩包后解压，得到MyBatis的资源相关的⽂件夹。其中内容如上所示。其中的mybatis-3.5.X.pdf就是帮助⽂档，其中的内容可以学习使⽤。3.MyBatis的⼯作原理4.MyBatis的应⽤案例(1)根据客户的编号进⾏唯⼀结果的查询。(2)根据客户的名称进⾏模糊查询。创建名为mybatis的数据库，并在其中创建⼀个表，表名为t_customer 插⼊测试数据 创建⼀个项⽬，在项⽬中的lib⽬录下复制以下的jar包。commons-logging-1.2.jarlog4j-1.2.17.jarlog4j-api-2.17.0.jarmybatis-3.5.9.jar但是要访问MySQL数据库，还需要jdbc的驱动包。mysql-connector-java-8.0.28.jar将以上的jar包添加到项⽬中去。构建项⽬的内容：在classpath⽬录下分别创建mybatis的⽇志配置⽂件和核⼼配置⽂件 Global logging configurationlog4j.rootLogger=ERROR,stdout MyBatis logging configurationlog4j.logger.com.lz.xbmu=DEBUG Console output…log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 创建项⽬的基础包路径 com.lz.xbmu并创建po包及类Customer 在com.lz.xbmu.mapper包中创建映射⽂件CustomerMapper.xml 在com.lz.xbmu.test包中创建测试类MyBatis的核⼼配置及映射⽂件SqlSessionFactory核⼼对象的理解：•SqlSessionFactory对象是线程安全的，它⼀旦被创建，在整个应⽤执⾏期间都会存在。如果我们多次的创建同⼀个数据库的SqlSessionFactory，那么此数据库的资源将很容易被耗尽。为此，通常每⼀个数据库都会只对应⼀个SqlSessionFactory，所以在构建SqlSessionFactory实例时，建议使⽤单列模式。在使⽤SqlSession对象执⾏SQL语句时，要注意commit⽅法的使⽤情况。MyBatisUtils.java 分别实现selectList,insert,delete等⽅法的代码 核⼼配置⽂件：建议参考帮助⽂档中的内容。typeHandlersobjectFactoryplugins以上三个配置元素了解即可。元素⽤于对环境进⾏配置。MyBatis的环境配置实际上就是数据源的配置，我们可以通过元素配置多种数据源，即配置多种数据库。其它的配置，请参考帮助⽂档。映射⽂件的配置：CustomerMapper.xml 动态SQLif的使⽤当使⽤综合条件查询时，⽆法确定条件是否都存在或是可⽤，就需要if来判断条件是否可⽤。choose、when、otherwise当多个条件都可⽤时，依次按条件出现的顺序选择第⼀个可⽤的条件进⾏查询。如果所有条件均不满⾜，则使⽤otherwise中的条件进⾏查询。 ⽤于处理较特殊的情况，例如去除where 1=1这种情况会⾃动判断后⾯的条件是否成⽴，如果成⽴则添加where条件，并且⾃动处理and或or关键字。 bindMyBatis关联映射⼀对⼀关系⾸先创建两个表，分别是身份证表tb_idcard，和⼈员信息表tb_person项⽬的内容：IdCard.java IdCardMapper.xml 测试程序代码 多对多关系tb_producttb_ordersitemtb_ordersitem⾸先在数据中分析清楚多对多的关系分步查询select * from tb_orders where id=1;select * from tb_ordersitem where orders_id=1;select * from tb_product where id in (1,2);综合查询 多对多嵌套查询 多对多的嵌套结果查询 四、Spring整合Mybatis1.搭建环境框架的整合过程，就是将Spring及MyBatis的包导⼊到项⽬中，并且还需要将⼀个专⻔的包导⼊。这个专⻔的包就是⽤于整合Spring及MyBatis的包，因为Spring的发布要先于或是快于MyBatis的版本，所以这个包⼀般情况下是由MyBatis来提供的。⼀般情况下的名称为mybatis-spring.xxxx.jar这个样式的jar包。Spring框架中⽤到的包有： spring-aop-5.2.19.RELEASE.jarspring-aspects-5.2.19.RELEASE.jarspring-beans-5.2.19.RELEASE.jarspring-context-5.2.19.RELEASE.jarspring-core-5.2.19.RELEASE.jarspring-expression-5.2.19.RELEASE.jarspring-jdbc-5.2.19.RELEASE.jarspring-tx-5.2.19.RELEASE.jar因为spring的aop使⽤了外部的框架技术，所以还要导⼊aspectjweaver MyBatis框架中⽤到的包有：commons-logging-1.2.jarlog4j-1.2.17.jarlog4j-api-2.17.0.jarmybatis-3.5.9.jarSpring整合MyBatis的包：该包可以去Please Wait… | Cloudflare (mvnrepository.com)这个⽹站下载使⽤maven管理项⽬的可以参考: mybatis-spring-2.0.7.jar数据库的驱动包mysql-connector-java-8.0.28.jar数据源及数据连接池相关包可以到Apache⽹站下载：Welcome to The Apache Software Foundation!commons-dbcp2-2.9.0.jarcommons-pool2-2.11.1.jar到这⾥就完成了所包的导⼊⼯作。这⾥只是对Spring和MyBatis进⾏整合，并不涉及SpringMVC技术，所以没有导⼊SpringMVC相关的包。将以上的包添加到开发环境的路径中去。2.编写配置⽂件在类的根路径下创建db.properties⽂件，并配置如下内容。db.properties mybatis-config.xmllog4j.properties3.使⽤Mapper的⽅式开发这⾥需要在Sprng的配置⽂件中进⾏修改，来实现通过mapper的定义接⼝来调⽤相关的⽅法。4.事务及分层 应⽤案例全过程：1.创建Customer.java com.lz.xbmu.mapper.CustomerMapper.xml com.lz.xbmu.service.CustomerService com.lz.xbmu.controller.CustomerController 项⽬案例的结构图：五、SpringMVC⽂件上传与下载1.新建项⽬Dynamic Web Project选择新建项⽬类型为Dynamic Web Project指定相关的项⽬参数2.导⼊相关的包将以下的jar包拷⻉到项⽬中WEB-INF⽬录下的lib⽬录下commons-fileupload-1.4.jarcommons-io-2.11.0.jarcommons-logging-1.2.jarjavax.servlet-api-3.1.0.jarspring-aop-5.2.19.RELEASE.jarspring-beans-5.2.9.RELEASE.jarspring-context-5.2.9.RELEASE.jarspring-core-5.2.9.RELEASE.jarspring-expression-5.2.9.RELEASE.jarspring-web-5.2.19.RELEASE.jarspring-webmvc-5.2.19.RELEASE.jar将以上的包添加到环境变量中3.创建⽂件上传⻚⾯在webapp⽬录下创建jsp⻚⾯&lt;%@ page language=”java” contentType=”text/html; charset=UTF-8” pageEncoding=”UTF-8”%&gt;4.新建配置⽂件并进⾏配置web.xml package com.lz.xbmu.controller; ⽂件下载的实现（防⽌中⽂乱码，进⾏统⼀编码）下载⻚⾯的设置 请求处理的Controller "},{"title":"LeetCode102 二叉树的层序遍历","date":"2021-11-25T03:14:50.000Z","url":"/2021/11/25/LeetCode102/","categories":[["LeetCode","/categories/LeetCode/"]],"content":"层序遍历（宽度优先遍历）实则将非递归先序遍历中的栈（stack）转化成队列（queue） 此题方法两种大体结构相同 方法1：核心思想：宽度优先遍历，再循环中设置count，当count = 0时说明当前层已经输出完毕 方法2：核心思想：宽度优先遍历 + HashMap（记录节点对应层数）及找出最大层数；通过使用宽度优先遍历的方法将整个输出的结果存放在list中通过使用HashMap找到结点所对应的层数并找到最大层数，以方便后续的整体遍历产生List&lt;List&gt; "},{"title":"布隆过滤器（bloom filter）","date":"2021-11-15T12:26:17.000Z","url":"/2021/11/15/BloomFilter/","categories":[["algorithm","/categories/algorithm/"]],"content":" 原理直观的说，bloom算法类似一个hash set，用来判断某个元素（key）是否在某个集合中。和一般的hash set不同的是，这个算法无需存储key的值，对于每个key，只需要k个比特位，每个存储一个标志，用来判断key是否在集合中。 算法： 首先需要k个hash函数，每个函数可以把key散列成为1个整数 初始化时，需要一个长度为n比特的数组，每个比特位初始化为0 某个key加入集合时，用k个hash函数计算出k个散列值，并把数组中对应的比特位置为1 判断某个key是否在集合时，用k个hash函数计算出k个散列值，并查询数组中对应的比特位，如果所有的比特位都是1，认为在集合中。 优点：不需要存储key，节省空间相比于其它的数据结构，布隆过滤器在空间和时间方面都有巨大的优势。布隆过滤器存储空间和插入/查询时间都是常数。另外, Hash 函数相互之间没有关系，方便由硬件并行实现。布隆过滤器不需要存储元素本身，在某些对保密要求非常严格的场合有优势。 缺点： 算法判断key在集合中时，有一定的概率key其实不在集合中(随着存入的元素数量增加，误算率随之增加。但是如果元素数量太少，则使用散列表足矣) 无法删除 典型的应用场景：某些存储系统的设计中，会存在空查询缺陷：当查询一个不存在的key时，需要访问慢设备，导致效率低下。比如一个前端页面的缓存系统，可能这样设计：先查询某个页面在本地是否存在，如果存在就直接返回，如果不存在，就从后端获取。但是当频繁从缓存系统查询一个页面时，缓存系统将会频繁请求后端，把压力导入后端。 这是只要增加一个bloom算法的服务，后端插入一个key时，在这个服务中设置一次需要查询后端时，先判断key在后端是否存在，这样就能避免后端的压力。 False positives 概率推导假设 Hash 函数以等概率条件选择并设置 Bit Array 中的某一位，m 是该位数组的大小，k 是 Hash 函数的个数，那么位数组中某一特定的位在进行元素插入时的 Hash 操作中没有被置位的概率是： "},{"title":"一致性哈希算法","date":"2021-11-15T12:02:16.000Z","url":"/2021/11/15/ConsistentHash/","categories":[["algorithm","/categories/algorithm/"]],"content":" 原理基本概念 一致性哈希算法（Consistent Hashing）最早在论文《Consistent Hashing and Random Trees: Distributed Caching Protocols for Relieving Hot Spots on the World Wide Web》中被提出。简单来说，一致性哈希将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0-2^32-1（即哈希值是一个32位无符号整形），整个哈希空间环如下： 整个空间按顺时针方向组织。0和232-1在零点中方向重合。 下一步将各个服务器使用Hash进行一个哈希，具体可以选择服务器的ip或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置，这里假设将上文中四台服务器使用ip地址哈希后在环空间的位置如下： 接下来使用如下算法定位数据访问到相应服务器：将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器。 例如我们有Object A、Object B、Object C、Object D四个数据对象，经过哈希计算后，在环空间上的位置如下： 根据一致性哈希算法，数据A会被定为到Node A上，B被定为到Node B上，C被定为到Node C上，D被定为到Node D上。 下面分析一致性哈希算法的容错性和可扩展性。现假设Node C不幸宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重定位到Node D。一般的，在一致性哈希算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响。 下面考虑另外一种情况，如果在系统中增加一台服务器Node X，如下图所示： 此时对象Object A、B、D不受影响，只有对象C需要重定位到新的Node X 。一般的，在一致性哈希算法中，如果增加一台服务器，则受影响的数据仅仅是新服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它数据也不会受到影响。 综上所述，一致性哈希算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。 另外，一致性哈希算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜问题。例如系统中只有两台服务器，其环分布如下， 此时必然造成大量数据集中到Node A上，而只有极少量会定位到Node B上。为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以在服务器ip或主机名的后面增加编号来实现。例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点： 同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到“Node A#1”、“Node A#2”、“Node A#3”三个虚拟节点的数据均定位到Node A上。这样就解决了服务节点少时数据倾斜的问题。在实际应用中，通常将虚拟节点数设置为32甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布。"},{"title":"PythonNote","date":"2021-10-25T11:30:34.000Z","url":"/2021/10/25/PythonNote/","categories":[["Python笔记","/categories/Python%E7%AC%94%E8%AE%B0/"]],"content":" &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 第一章注：运行文件末尾的.py指这是一个python程序-&gt;python解释器读取 ·变量在程序中可随时修改变量的值，而python将始终记录变量的最新值。 ··有关变量的规则·变量名只能包含字母、数字和下划线。变量可以字母和下划线开头，但是不能以数字开头 ·变量名不能包含空格，但可使用下划线来分隔其中的单词。 ·不要将python关键字和函数名作变量名，即不要使用python保留用于特殊用途的单词 ·变量名应该简短又具有描述性。 ·慎用小写字母l和大写字母o，因为他们可能被人错看成数字1和0. ··当输入程序有误时，解释器就会报错。·字符串字符串就是一系列字符，用引号括（单引号和双引号）起来的都是字符串。 ··修改字符的大小写 输出Ada Lovelace 方法是Python可对数据执行的操作。 在name.title()中，name后 面的句点（.）让Python对变量name执 行方法title()指定的操作。每个方法后面都跟着一对括号， 这是因为方法通常需要额外的信息来完成其工作。这种信息是在括号内提供的。函数title()不 需要额外的信息，因此它后面的括号是空的。 title()以首字母大写的方式显示每个单词，即将每个单词的首字母都改为大写。Upper()将字符串转换成大写；lower()将字符串转换成小写； ··合并字符串 Python使用加号（+）来合并字符串。在这个示例中，我们使用+来合并first_name、空格和 last_name，以得到完整的姓名 ··使用制表符或换行符来添加空白/t-&gt;tab制表符；/n-&gt;换行 ··删除空白rstrip()-&gt;确保字符串末尾没有空白（暂时性的删除）；要永久删除这个字符串中的空白，必须将删除操作的结果存回到变量中 Lstrip()-&gt;确保字符串的开头没有空白 strip()-&gt;确保字符串开头和结束都没有空白 ··使用字符串时避免语法错误种语法错误表明，在解释器看 来，其中的有些内容不是有效的Python代码。（有撇号使用双引号） ··python 2中的print语句 print “Hello Python 2.7 world!”·数字··整数python支持运算次序；，空格不影响Python计算表达式的方式；python使用两个乘号表示乘方运算； 如32=9、106=1000000； ··浮点数python将带小数点的数字都称浮点数。加减乘除都适用，但需要注意的是，结果包含的小数位数可能是不确定的。如0.2+0.1=0.3000000000000000004；暂时忽略 多余的小数位数即可； ··使用函数str()避免类型错误str()-&gt;将非字符串值表示字符串如age=23 message = “Happy” + str(age)+”rd Birthday!” ··python 2 中的整数3/2=1;整数除法的结果只包含整数部分，小数部 分被删除。请注意，计算整数结果时，采取的方式不是四舍五入，而是将小数部分直接删除;3.0/2=1.5 3/2.0=1.5 3.0/2.0=1.5; ·注释··如何编写注释在Python中，注释用井号（#）标识。井号后面的内容都会被Python解释器忽略 ··该编写什么样的注释编写注释的主要目的是阐述代码要做什么，以及是如何做的。 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 第二章·列表是什么列表有一系列按特定顺序排列的元素组成。 ··访问列表元素只需将元素的位置或索引告诉python如bicycles = [‘trek’, ‘cannondale’, ‘redline’, ‘specialized’] print(bicycles[0]) 输出 Trek ··索引从0而不是1开始 输出cannondale specialized// 输出specycles 索引-2返回倒数第二个列表元素， 索引-3返回倒数第三个列表元素，以此类推； ··使用列表中的各个值 输出My first bicycle was a Trek. ·修改、添加和删除元素··修改列表元素要修改列表元素，可指定列表名和要修改 的元素的索引，再指定该元素的新值 ··在列表中添加元素append()-&gt;在列表末尾添加元素;(动态的添加列表)：motorcycles.append(‘ducati’) Insret()-&gt;在列表中添加元素； 输出[‘ducati’, ‘honda’, ‘yamaha’, ‘suzuki’] ··从列表中删除元素·使用del语句删除元素；del motorcycles[0] ·pop()-&gt;删除元素 （可删除列表末尾的元素，并让你能够接着使用它）pop(-1)==pop() 输出[‘honda’, ‘yamaha’, ‘suzuki’] [‘honda’, ‘yamaha’] suzuki 判断标准：如果你要从列表 中删除一个元素，且不再以任何方式使用它，就使用del语句；如果你要在删除元素后还能继续 使用它，就使用方法pop()。 ·remove()-&gt;你不知道要从列表中删除的值所处的位置。如果你只知道要删除的元素的值;motorcycles.remove(‘ducati’) 注意: 方法remove()只删除第一个指定的值。如果要删除的值可能在列表中出现多次，就需要z使用循环来判断是否删除了所有这样的值 ·组织列表··sort（）-&gt;对数列永久性排序;cars.sort().sort(reverse=True)-&gt;以按与字母顺序相反的顺序排列列表元素;cars.sort(reverse=True) ··sorted()-&gt;对列表进行临时排序；sorted(cars)sorted(XXXXX,reverse=True)-&gt;按与字母顺 序相反的顺序显示列表 ··倒这打印列表reverse()-&gt;反转列表元素的排列顺序;cars.reverse() 注意，reverse()不是指按与字母顺序相反的顺序排列列表元素，而只是反转列表元素的排 列顺序 ··len()-&gt; 确定列表长度；len(cars)··使用列表时避免索引错误Python无法理解你指定的索引 ·索引-1：访问列表最后一个元素&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 第三章遍历整个列表使用for循环 for AAA in BBB //将BBB复制给AAA； 深入地研究循环在for循环中执行更多的操作 for语句中后面语句执行缩进的语句； 在for循环结束后执行一些操作没有缩进的代码都只执行一次，而不会重复执行 避免缩进错误忘记缩进忘记缩进额外的代码行不必要的缩进循环后不必要的缩进遗漏了冒号（语法错误）创建数值列表range()-&gt;生成一系列的数字; 输出： 1 2 3 4//第一个值开始，第二个值前一个结束；即此例不输出5 使用range() 创建数字列表list()-&gt;将数字转换为列表； 输出： 对数字列表执行简单的统计计算min()-&gt;数字列表中的最小值； max()-&gt;数值列表中的最大值； sum()-&gt;数值列表中的和； 列表解析 两个输出语句相同结果如下： 使用列表的一部分切片 输出: [0:3]-&gt;[:3] [2:]-&gt;从2开始到最后一个 [-3:]-&gt;从倒数第三个开始到最后一个 遍历切片 输出: 复制列表 friend_foods = my_foods[:]//之后改变friend_foods改变时my_foods不会改变 不能friend_foods = my_foods//改变一个其他的一个也会改变 元祖定义元祖元祖犹如列表，但使用圆括号，列表是可以改变的但元祖不可以改变dimensions = (200, 50) 修改元素变量不能修改元组的元素，但可以给存储元组的变量赋值，重新赋值 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;第四章一个简单示例 条件测试每条if语句的核心都是一个值为True或False的表达式，这种表达式被称为条件测 检测是否相等==-&gt;判断左右是否相等（字符的大小也会影响） 检测是否不相等！=-&gt;判断左右是否不相等 比较数字== != &lt; &lt;= &gt; &gt;= 检查多个条件and -&gt; 相当于 &amp;&amp; or -&gt; 相当于 ||（当左边为真时在不经过右边） 检测特定值是否包含在列表中 检测特定值是否不包含在列表中 输出 布尔表达式条件测试的别名。与条 件表达式一样，布尔表达式的结果要么为True，要么为False if语句简单的if语句if age &gt;= 18: if-else语句if-elif-else语句-&gt;C语言if-else if - else语句使用if语句处理列表检查特殊元素 确定列表不是空的i=[] if i://判断i是不是空列表 使用多个列表 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;第五章使用字典 alien_0 = {‘color’: ‘green’, ‘points’: 5} //使用大括号 访问字典中的值 输出结果： str()-&gt; 函数将对象转化为适于人阅读的形式 添加键-值对 alien_0[‘y_position’] = 25 —-‘[y_position’:25] 先创建一个空字典 alien_0 = {}修改字典中的值 次指定字典名、用方括号括起的键以及与该键相关联的新值，类似重新添加键-值对 删除键—值对 del alien_0[‘points’]由类似对象组成的字典遍历字典遍历所有的键—值对items() -&gt;方法以列表返回可遍历的(键, 值) 元组数组。 遍历字典中的所有键keys()-&gt; 方法返回一个可迭代对象“键”，for name in favorite_languages.keys(） list()-&gt; 来转换为列表。 遍历字典中的所有值Values()-&gt;返回值列表 for name in favorite_languages.keys(） 嵌套字典列表 range()-&gt; 函数可创建一个整数列表，一般用在 for 循环中 range(1, 11) # 从 1 开始到 11 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 字典中我们可以再次嵌套字典；输出时用for即可输出 在字典中储存列表 输出 在字典中储存字典 另一种输出方法 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;第六章函数input （）的工作原理Input()-&gt;让程序暂停运行，等待用户输入（用户按回车后运行） message = input(“Tell me something, and I will repeat it back to you: “) print(message) 编写清晰的程序&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;第七章定义函数 “””显示简单的问候语””” #文档字符串的注释用三个括号 print(“Hello!”) greet_user() 中间的称为函数体 向函数传递信息 def greet_user(username): #添加username可指定任何值 greet_user(‘jesse’) #调用函数 （可调用任意次） 实参和形参以上面代码username是形参，在最后一行greet_user(“jesse”)中，值“jesse”是实参 实参是调用函数时传递给函数的信 息 传递实参位置实参的关联方式是基于实参的顺序。这种关联方式被称为位置实参 def describe_pet(animal_type, pet_name): describe_pet(‘hamster’, ‘harry’) describe_pet(‘dog’, ‘willie’) #要再描述一个宠物，只需再次调用describe_pet()即可 关键字实参关键字实参是传递给函数的名称—值对 describe_pet(animal_type=’hamster’, pet_name=’harry’) describe_pet(pet_name=’harry’, animal_type=’hamster’) 以上两个函数调用是等效的（实参的顺序无关紧要） 默认值编写函数时，可给每个形参指定默认值。在调用函数中给形参提供了实参时，Python将使用 指定的实参值；否则，将使用形参的默认值。因此，，给形参指定默认值后，可在函数调用中省略 相应的实参。 默认值只需在定义时赋值：def describe_pet(pet_name, animal_type=’dog’): 等效的函数调用避免实参错误实现一一对应 返回值（函数返回的值return）返回简单值 def get_formatted_name(first_name, last_name): “””返回整洁的姓名”””  full_name = first_name + ‘ ‘ + last_name  return full_name.title() //返回函数值  musician = get_formatted_name(‘jimi’, ‘hendrix’) print(musician) 让实参变成可选的def get_formatted_name(first_name, last_name, middle_name=’’): 再用if判断语句来判断middle_name中有无值出现 返回字典defbuild_person(first_name,last_name): “””返回一个字典，其中包含有关一个人的信息””” person={‘first’:first_name,’last’:last_name} returnperson musician=build_person(‘jimi’,’hendrix’) print(musician) 输出{‘first’: ‘jimi’, ‘last’: ‘hendrix’} 结合使用函数和while循环while True: print(“\\nPlease tell me your name:”) print(“(enter ‘q’ at any time to quit)”) 简单whlie死循环；可用break退出循环； 传递列表defgreet_users(names): “””向列表中的每位用户都发出简单的问候””” fornameinnames: msg=”Hello,”+name.title()+”!” print(msg) usernames=[‘hannah’,’ty’,’margot’] greet_users(usernames) 在函数中修改列表defprint_models(unprinted_designs,completed_models): “””模拟打印每个设计，直到没有未打印的设计为止 打印每个设计后，都将其移到列表completed_models中””” whileunprinted_designs: current_design=unprinted_designs.pop()#将unprinted_designs中最后一个赋给currnt_desige #模拟根据设计制作3D打印模型的过程 print(“Printingmodel:”+current_design) completed_models.append(current_design)#将unprinted_desigens倒叙赋给completed_models defshow_completed_models(completed_models): “””显示打印好的所有模型””” print(“\\nThefollowingmodelshavebeenprinted:”) forcompleted_modelincompleted_models: print(completed_model) unprinted_designs=[‘iphonecase’,’robotpendant’,’dodecahedron’] completed_models=[] print_models(unprinted_designs,completed_models) show_completed_models(completed_models) 禁止函数修改可向函数传 递列表的副本而不是原件 function_name ( list_name [:])//切片表示法创建列表的副本 传递任意值数量的实参def make_pizza(*toppings): “””打印顾客点的所有配料””” print(toppings) make_pizza(‘pepperoni’) make_pizza(‘mushrooms’, ‘green peppers’, ‘extra cheese’) 形参名*toppings中星号创建一个名为toppings的空元组； 结合使用位置实参和任意数量实参如果要让函数接受不同类型的实参，必须在函数定义中将接纳任意数量实参的形参放在 后。Python先匹配位置实参和关键字实参，再将余下的实参都收集到后一个形参中。 def make_pizza(size, *toppings): 任意函数数量的关键字实参defbuild_profile(first,last,**user_info): “””创建一个字典，其中包含我们知道的有关用户的一切””” profile={} profile[‘first_name’]=first profile[‘last_name’]=last forkey,valueinuser_info.items(): profile[key]=value returnprofile user_profile=build_profile(‘albert’,’einstein’,location=’princeton’,field=’physics’)//键-值对 print(user_profile) 输出{‘first_name’: ‘albert’, ‘last_name’: ‘einstein’, ‘location’: ‘princeton’, ‘field’: ‘physics’} 形参名**user_info两个星号创建一个名为user_info的空字典 将函数储存在模块中函数的优点之一是，使用它们可将代码块与主程序分离。 import语句允许在当前运行的程序文件中使用模块中的代码。 导入整个模块Import XXXX-&gt;在其他文件中调用函数的前提 import pizza pizza.make_pizza(16, ‘pepperoni’) pizza.make_pizza(12, ‘mushrooms’, ‘green peppers’, ‘extra cheese’) 要写pizza.make_pizza：pizza不能省 导入特定的函数通过用逗号分隔函数名，可根据需要从模块中导入任意数量的函数： from module_name import function_0 , function_1 , function_2 from pizza import make_pizza make_pizza(16, ‘pepperoni’) make_pizza(12, ‘mushrooms’, ‘green peppers’, ‘extra cheese’) 可以省去pizza 使用as给函数指定别名如果要导入的函数的名称可能与程序中现有的名称冲突，或者函数的名称太长，可指定简短 而独一无二的别名——函数的另一个名称 给函数make_pizza()指定了别名mp()。这是在import语句中使用make_pizza as mp实现的， 关键字as将函数重命名为你提供的别名： from pizza import make_pizza as mp mp(16, ‘pepperoni’) mp(12, ‘mushrooms’, ‘green peppers’, ‘extra cheese’) 使用as给模块指定别名import pizza as p // p.make_pizza(16, ‘pepperoni’) p.make_pizza(12, ‘mushrooms’, ‘green peppers’, ‘extra cheese’) 导入模块中的所有函数使用星号（*）运算符可让Python导入模块中的所有函数： 函数编写指南应给函数指定描述性名称，且只在其中使用小写字母和下 划线 给形参指定默认值时，等号两边不要有空格： def function_name ( parameter_0 , parameter_1 =’ default value ‘) 对于函数调用中的关键字实参，也应遵循这种约定： function_name ( value_0 , parameter_1 =’ value ‘) "},{"title":"hexo-relevant","date":"2021-10-22T13:46:27.000Z","url":"/2021/10/22/hexo-relevant/","categories":[["hexo","/categories/hexo/"]],"content":" 修改博客内容整体上边界目录：[simon-yian]–&gt;[themes]–&gt;[next]–&gt;[source]–&gt;[css]–&gt;[_common]–&gt;[scaffolding]–&gt;[normalize.styl] 第十八行/** Remove the margin in all browsers. / "},{"title":"在VMware16中创建虚拟机安装ubuntu 21.04系统","date":"2021-10-18T11:59:48.000Z","url":"/2021/10/18/VMware-ubuntu/","categories":[["VMware","/categories/VMware/"]],"content":" 此篇是创建VMware16虚拟机安装ubuntu21.04系统的超详细操作过程，希望对小白白有所帮助 安装环境： windows 10 VMware 16安装包：我用阿里云盘分享了「VMware-workstation-full-16.1.2-17966106.exe」，你可以不限速下载🚀复制这段内容打开「阿里云盘」App 即可获取链接： ubuntu 21.04镜像：链接：提取码：n9ms 安装VMware 161、 直接双击下载好的VMware，这个过程可能会显示重新启动系统，那你点就是了。重新启动后再次双击下载好的VMware，然后点击【下一步】。 2、勾选【我接受许可协议中的条款】，点击【下一步】 3、可以默认，也可更改安装位置 4、选择安装位置，然后点击【确定】 5、点击【下一步】 6、取消勾选【启动时检查产品更新】和【加入VMware客户体验改进计划】，点击【下一步 7、点击【下一步】 8、点击【安装】 9、正在安装，等待几分钟 10、点击【许可证】 11、框中输入许可证：ZF3R0-FHED2-M80TY-8QYGC-NPKYF，（复制粘贴就可以）然后点击【输入】 12、点击【完成】 恭喜你这会你的虚拟机已经安装好了，是不是直接点击下一步就可以 在VMware中安装ubuntu 21.04系统1、双击打开你创建在桌面的虚拟机，然后点击【创建新的虚拟机】 2、选择【典型】（默认便是典型），点击【下一步】 3、选择【稍后安装操作系统】，点击【下一步】 4、客户机操作系统选择【Linux】，版本选择【Ubuntu64位】，然后点击【下一步】 5、位置可更改，点击【下一步】 6、最大磁盘大小【20】GB，选择【将虚拟机磁盘拆分成多个文件】，然后点击【下一步】 7、点击【自定义硬件】 8、选择【内存】，此虚拟机的内存设为【2048MB】 9、选择【新CD/DVD(TATA)】后选择【使用ISO映像文件】，点击【浏览】，找到下载后文件夹里面的【ubuntu-21.04-desktop-amd64.iso】这个镜像并选择！ 10、选择【网络适配器】，然后选择【仅主机模式】 11、选择【USB控制器】，点击【移除】 12、选择【打印机】，点击【移除】 13、点击【关闭】 14、点击【完成】 实在没有耐心放图片了，等闲了再贴图片吧,相信自己即使看文字你也可以安装完成的，加油！ 15、点击【开启此虚拟机】，等待开启 16、择【中文简体】，点击【安装Ubuntu】 17、点击【继续】 18、点击【继续】 19、点击【现在安装】 20、点击【继续】 21、这里默认【Shanghai】就OK 22、创建用户账号（记住密码哦！）。不要担心你的计算机名是什么，你只需要输入姓名，计算机名就会自动生成。然后点击[继续] 23、安装中，耐心等待（这个可能需要多点时间） 24、点击【现在重启】，重启一会看屏幕中下方转圈其他都不动，键盘上点击【enter】 25、点击账户，我这里是【simon-yian】 26、输入之前创建用户账号时设的密码，然后点击【登录】 27、至此Ubuntu系统安装完成！ 如果你觉得可以千万不要忘记动动你的小手，赞赏一下贫困的博客主记得收藏啊，以后会有更好的内容给您分享"},{"title":"makedown进阶（改变字体颜色，大小，设置文字背景，调整图片大小设置剧中）","date":"2021-10-18T01:29:55.000Z","url":"/2021/10/18/picture/","categories":[["hexo","/categories/hexo/"]],"content":" 基础知识： Markdown 通过简单标记语法，使普通文本内容具有一定格式。但它本身不支持修改字体、字号与颜色等功能的。CSDN-markdown 编辑器是其衍生版本，支持基于 PageDown ( Stack Overflow）所使用的编辑器的扩展功能（如表格、脚注、内嵌HTML、内嵌 LaTeX 等等）。 Size：规定文本的尺寸大小，取值从 1 到 7 ，浏览器默认值是 3. 一、添加照片的两种方法，第二种可改变图片大小及位置注：你可以上传到图床的…图床访问速度比GithubPage更快，不用担心文章加载出来了但图片迟迟没有加载出的情况。国内比较稳定的图床几个有sm.ms，imgchr等 第一种： 第二种（可改变大小及显示位置）： 二、更改字体、大小、颜色 效果如下： 我是黑体字我是微软雅黑我是华文彩云我是红色我是绿色我是蓝色我是尺寸我是黑体，绿色，尺寸为5 三、为文字添加背景色 由于 style 标签和标签的 style 属性不被支持，所以这里只能是借助 table, tr, td 等表格标签的 bgcolor 属性来实现背景色。故这里对于文字背景色的设置，只是将那一整行看作一个表格，更改了那个格子的背景色（bgcolor） 效果如下： 背景色yellow"},{"title":"使用hexo+github搭建博客","date":"2021-10-18T01:16:36.000Z","url":"/2021/10/18/hexo-github-BuildBlog/","categories":[["hexo","/categories/hexo/"]],"content":" 搭建博客千千万，最后受欢迎的9还是Hexo和Jekyll,用户用的非常多的两个静态博客生成系统。本文就介绍利用Hexo结合github page来搭建个人博客。 基础知识什么是Hexo？Hexo 是一个基于 node.js 制作的快速、简洁且高效的博客框架。Hexo 可以将我们撰写的 Markdown 文档解析渲染成静态的 HTML 网页。 Hexo和Jekyll的区别·本地环境Jeklly 是由 Ruby 语言编写，需要到官网下载并安装 RubyInstaller。Hexo 则需要安装 Node.js 环境。网上经常看到很多人吐槽安装 Jekyll 经常碰到各种问题。 ·速度说是比较 Hexo 和 Jeklly 这两个框架，其实要比较 Ruby 和 Node.js 的运行速度。Node.js 是一个 Javascrip t运行环境(Runtime)。实际上它是对 Google V8 引擎进行了封装。众所周知，Google JS Runtime 速度非常快，性能非常好。在本地预览上，Jekyll 是生成了页面然后进行预览，而 Hexo 是没有在根目录生成文件的，速度也快不少。因此，Hexo 在性能和速度上面更胜一筹。 ·部署Jeklly 是将整个工程源码上传到 Github 仓库，然后 Github 会自动生成静态文件。而 Hexo 需要事先在本地生成整个站点页面，再将 Html 文件、资源文件等上传到 Github 上。 ·主题Jekyll 使用 Liquid；它是有 Ruby 语言编写的开源模板语言。Hexo 使用的是 EJS；EJS 是 JavaScript 模板库，用来从 JSON 数据中生成 HTML 字符串。EJS 相对比较复杂，所以可实现的功能更加的多。从开发一个主题难度上看，Hexo 实现起来更方便、更简单些。 安装环境1、本机系统：Windows 10（64位）2、Node.js：v6.9.2LTS（64位） 前期准备安装Node.js简单的说 Node.js 就是运行在服务端的 JavaScript。Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。打开官网下载链接Node.js: (选择长期服务，版本更稳定) 下载完成之后直接双击安装包，只需点击下一步（默认所有选项），然后改变安装路径即可。 测试安装是否成功： 按【win+R】键，输入cmd，再按回车弹出命令窗口 输入：(显示版本行) 显示结果： 即安装成功； 安装gitGit是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。 也是Linus Torvalds为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件。 从一般开发者的角度来看，git有以下功能：1、从服务器上克隆完整的Git仓库（包括代码和版本信息）到单机上。2、在自己的机器上根据不同的开发目的，创建分支，修改代码。3、在单机上自己创建的分支上提交代码。4、在单机上合并分支。5、把服务器上最新版的代码fetch下来，然后跟自己的主分支合并。6、生成补丁（patch），把补丁发送给主开发者。 打开官网下载链接： (选择windows版本即可) 下载完成之后直接双击安装包，只需点击下一步（出下图外选项，默认所有选项），然后改变安装路径即可。 测试是否安装成功： 按【win+R】键，输入cmd，再按回车弹出命令窗口，再输入： 显示结果: 开始搭建在Git安装目录中点击【git-bash.exe】,输入命令：（输入时引号不要删） 然后按四次【enter】即可，生成后如下图： 打开Github,点击头像–&gt;【setting】 点击【SSH and GPG keys】–&gt;【New SSH key】 输入title（可以随便输），但Key你需要用记事本或Notepad++打开磁盘中c:/用户/用户名/.ssh/id_rsa.pub然后复制粘贴里面的内容到key中，最后点击【ADD SSH key】； 安装hexo在想要搭建博客的目录下创建文件夹名为blog，按【win+R】键，输入cmd，再按回车弹出命令窗口，cd到创建的文件夹下，输入： 不要关闭刚才的命令窗口，在刚才的窗口中初始化hexo，输入： 在博客目录中安装依赖在刚才的窗口中 安装完成之后进行测试，窗口中输入： 在浏览器上输入 localhost:5555 安装Sublime Text打开官网下载链接： （点击DPWNLOAD FOR WINDOWS） 下载完成之后直接双击安装包，只需点击下一步（默认所有选项），然后改变安装路径即可。 打开Sublime 直接将博客目录拖进Sublime即可； hexo发布到Github使用Sublime打开博客根目录中_config.yml 修改第16行的url 改为自己的网址（如 https://自己的博客名.github.io ） 打开Github网页点击【Your repositories】 最后复制链接 在_config.yml文件最后一行添加repo 将你复制的链接添加到repo之后，用引号隔开（切记引号后面必须要有空格） 在最后一行添加 type后添加git 如下图 在博客根目录下添加插件： 获取个人访问令牌对密码身份验证的支持已于 2021 年 8 月 13 日移除。现在改用个人访问令牌。简单点说就是需要把你的密码换成 token。 在个人设置页面，找到 Settings找到 Developer settings选择个人访问令牌 Personal access tokens，然后点击生成令牌 Generate new token设置 token 的有效期，访问权限等，生成令牌 Generate token如下为生成的令牌 注意记得把 token 保存下来，当你再次刷新网页的时候，就没办法看见了 最后，把 token 直接添加远程仓库链接中，这样就可以避免同一个仓库每次提交代码都要输入 token 了。 添加到如下图位置：（使用“@”和后面内容隔开） git中设置你的用户名和邮件名 这一点很重要，因为每一个 Git 提交都会使用这些信息，它们会写入到你的每一次提交中。 生成提交 打开你的浏览器： 恭喜您，您的博客现在已制作完成，现在只需要添加你喜欢的主题既可以开始你的博客之旅了。 添加主题hexo主题网站： 找到你喜欢的主题，例如next主题 点击【next】 按照文件中所说下载和修改即可 在博客根目录中打开【Git Bash Here】 安装完成后，打开 Hexo 配置文件(_config.yml)并将theme变量设置为next. 现在来介绍常用的Hexo 命令npm install hexo -g #安装Hexonpm update hexo -g #升级hexo init #初始化博客 命令简写hexo n “我的博客” == hexo new “我的博客” #新建文章hexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署 hexo server #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存，若是网页正常情况下可以忽略这条命令"},{"title":"Hello World","date":"2021-10-11T13:35:33.520Z","url":"/2021/10/11/hello-world/","categories":[["undefined",""]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 顾浩儿Quick StartCreate a new post More info: Writing Run server More info: Server 清除缓存文件为了避免不必要的错误，在生成静态文件前，强烈建议先运行以下命令： Generate static files More info: Generating Deploy to remote sites More info: Deployment"}]